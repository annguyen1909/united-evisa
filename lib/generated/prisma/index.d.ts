
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Application
 * 
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>
/**
 * Model ApplicationDocument
 * 
 */
export type ApplicationDocument = $Result.DefaultSelection<Prisma.$ApplicationDocumentPayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model CardHolder
 * 
 */
export type CardHolder = $Result.DefaultSelection<Prisma.$CardHolderPayload>
/**
 * Model Case
 * 
 */
export type Case = $Result.DefaultSelection<Prisma.$CasePayload>
/**
 * Model CaseSequence
 * 
 */
export type CaseSequence = $Result.DefaultSelection<Prisma.$CaseSequencePayload>
/**
 * Model CustomRequirement
 * 
 */
export type CustomRequirement = $Result.DefaultSelection<Prisma.$CustomRequirementPayload>
/**
 * Model Destination
 * 
 */
export type Destination = $Result.DefaultSelection<Prisma.$DestinationPayload>
/**
 * Model DocumentMapping
 * 
 */
export type DocumentMapping = $Result.DefaultSelection<Prisma.$DocumentMappingPayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model EmailThread
 * 
 */
export type EmailThread = $Result.DefaultSelection<Prisma.$EmailThreadPayload>
/**
 * Model Passenger
 * 
 */
export type Passenger = $Result.DefaultSelection<Prisma.$PassengerPayload>
/**
 * Model Risk
 * 
 */
export type Risk = $Result.DefaultSelection<Prisma.$RiskPayload>
/**
 * Model RiskActivity
 * 
 */
export type RiskActivity = $Result.DefaultSelection<Prisma.$RiskActivityPayload>
/**
 * Model RiskDocument
 * 
 */
export type RiskDocument = $Result.DefaultSelection<Prisma.$RiskDocumentPayload>
/**
 * Model StripeActivity
 * 
 */
export type StripeActivity = $Result.DefaultSelection<Prisma.$StripeActivityPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskActivity
 * 
 */
export type TaskActivity = $Result.DefaultSelection<Prisma.$TaskActivityPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model VisaType
 * 
 */
export type VisaType = $Result.DefaultSelection<Prisma.$VisaTypePayload>
/**
 * Model password_reset_tokens
 * 
 */
export type password_reset_tokens = $Result.DefaultSelection<Prisma.$password_reset_tokensPayload>
/**
 * Model sessions
 * 
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): Prisma.ApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applicationDocument`: Exposes CRUD operations for the **ApplicationDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApplicationDocuments
    * const applicationDocuments = await prisma.applicationDocument.findMany()
    * ```
    */
  get applicationDocument(): Prisma.ApplicationDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cardHolder`: Exposes CRUD operations for the **CardHolder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CardHolders
    * const cardHolders = await prisma.cardHolder.findMany()
    * ```
    */
  get cardHolder(): Prisma.CardHolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.case`: Exposes CRUD operations for the **Case** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cases
    * const cases = await prisma.case.findMany()
    * ```
    */
  get case(): Prisma.CaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseSequence`: Exposes CRUD operations for the **CaseSequence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseSequences
    * const caseSequences = await prisma.caseSequence.findMany()
    * ```
    */
  get caseSequence(): Prisma.CaseSequenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customRequirement`: Exposes CRUD operations for the **CustomRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomRequirements
    * const customRequirements = await prisma.customRequirement.findMany()
    * ```
    */
  get customRequirement(): Prisma.CustomRequirementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.destination`: Exposes CRUD operations for the **Destination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Destinations
    * const destinations = await prisma.destination.findMany()
    * ```
    */
  get destination(): Prisma.DestinationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentMapping`: Exposes CRUD operations for the **DocumentMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentMappings
    * const documentMappings = await prisma.documentMapping.findMany()
    * ```
    */
  get documentMapping(): Prisma.DocumentMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailThread`: Exposes CRUD operations for the **EmailThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailThreads
    * const emailThreads = await prisma.emailThread.findMany()
    * ```
    */
  get emailThread(): Prisma.EmailThreadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passenger`: Exposes CRUD operations for the **Passenger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passengers
    * const passengers = await prisma.passenger.findMany()
    * ```
    */
  get passenger(): Prisma.PassengerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.risk`: Exposes CRUD operations for the **Risk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Risks
    * const risks = await prisma.risk.findMany()
    * ```
    */
  get risk(): Prisma.RiskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.riskActivity`: Exposes CRUD operations for the **RiskActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskActivities
    * const riskActivities = await prisma.riskActivity.findMany()
    * ```
    */
  get riskActivity(): Prisma.RiskActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.riskDocument`: Exposes CRUD operations for the **RiskDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskDocuments
    * const riskDocuments = await prisma.riskDocument.findMany()
    * ```
    */
  get riskDocument(): Prisma.RiskDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stripeActivity`: Exposes CRUD operations for the **StripeActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StripeActivities
    * const stripeActivities = await prisma.stripeActivity.findMany()
    * ```
    */
  get stripeActivity(): Prisma.StripeActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskActivity`: Exposes CRUD operations for the **TaskActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskActivities
    * const taskActivities = await prisma.taskActivity.findMany()
    * ```
    */
  get taskActivity(): Prisma.TaskActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visaType`: Exposes CRUD operations for the **VisaType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisaTypes
    * const visaTypes = await prisma.visaType.findMany()
    * ```
    */
  get visaType(): Prisma.VisaTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.password_reset_tokens`: Exposes CRUD operations for the **password_reset_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Password_reset_tokens
    * const password_reset_tokens = await prisma.password_reset_tokens.findMany()
    * ```
    */
  get password_reset_tokens(): Prisma.password_reset_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Application: 'Application',
    ApplicationDocument: 'ApplicationDocument',
    Attachment: 'Attachment',
    CardHolder: 'CardHolder',
    Case: 'Case',
    CaseSequence: 'CaseSequence',
    CustomRequirement: 'CustomRequirement',
    Destination: 'Destination',
    DocumentMapping: 'DocumentMapping',
    EmailTemplate: 'EmailTemplate',
    EmailThread: 'EmailThread',
    Passenger: 'Passenger',
    Risk: 'Risk',
    RiskActivity: 'RiskActivity',
    RiskDocument: 'RiskDocument',
    StripeActivity: 'StripeActivity',
    Task: 'Task',
    TaskActivity: 'TaskActivity',
    User: 'User',
    VisaType: 'VisaType',
    password_reset_tokens: 'password_reset_tokens',
    sessions: 'sessions'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "application" | "applicationDocument" | "attachment" | "cardHolder" | "case" | "caseSequence" | "customRequirement" | "destination" | "documentMapping" | "emailTemplate" | "emailThread" | "passenger" | "risk" | "riskActivity" | "riskDocument" | "stripeActivity" | "task" | "taskActivity" | "user" | "visaType" | "password_reset_tokens" | "sessions"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>
        fields: Prisma.ApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication>
          }
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number
          }
        }
      }
      ApplicationDocument: {
        payload: Prisma.$ApplicationDocumentPayload<ExtArgs>
        fields: Prisma.ApplicationDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
          }
          findFirst: {
            args: Prisma.ApplicationDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
          }
          findMany: {
            args: Prisma.ApplicationDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>[]
          }
          create: {
            args: Prisma.ApplicationDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
          }
          createMany: {
            args: Prisma.ApplicationDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicationDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>[]
          }
          delete: {
            args: Prisma.ApplicationDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
          }
          update: {
            args: Prisma.ApplicationDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApplicationDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>[]
          }
          upsert: {
            args: Prisma.ApplicationDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
          }
          aggregate: {
            args: Prisma.ApplicationDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicationDocument>
          }
          groupBy: {
            args: Prisma.ApplicationDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationDocumentCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      CardHolder: {
        payload: Prisma.$CardHolderPayload<ExtArgs>
        fields: Prisma.CardHolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardHolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardHolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardHolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardHolderPayload>
          }
          findFirst: {
            args: Prisma.CardHolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardHolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardHolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardHolderPayload>
          }
          findMany: {
            args: Prisma.CardHolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardHolderPayload>[]
          }
          create: {
            args: Prisma.CardHolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardHolderPayload>
          }
          createMany: {
            args: Prisma.CardHolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CardHolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardHolderPayload>[]
          }
          delete: {
            args: Prisma.CardHolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardHolderPayload>
          }
          update: {
            args: Prisma.CardHolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardHolderPayload>
          }
          deleteMany: {
            args: Prisma.CardHolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardHolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CardHolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardHolderPayload>[]
          }
          upsert: {
            args: Prisma.CardHolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardHolderPayload>
          }
          aggregate: {
            args: Prisma.CardHolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCardHolder>
          }
          groupBy: {
            args: Prisma.CardHolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardHolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardHolderCountArgs<ExtArgs>
            result: $Utils.Optional<CardHolderCountAggregateOutputType> | number
          }
        }
      }
      Case: {
        payload: Prisma.$CasePayload<ExtArgs>
        fields: Prisma.CaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          findFirst: {
            args: Prisma.CaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          findMany: {
            args: Prisma.CaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>[]
          }
          create: {
            args: Prisma.CaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          createMany: {
            args: Prisma.CaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>[]
          }
          delete: {
            args: Prisma.CaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          update: {
            args: Prisma.CaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          deleteMany: {
            args: Prisma.CaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>[]
          }
          upsert: {
            args: Prisma.CaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePayload>
          }
          aggregate: {
            args: Prisma.CaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCase>
          }
          groupBy: {
            args: Prisma.CaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseCountArgs<ExtArgs>
            result: $Utils.Optional<CaseCountAggregateOutputType> | number
          }
        }
      }
      CaseSequence: {
        payload: Prisma.$CaseSequencePayload<ExtArgs>
        fields: Prisma.CaseSequenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseSequenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseSequencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseSequenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseSequencePayload>
          }
          findFirst: {
            args: Prisma.CaseSequenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseSequencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseSequenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseSequencePayload>
          }
          findMany: {
            args: Prisma.CaseSequenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseSequencePayload>[]
          }
          create: {
            args: Prisma.CaseSequenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseSequencePayload>
          }
          createMany: {
            args: Prisma.CaseSequenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseSequenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseSequencePayload>[]
          }
          delete: {
            args: Prisma.CaseSequenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseSequencePayload>
          }
          update: {
            args: Prisma.CaseSequenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseSequencePayload>
          }
          deleteMany: {
            args: Prisma.CaseSequenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseSequenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaseSequenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseSequencePayload>[]
          }
          upsert: {
            args: Prisma.CaseSequenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseSequencePayload>
          }
          aggregate: {
            args: Prisma.CaseSequenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseSequence>
          }
          groupBy: {
            args: Prisma.CaseSequenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseSequenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseSequenceCountArgs<ExtArgs>
            result: $Utils.Optional<CaseSequenceCountAggregateOutputType> | number
          }
        }
      }
      CustomRequirement: {
        payload: Prisma.$CustomRequirementPayload<ExtArgs>
        fields: Prisma.CustomRequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomRequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomRequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRequirementPayload>
          }
          findFirst: {
            args: Prisma.CustomRequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomRequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRequirementPayload>
          }
          findMany: {
            args: Prisma.CustomRequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRequirementPayload>[]
          }
          create: {
            args: Prisma.CustomRequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRequirementPayload>
          }
          createMany: {
            args: Prisma.CustomRequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomRequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRequirementPayload>[]
          }
          delete: {
            args: Prisma.CustomRequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRequirementPayload>
          }
          update: {
            args: Prisma.CustomRequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRequirementPayload>
          }
          deleteMany: {
            args: Prisma.CustomRequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomRequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomRequirementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRequirementPayload>[]
          }
          upsert: {
            args: Prisma.CustomRequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomRequirementPayload>
          }
          aggregate: {
            args: Prisma.CustomRequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomRequirement>
          }
          groupBy: {
            args: Prisma.CustomRequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomRequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomRequirementCountArgs<ExtArgs>
            result: $Utils.Optional<CustomRequirementCountAggregateOutputType> | number
          }
        }
      }
      Destination: {
        payload: Prisma.$DestinationPayload<ExtArgs>
        fields: Prisma.DestinationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DestinationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DestinationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          findFirst: {
            args: Prisma.DestinationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DestinationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          findMany: {
            args: Prisma.DestinationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          create: {
            args: Prisma.DestinationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          createMany: {
            args: Prisma.DestinationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DestinationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          delete: {
            args: Prisma.DestinationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          update: {
            args: Prisma.DestinationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          deleteMany: {
            args: Prisma.DestinationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DestinationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DestinationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          upsert: {
            args: Prisma.DestinationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          aggregate: {
            args: Prisma.DestinationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDestination>
          }
          groupBy: {
            args: Prisma.DestinationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DestinationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DestinationCountArgs<ExtArgs>
            result: $Utils.Optional<DestinationCountAggregateOutputType> | number
          }
        }
      }
      DocumentMapping: {
        payload: Prisma.$DocumentMappingPayload<ExtArgs>
        fields: Prisma.DocumentMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentMappingPayload>
          }
          findFirst: {
            args: Prisma.DocumentMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentMappingPayload>
          }
          findMany: {
            args: Prisma.DocumentMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentMappingPayload>[]
          }
          create: {
            args: Prisma.DocumentMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentMappingPayload>
          }
          createMany: {
            args: Prisma.DocumentMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentMappingPayload>[]
          }
          delete: {
            args: Prisma.DocumentMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentMappingPayload>
          }
          update: {
            args: Prisma.DocumentMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentMappingPayload>
          }
          deleteMany: {
            args: Prisma.DocumentMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentMappingPayload>[]
          }
          upsert: {
            args: Prisma.DocumentMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentMappingPayload>
          }
          aggregate: {
            args: Prisma.DocumentMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentMapping>
          }
          groupBy: {
            args: Prisma.DocumentMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentMappingCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentMappingCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      EmailThread: {
        payload: Prisma.$EmailThreadPayload<ExtArgs>
        fields: Prisma.EmailThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailThreadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailThreadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          findFirst: {
            args: Prisma.EmailThreadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailThreadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          findMany: {
            args: Prisma.EmailThreadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>[]
          }
          create: {
            args: Prisma.EmailThreadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          createMany: {
            args: Prisma.EmailThreadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailThreadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>[]
          }
          delete: {
            args: Prisma.EmailThreadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          update: {
            args: Prisma.EmailThreadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          deleteMany: {
            args: Prisma.EmailThreadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailThreadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailThreadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>[]
          }
          upsert: {
            args: Prisma.EmailThreadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          aggregate: {
            args: Prisma.EmailThreadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailThread>
          }
          groupBy: {
            args: Prisma.EmailThreadGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailThreadCountArgs<ExtArgs>
            result: $Utils.Optional<EmailThreadCountAggregateOutputType> | number
          }
        }
      }
      Passenger: {
        payload: Prisma.$PassengerPayload<ExtArgs>
        fields: Prisma.PassengerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PassengerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PassengerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          findFirst: {
            args: Prisma.PassengerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PassengerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          findMany: {
            args: Prisma.PassengerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          create: {
            args: Prisma.PassengerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          createMany: {
            args: Prisma.PassengerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PassengerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          delete: {
            args: Prisma.PassengerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          update: {
            args: Prisma.PassengerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          deleteMany: {
            args: Prisma.PassengerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PassengerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PassengerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          upsert: {
            args: Prisma.PassengerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          aggregate: {
            args: Prisma.PassengerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassenger>
          }
          groupBy: {
            args: Prisma.PassengerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PassengerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PassengerCountArgs<ExtArgs>
            result: $Utils.Optional<PassengerCountAggregateOutputType> | number
          }
        }
      }
      Risk: {
        payload: Prisma.$RiskPayload<ExtArgs>
        fields: Prisma.RiskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskPayload>
          }
          findFirst: {
            args: Prisma.RiskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskPayload>
          }
          findMany: {
            args: Prisma.RiskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskPayload>[]
          }
          create: {
            args: Prisma.RiskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskPayload>
          }
          createMany: {
            args: Prisma.RiskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskPayload>[]
          }
          delete: {
            args: Prisma.RiskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskPayload>
          }
          update: {
            args: Prisma.RiskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskPayload>
          }
          deleteMany: {
            args: Prisma.RiskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RiskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskPayload>[]
          }
          upsert: {
            args: Prisma.RiskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskPayload>
          }
          aggregate: {
            args: Prisma.RiskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRisk>
          }
          groupBy: {
            args: Prisma.RiskGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskCountArgs<ExtArgs>
            result: $Utils.Optional<RiskCountAggregateOutputType> | number
          }
        }
      }
      RiskActivity: {
        payload: Prisma.$RiskActivityPayload<ExtArgs>
        fields: Prisma.RiskActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskActivityPayload>
          }
          findFirst: {
            args: Prisma.RiskActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskActivityPayload>
          }
          findMany: {
            args: Prisma.RiskActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskActivityPayload>[]
          }
          create: {
            args: Prisma.RiskActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskActivityPayload>
          }
          createMany: {
            args: Prisma.RiskActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskActivityPayload>[]
          }
          delete: {
            args: Prisma.RiskActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskActivityPayload>
          }
          update: {
            args: Prisma.RiskActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskActivityPayload>
          }
          deleteMany: {
            args: Prisma.RiskActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RiskActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskActivityPayload>[]
          }
          upsert: {
            args: Prisma.RiskActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskActivityPayload>
          }
          aggregate: {
            args: Prisma.RiskActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskActivity>
          }
          groupBy: {
            args: Prisma.RiskActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskActivityCountArgs<ExtArgs>
            result: $Utils.Optional<RiskActivityCountAggregateOutputType> | number
          }
        }
      }
      RiskDocument: {
        payload: Prisma.$RiskDocumentPayload<ExtArgs>
        fields: Prisma.RiskDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDocumentPayload>
          }
          findFirst: {
            args: Prisma.RiskDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDocumentPayload>
          }
          findMany: {
            args: Prisma.RiskDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDocumentPayload>[]
          }
          create: {
            args: Prisma.RiskDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDocumentPayload>
          }
          createMany: {
            args: Prisma.RiskDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDocumentPayload>[]
          }
          delete: {
            args: Prisma.RiskDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDocumentPayload>
          }
          update: {
            args: Prisma.RiskDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDocumentPayload>
          }
          deleteMany: {
            args: Prisma.RiskDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RiskDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDocumentPayload>[]
          }
          upsert: {
            args: Prisma.RiskDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDocumentPayload>
          }
          aggregate: {
            args: Prisma.RiskDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskDocument>
          }
          groupBy: {
            args: Prisma.RiskDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<RiskDocumentCountAggregateOutputType> | number
          }
        }
      }
      StripeActivity: {
        payload: Prisma.$StripeActivityPayload<ExtArgs>
        fields: Prisma.StripeActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StripeActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StripeActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeActivityPayload>
          }
          findFirst: {
            args: Prisma.StripeActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StripeActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeActivityPayload>
          }
          findMany: {
            args: Prisma.StripeActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeActivityPayload>[]
          }
          create: {
            args: Prisma.StripeActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeActivityPayload>
          }
          createMany: {
            args: Prisma.StripeActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StripeActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeActivityPayload>[]
          }
          delete: {
            args: Prisma.StripeActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeActivityPayload>
          }
          update: {
            args: Prisma.StripeActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeActivityPayload>
          }
          deleteMany: {
            args: Prisma.StripeActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StripeActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StripeActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeActivityPayload>[]
          }
          upsert: {
            args: Prisma.StripeActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeActivityPayload>
          }
          aggregate: {
            args: Prisma.StripeActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStripeActivity>
          }
          groupBy: {
            args: Prisma.StripeActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<StripeActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.StripeActivityCountArgs<ExtArgs>
            result: $Utils.Optional<StripeActivityCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskActivity: {
        payload: Prisma.$TaskActivityPayload<ExtArgs>
        fields: Prisma.TaskActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskActivityPayload>
          }
          findFirst: {
            args: Prisma.TaskActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskActivityPayload>
          }
          findMany: {
            args: Prisma.TaskActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskActivityPayload>[]
          }
          create: {
            args: Prisma.TaskActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskActivityPayload>
          }
          createMany: {
            args: Prisma.TaskActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskActivityPayload>[]
          }
          delete: {
            args: Prisma.TaskActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskActivityPayload>
          }
          update: {
            args: Prisma.TaskActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskActivityPayload>
          }
          deleteMany: {
            args: Prisma.TaskActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskActivityPayload>[]
          }
          upsert: {
            args: Prisma.TaskActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskActivityPayload>
          }
          aggregate: {
            args: Prisma.TaskActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskActivity>
          }
          groupBy: {
            args: Prisma.TaskActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskActivityCountArgs<ExtArgs>
            result: $Utils.Optional<TaskActivityCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      VisaType: {
        payload: Prisma.$VisaTypePayload<ExtArgs>
        fields: Prisma.VisaTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisaTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisaTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaTypePayload>
          }
          findFirst: {
            args: Prisma.VisaTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisaTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaTypePayload>
          }
          findMany: {
            args: Prisma.VisaTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaTypePayload>[]
          }
          create: {
            args: Prisma.VisaTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaTypePayload>
          }
          createMany: {
            args: Prisma.VisaTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisaTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaTypePayload>[]
          }
          delete: {
            args: Prisma.VisaTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaTypePayload>
          }
          update: {
            args: Prisma.VisaTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaTypePayload>
          }
          deleteMany: {
            args: Prisma.VisaTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisaTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VisaTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaTypePayload>[]
          }
          upsert: {
            args: Prisma.VisaTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaTypePayload>
          }
          aggregate: {
            args: Prisma.VisaTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisaType>
          }
          groupBy: {
            args: Prisma.VisaTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisaTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisaTypeCountArgs<ExtArgs>
            result: $Utils.Optional<VisaTypeCountAggregateOutputType> | number
          }
        }
      }
      password_reset_tokens: {
        payload: Prisma.$password_reset_tokensPayload<ExtArgs>
        fields: Prisma.password_reset_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.password_reset_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.password_reset_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          findFirst: {
            args: Prisma.password_reset_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.password_reset_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          findMany: {
            args: Prisma.password_reset_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>[]
          }
          create: {
            args: Prisma.password_reset_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          createMany: {
            args: Prisma.password_reset_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.password_reset_tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>[]
          }
          delete: {
            args: Prisma.password_reset_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          update: {
            args: Prisma.password_reset_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          deleteMany: {
            args: Prisma.password_reset_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.password_reset_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.password_reset_tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>[]
          }
          upsert: {
            args: Prisma.password_reset_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          aggregate: {
            args: Prisma.Password_reset_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassword_reset_tokens>
          }
          groupBy: {
            args: Prisma.password_reset_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Password_reset_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.password_reset_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Password_reset_tokensCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sessionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    application?: ApplicationOmit
    applicationDocument?: ApplicationDocumentOmit
    attachment?: AttachmentOmit
    cardHolder?: CardHolderOmit
    case?: CaseOmit
    caseSequence?: CaseSequenceOmit
    customRequirement?: CustomRequirementOmit
    destination?: DestinationOmit
    documentMapping?: DocumentMappingOmit
    emailTemplate?: EmailTemplateOmit
    emailThread?: EmailThreadOmit
    passenger?: PassengerOmit
    risk?: RiskOmit
    riskActivity?: RiskActivityOmit
    riskDocument?: RiskDocumentOmit
    stripeActivity?: StripeActivityOmit
    task?: TaskOmit
    taskActivity?: TaskActivityOmit
    user?: UserOmit
    visaType?: VisaTypeOmit
    password_reset_tokens?: password_reset_tokensOmit
    sessions?: sessionsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    Application: number
    Case: number
    password_reset_tokens: number
    sessions: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | AccountCountOutputTypeCountApplicationArgs
    Case?: boolean | AccountCountOutputTypeCountCaseArgs
    password_reset_tokens?: boolean | AccountCountOutputTypeCountPassword_reset_tokensArgs
    sessions?: boolean | AccountCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountPassword_reset_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: password_reset_tokensWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
  }


  /**
   * Count Type ApplicationCountOutputType
   */

  export type ApplicationCountOutputType = {
    ApplicationDocument: number
    Case: number
    Passenger: number
    Risk: number
    StripeActivity: number
    Task: number
  }

  export type ApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ApplicationDocument?: boolean | ApplicationCountOutputTypeCountApplicationDocumentArgs
    Case?: boolean | ApplicationCountOutputTypeCountCaseArgs
    Passenger?: boolean | ApplicationCountOutputTypeCountPassengerArgs
    Risk?: boolean | ApplicationCountOutputTypeCountRiskArgs
    StripeActivity?: boolean | ApplicationCountOutputTypeCountStripeActivityArgs
    Task?: boolean | ApplicationCountOutputTypeCountTaskArgs
  }

  // Custom InputTypes
  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationCountOutputType
     */
    select?: ApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountApplicationDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationDocumentWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountPassengerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassengerWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountRiskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountStripeActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeActivityWhereInput
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type CaseCountOutputType
   */

  export type CaseCountOutputType = {
    EmailThread: number
  }

  export type CaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmailThread?: boolean | CaseCountOutputTypeCountEmailThreadArgs
  }

  // Custom InputTypes
  /**
   * CaseCountOutputType without action
   */
  export type CaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseCountOutputType
     */
    select?: CaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CaseCountOutputType without action
   */
  export type CaseCountOutputTypeCountEmailThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailThreadWhereInput
  }


  /**
   * Count Type DestinationCountOutputType
   */

  export type DestinationCountOutputType = {
    Application: number
    VisaType: number
  }

  export type DestinationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | DestinationCountOutputTypeCountApplicationArgs
    VisaType?: boolean | DestinationCountOutputTypeCountVisaTypeArgs
  }

  // Custom InputTypes
  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinationCountOutputType
     */
    select?: DestinationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeCountApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }

  /**
   * DestinationCountOutputType without action
   */
  export type DestinationCountOutputTypeCountVisaTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisaTypeWhereInput
  }


  /**
   * Count Type EmailThreadCountOutputType
   */

  export type EmailThreadCountOutputType = {
    Attachment: number
  }

  export type EmailThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Attachment?: boolean | EmailThreadCountOutputTypeCountAttachmentArgs
  }

  // Custom InputTypes
  /**
   * EmailThreadCountOutputType without action
   */
  export type EmailThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThreadCountOutputType
     */
    select?: EmailThreadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailThreadCountOutputType without action
   */
  export type EmailThreadCountOutputTypeCountAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }


  /**
   * Count Type RiskCountOutputType
   */

  export type RiskCountOutputType = {
    RiskActivity: number
    RiskDocument: number
  }

  export type RiskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RiskActivity?: boolean | RiskCountOutputTypeCountRiskActivityArgs
    RiskDocument?: boolean | RiskCountOutputTypeCountRiskDocumentArgs
  }

  // Custom InputTypes
  /**
   * RiskCountOutputType without action
   */
  export type RiskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskCountOutputType
     */
    select?: RiskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RiskCountOutputType without action
   */
  export type RiskCountOutputTypeCountRiskActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskActivityWhereInput
  }

  /**
   * RiskCountOutputType without action
   */
  export type RiskCountOutputTypeCountRiskDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskDocumentWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    TaskActivity: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TaskActivity?: boolean | TaskCountOutputTypeCountTaskActivityArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTaskActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskActivityWhereInput
  }


  /**
   * Count Type VisaTypeCountOutputType
   */

  export type VisaTypeCountOutputType = {
    Application: number
  }

  export type VisaTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | VisaTypeCountOutputTypeCountApplicationArgs
  }

  // Custom InputTypes
  /**
   * VisaTypeCountOutputType without action
   */
  export type VisaTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaTypeCountOutputType
     */
    select?: VisaTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VisaTypeCountOutputType without action
   */
  export type VisaTypeCountOutputTypeCountApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    fullName: string | null
    areaCode: string | null
    phoneNumber: string | null
    gender: string | null
    password: string | null
    emailVerified: boolean | null
    websiteCreatedAt: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    fullName: string | null
    areaCode: string | null
    phoneNumber: string | null
    gender: string | null
    password: string | null
    emailVerified: boolean | null
    websiteCreatedAt: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    email: number
    fullName: number
    areaCode: number
    phoneNumber: number
    gender: number
    password: number
    emailVerified: number
    websiteCreatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    fullName?: true
    areaCode?: true
    phoneNumber?: true
    gender?: true
    password?: true
    emailVerified?: true
    websiteCreatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    fullName?: true
    areaCode?: true
    phoneNumber?: true
    gender?: true
    password?: true
    emailVerified?: true
    websiteCreatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    fullName?: true
    areaCode?: true
    phoneNumber?: true
    gender?: true
    password?: true
    emailVerified?: true
    websiteCreatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date | null
    email: string
    fullName: string
    areaCode: string
    phoneNumber: string
    gender: string
    password: string | null
    emailVerified: boolean
    websiteCreatedAt: string
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    fullName?: boolean
    areaCode?: boolean
    phoneNumber?: boolean
    gender?: boolean
    password?: boolean
    emailVerified?: boolean
    websiteCreatedAt?: boolean
    Application?: boolean | Account$ApplicationArgs<ExtArgs>
    Case?: boolean | Account$CaseArgs<ExtArgs>
    password_reset_tokens?: boolean | Account$password_reset_tokensArgs<ExtArgs>
    sessions?: boolean | Account$sessionsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    fullName?: boolean
    areaCode?: boolean
    phoneNumber?: boolean
    gender?: boolean
    password?: boolean
    emailVerified?: boolean
    websiteCreatedAt?: boolean
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    fullName?: boolean
    areaCode?: boolean
    phoneNumber?: boolean
    gender?: boolean
    password?: boolean
    emailVerified?: boolean
    websiteCreatedAt?: boolean
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    fullName?: boolean
    areaCode?: boolean
    phoneNumber?: boolean
    gender?: boolean
    password?: boolean
    emailVerified?: boolean
    websiteCreatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "email" | "fullName" | "areaCode" | "phoneNumber" | "gender" | "password" | "emailVerified" | "websiteCreatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | Account$ApplicationArgs<ExtArgs>
    Case?: boolean | Account$CaseArgs<ExtArgs>
    password_reset_tokens?: boolean | Account$password_reset_tokensArgs<ExtArgs>
    sessions?: boolean | Account$sessionsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      Application: Prisma.$ApplicationPayload<ExtArgs>[]
      Case: Prisma.$CasePayload<ExtArgs>[]
      password_reset_tokens: Prisma.$password_reset_tokensPayload<ExtArgs>[]
      sessions: Prisma.$sessionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date | null
      email: string
      fullName: string
      areaCode: string
      phoneNumber: string
      gender: string
      password: string | null
      emailVerified: boolean
      websiteCreatedAt: string
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Application<T extends Account$ApplicationArgs<ExtArgs> = {}>(args?: Subset<T, Account$ApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Case<T extends Account$CaseArgs<ExtArgs> = {}>(args?: Subset<T, Account$CaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    password_reset_tokens<T extends Account$password_reset_tokensArgs<ExtArgs> = {}>(args?: Subset<T, Account$password_reset_tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends Account$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
    readonly email: FieldRef<"Account", 'String'>
    readonly fullName: FieldRef<"Account", 'String'>
    readonly areaCode: FieldRef<"Account", 'String'>
    readonly phoneNumber: FieldRef<"Account", 'String'>
    readonly gender: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly emailVerified: FieldRef<"Account", 'Boolean'>
    readonly websiteCreatedAt: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.Application
   */
  export type Account$ApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Account.Case
   */
  export type Account$CaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    where?: CaseWhereInput
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    cursor?: CaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * Account.password_reset_tokens
   */
  export type Account$password_reset_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    where?: password_reset_tokensWhereInput
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    cursor?: password_reset_tokensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * Account.sessions
   */
  export type Account$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    cursor?: sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null
    _avg: ApplicationAvgAggregateOutputType | null
    _sum: ApplicationSumAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  export type ApplicationAvgAggregateOutputType = {
    passengerCount: number | null
    total: number | null
  }

  export type ApplicationSumAggregateOutputType = {
    passengerCount: number | null
    total: number | null
  }

  export type ApplicationMinAggregateOutputType = {
    id: string | null
    destinationId: string | null
    visaTypeId: string | null
    status: string | null
    accountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    applicationId: string | null
    passengerCount: number | null
    stayingEnd: Date | null
    stayingStart: Date | null
    total: number | null
    cancellationDetails: string | null
    cancellationReason: string | null
    cancelledAt: Date | null
    cancelledBy: string | null
    applyDate: Date | null
    paymentStatus: string | null
  }

  export type ApplicationMaxAggregateOutputType = {
    id: string | null
    destinationId: string | null
    visaTypeId: string | null
    status: string | null
    accountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    applicationId: string | null
    passengerCount: number | null
    stayingEnd: Date | null
    stayingStart: Date | null
    total: number | null
    cancellationDetails: string | null
    cancellationReason: string | null
    cancelledAt: Date | null
    cancelledBy: string | null
    applyDate: Date | null
    paymentStatus: string | null
  }

  export type ApplicationCountAggregateOutputType = {
    id: number
    destinationId: number
    visaTypeId: number
    status: number
    accountId: number
    createdAt: number
    updatedAt: number
    applicationId: number
    passengerCount: number
    stayingEnd: number
    stayingStart: number
    total: number
    cancellationDetails: number
    cancellationReason: number
    cancelledAt: number
    cancelledBy: number
    applyDate: number
    paymentStatus: number
    _all: number
  }


  export type ApplicationAvgAggregateInputType = {
    passengerCount?: true
    total?: true
  }

  export type ApplicationSumAggregateInputType = {
    passengerCount?: true
    total?: true
  }

  export type ApplicationMinAggregateInputType = {
    id?: true
    destinationId?: true
    visaTypeId?: true
    status?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    applicationId?: true
    passengerCount?: true
    stayingEnd?: true
    stayingStart?: true
    total?: true
    cancellationDetails?: true
    cancellationReason?: true
    cancelledAt?: true
    cancelledBy?: true
    applyDate?: true
    paymentStatus?: true
  }

  export type ApplicationMaxAggregateInputType = {
    id?: true
    destinationId?: true
    visaTypeId?: true
    status?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    applicationId?: true
    passengerCount?: true
    stayingEnd?: true
    stayingStart?: true
    total?: true
    cancellationDetails?: true
    cancellationReason?: true
    cancelledAt?: true
    cancelledBy?: true
    applyDate?: true
    paymentStatus?: true
  }

  export type ApplicationCountAggregateInputType = {
    id?: true
    destinationId?: true
    visaTypeId?: true
    status?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    applicationId?: true
    passengerCount?: true
    stayingEnd?: true
    stayingStart?: true
    total?: true
    cancellationDetails?: true
    cancellationReason?: true
    cancelledAt?: true
    cancelledBy?: true
    applyDate?: true
    paymentStatus?: true
    _all?: true
  }

  export type ApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applications
    **/
    _count?: true | ApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationMaxAggregateInputType
  }

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>
  }




  export type ApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[]
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum
    having?: ApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationCountAggregateInputType | true
    _avg?: ApplicationAvgAggregateInputType
    _sum?: ApplicationSumAggregateInputType
    _min?: ApplicationMinAggregateInputType
    _max?: ApplicationMaxAggregateInputType
  }

  export type ApplicationGroupByOutputType = {
    id: string
    destinationId: string
    visaTypeId: string
    status: string
    accountId: string
    createdAt: Date
    updatedAt: Date | null
    applicationId: string
    passengerCount: number | null
    stayingEnd: Date | null
    stayingStart: Date | null
    total: number | null
    cancellationDetails: string | null
    cancellationReason: string | null
    cancelledAt: Date | null
    cancelledBy: string | null
    applyDate: Date | null
    paymentStatus: string | null
    _count: ApplicationCountAggregateOutputType | null
    _avg: ApplicationAvgAggregateOutputType | null
    _sum: ApplicationSumAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    destinationId?: boolean
    visaTypeId?: boolean
    status?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicationId?: boolean
    passengerCount?: boolean
    stayingEnd?: boolean
    stayingStart?: boolean
    total?: boolean
    cancellationDetails?: boolean
    cancellationReason?: boolean
    cancelledAt?: boolean
    cancelledBy?: boolean
    applyDate?: boolean
    paymentStatus?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
    Destination?: boolean | DestinationDefaultArgs<ExtArgs>
    VisaType?: boolean | VisaTypeDefaultArgs<ExtArgs>
    ApplicationDocument?: boolean | Application$ApplicationDocumentArgs<ExtArgs>
    CardHolder?: boolean | Application$CardHolderArgs<ExtArgs>
    Case?: boolean | Application$CaseArgs<ExtArgs>
    Passenger?: boolean | Application$PassengerArgs<ExtArgs>
    Risk?: boolean | Application$RiskArgs<ExtArgs>
    StripeActivity?: boolean | Application$StripeActivityArgs<ExtArgs>
    Task?: boolean | Application$TaskArgs<ExtArgs>
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    destinationId?: boolean
    visaTypeId?: boolean
    status?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicationId?: boolean
    passengerCount?: boolean
    stayingEnd?: boolean
    stayingStart?: boolean
    total?: boolean
    cancellationDetails?: boolean
    cancellationReason?: boolean
    cancelledAt?: boolean
    cancelledBy?: boolean
    applyDate?: boolean
    paymentStatus?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
    Destination?: boolean | DestinationDefaultArgs<ExtArgs>
    VisaType?: boolean | VisaTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    destinationId?: boolean
    visaTypeId?: boolean
    status?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicationId?: boolean
    passengerCount?: boolean
    stayingEnd?: boolean
    stayingStart?: boolean
    total?: boolean
    cancellationDetails?: boolean
    cancellationReason?: boolean
    cancelledAt?: boolean
    cancelledBy?: boolean
    applyDate?: boolean
    paymentStatus?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
    Destination?: boolean | DestinationDefaultArgs<ExtArgs>
    VisaType?: boolean | VisaTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectScalar = {
    id?: boolean
    destinationId?: boolean
    visaTypeId?: boolean
    status?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicationId?: boolean
    passengerCount?: boolean
    stayingEnd?: boolean
    stayingStart?: boolean
    total?: boolean
    cancellationDetails?: boolean
    cancellationReason?: boolean
    cancelledAt?: boolean
    cancelledBy?: boolean
    applyDate?: boolean
    paymentStatus?: boolean
  }

  export type ApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "destinationId" | "visaTypeId" | "status" | "accountId" | "createdAt" | "updatedAt" | "applicationId" | "passengerCount" | "stayingEnd" | "stayingStart" | "total" | "cancellationDetails" | "cancellationReason" | "cancelledAt" | "cancelledBy" | "applyDate" | "paymentStatus", ExtArgs["result"]["application"]>
  export type ApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
    Destination?: boolean | DestinationDefaultArgs<ExtArgs>
    VisaType?: boolean | VisaTypeDefaultArgs<ExtArgs>
    ApplicationDocument?: boolean | Application$ApplicationDocumentArgs<ExtArgs>
    CardHolder?: boolean | Application$CardHolderArgs<ExtArgs>
    Case?: boolean | Application$CaseArgs<ExtArgs>
    Passenger?: boolean | Application$PassengerArgs<ExtArgs>
    Risk?: boolean | Application$RiskArgs<ExtArgs>
    StripeActivity?: boolean | Application$StripeActivityArgs<ExtArgs>
    Task?: boolean | Application$TaskArgs<ExtArgs>
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
    Destination?: boolean | DestinationDefaultArgs<ExtArgs>
    VisaType?: boolean | VisaTypeDefaultArgs<ExtArgs>
  }
  export type ApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
    Destination?: boolean | DestinationDefaultArgs<ExtArgs>
    VisaType?: boolean | VisaTypeDefaultArgs<ExtArgs>
  }

  export type $ApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Application"
    objects: {
      Account: Prisma.$AccountPayload<ExtArgs>
      Destination: Prisma.$DestinationPayload<ExtArgs>
      VisaType: Prisma.$VisaTypePayload<ExtArgs>
      ApplicationDocument: Prisma.$ApplicationDocumentPayload<ExtArgs>[]
      CardHolder: Prisma.$CardHolderPayload<ExtArgs> | null
      Case: Prisma.$CasePayload<ExtArgs>[]
      Passenger: Prisma.$PassengerPayload<ExtArgs>[]
      Risk: Prisma.$RiskPayload<ExtArgs>[]
      StripeActivity: Prisma.$StripeActivityPayload<ExtArgs>[]
      Task: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      destinationId: string
      visaTypeId: string
      status: string
      accountId: string
      createdAt: Date
      updatedAt: Date | null
      applicationId: string
      passengerCount: number | null
      stayingEnd: Date | null
      stayingStart: Date | null
      total: number | null
      cancellationDetails: string | null
      cancellationReason: string | null
      cancelledAt: Date | null
      cancelledBy: string | null
      applyDate: Date | null
      paymentStatus: string | null
    }, ExtArgs["result"]["application"]>
    composites: {}
  }

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> = $Result.GetResult<Prisma.$ApplicationPayload, S>

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationCountAggregateInputType | true
    }

  export interface ApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Application'], meta: { name: 'Application' } }
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationWithIdOnly = await prisma.application.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationFindManyArgs>(args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     * 
     */
    create<T extends ApplicationCreateArgs>(args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationCreateManyArgs>(args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Applications and returns the data saved in the database.
     * @param {ApplicationCreateManyAndReturnArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDeleteArgs>(args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationUpdateArgs>(args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationUpdateManyArgs>(args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications and returns the data updated in the database.
     * @param {ApplicationUpdateManyAndReturnArgs} args - Arguments to update many Applications.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Applications and only return the `id`
     * const applicationWithIdOnly = await prisma.application.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, ApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationAggregateArgs>(args: Subset<T, ApplicationAggregateArgs>): Prisma.PrismaPromise<GetApplicationAggregateType<T>>

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Application model
   */
  readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Destination<T extends DestinationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DestinationDefaultArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    VisaType<T extends VisaTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VisaTypeDefaultArgs<ExtArgs>>): Prisma__VisaTypeClient<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ApplicationDocument<T extends Application$ApplicationDocumentArgs<ExtArgs> = {}>(args?: Subset<T, Application$ApplicationDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CardHolder<T extends Application$CardHolderArgs<ExtArgs> = {}>(args?: Subset<T, Application$CardHolderArgs<ExtArgs>>): Prisma__CardHolderClient<$Result.GetResult<Prisma.$CardHolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Case<T extends Application$CaseArgs<ExtArgs> = {}>(args?: Subset<T, Application$CaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Passenger<T extends Application$PassengerArgs<ExtArgs> = {}>(args?: Subset<T, Application$PassengerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Risk<T extends Application$RiskArgs<ExtArgs> = {}>(args?: Subset<T, Application$RiskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StripeActivity<T extends Application$StripeActivityArgs<ExtArgs> = {}>(args?: Subset<T, Application$StripeActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Task<T extends Application$TaskArgs<ExtArgs> = {}>(args?: Subset<T, Application$TaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Application model
   */
  interface ApplicationFieldRefs {
    readonly id: FieldRef<"Application", 'String'>
    readonly destinationId: FieldRef<"Application", 'String'>
    readonly visaTypeId: FieldRef<"Application", 'String'>
    readonly status: FieldRef<"Application", 'String'>
    readonly accountId: FieldRef<"Application", 'String'>
    readonly createdAt: FieldRef<"Application", 'DateTime'>
    readonly updatedAt: FieldRef<"Application", 'DateTime'>
    readonly applicationId: FieldRef<"Application", 'String'>
    readonly passengerCount: FieldRef<"Application", 'Int'>
    readonly stayingEnd: FieldRef<"Application", 'DateTime'>
    readonly stayingStart: FieldRef<"Application", 'DateTime'>
    readonly total: FieldRef<"Application", 'Float'>
    readonly cancellationDetails: FieldRef<"Application", 'String'>
    readonly cancellationReason: FieldRef<"Application", 'String'>
    readonly cancelledAt: FieldRef<"Application", 'DateTime'>
    readonly cancelledBy: FieldRef<"Application", 'String'>
    readonly applyDate: FieldRef<"Application", 'DateTime'>
    readonly paymentStatus: FieldRef<"Application", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application create
   */
  export type ApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
  }

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Application createManyAndReturn
   */
  export type ApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to update.
     */
    limit?: number
  }

  /**
   * Application updateManyAndReturn
   */
  export type ApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
  }

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to delete.
     */
    limit?: number
  }

  /**
   * Application.ApplicationDocument
   */
  export type Application$ApplicationDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    where?: ApplicationDocumentWhereInput
    orderBy?: ApplicationDocumentOrderByWithRelationInput | ApplicationDocumentOrderByWithRelationInput[]
    cursor?: ApplicationDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationDocumentScalarFieldEnum | ApplicationDocumentScalarFieldEnum[]
  }

  /**
   * Application.CardHolder
   */
  export type Application$CardHolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderInclude<ExtArgs> | null
    where?: CardHolderWhereInput
  }

  /**
   * Application.Case
   */
  export type Application$CaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    where?: CaseWhereInput
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    cursor?: CaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * Application.Passenger
   */
  export type Application$PassengerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    where?: PassengerWhereInput
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    cursor?: PassengerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Application.Risk
   */
  export type Application$RiskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskInclude<ExtArgs> | null
    where?: RiskWhereInput
    orderBy?: RiskOrderByWithRelationInput | RiskOrderByWithRelationInput[]
    cursor?: RiskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RiskScalarFieldEnum | RiskScalarFieldEnum[]
  }

  /**
   * Application.StripeActivity
   */
  export type Application$StripeActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityInclude<ExtArgs> | null
    where?: StripeActivityWhereInput
    orderBy?: StripeActivityOrderByWithRelationInput | StripeActivityOrderByWithRelationInput[]
    cursor?: StripeActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StripeActivityScalarFieldEnum | StripeActivityScalarFieldEnum[]
  }

  /**
   * Application.Task
   */
  export type Application$TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
  }


  /**
   * Model ApplicationDocument
   */

  export type AggregateApplicationDocument = {
    _count: ApplicationDocumentCountAggregateOutputType | null
    _min: ApplicationDocumentMinAggregateOutputType | null
    _max: ApplicationDocumentMaxAggregateOutputType | null
  }

  export type ApplicationDocumentMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    name: string | null
    type: string | null
    content: Uint8Array | null
    status: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApplicationDocumentMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    name: string | null
    type: string | null
    content: Uint8Array | null
    status: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApplicationDocumentCountAggregateOutputType = {
    id: number
    applicationId: number
    name: number
    type: number
    content: number
    status: number
    uploadedAt: number
    uploadedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApplicationDocumentMinAggregateInputType = {
    id?: true
    applicationId?: true
    name?: true
    type?: true
    content?: true
    status?: true
    uploadedAt?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApplicationDocumentMaxAggregateInputType = {
    id?: true
    applicationId?: true
    name?: true
    type?: true
    content?: true
    status?: true
    uploadedAt?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApplicationDocumentCountAggregateInputType = {
    id?: true
    applicationId?: true
    name?: true
    type?: true
    content?: true
    status?: true
    uploadedAt?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApplicationDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApplicationDocument to aggregate.
     */
    where?: ApplicationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationDocuments to fetch.
     */
    orderBy?: ApplicationDocumentOrderByWithRelationInput | ApplicationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApplicationDocuments
    **/
    _count?: true | ApplicationDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationDocumentMaxAggregateInputType
  }

  export type GetApplicationDocumentAggregateType<T extends ApplicationDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicationDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicationDocument[P]>
      : GetScalarType<T[P], AggregateApplicationDocument[P]>
  }




  export type ApplicationDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationDocumentWhereInput
    orderBy?: ApplicationDocumentOrderByWithAggregationInput | ApplicationDocumentOrderByWithAggregationInput[]
    by: ApplicationDocumentScalarFieldEnum[] | ApplicationDocumentScalarFieldEnum
    having?: ApplicationDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationDocumentCountAggregateInputType | true
    _min?: ApplicationDocumentMinAggregateInputType
    _max?: ApplicationDocumentMaxAggregateInputType
  }

  export type ApplicationDocumentGroupByOutputType = {
    id: string
    applicationId: string
    name: string
    type: string
    content: Uint8Array
    status: string | null
    uploadedAt: Date
    uploadedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ApplicationDocumentCountAggregateOutputType | null
    _min: ApplicationDocumentMinAggregateOutputType | null
    _max: ApplicationDocumentMaxAggregateOutputType | null
  }

  type GetApplicationDocumentGroupByPayload<T extends ApplicationDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationDocumentGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    name?: boolean
    type?: boolean
    content?: boolean
    status?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
    DocumentMapping?: boolean | ApplicationDocument$DocumentMappingArgs<ExtArgs>
  }, ExtArgs["result"]["applicationDocument"]>

  export type ApplicationDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    name?: boolean
    type?: boolean
    content?: boolean
    status?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationDocument"]>

  export type ApplicationDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    name?: boolean
    type?: boolean
    content?: boolean
    status?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationDocument"]>

  export type ApplicationDocumentSelectScalar = {
    id?: boolean
    applicationId?: boolean
    name?: boolean
    type?: boolean
    content?: boolean
    status?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApplicationDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationId" | "name" | "type" | "content" | "status" | "uploadedAt" | "uploadedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["applicationDocument"]>
  export type ApplicationDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
    DocumentMapping?: boolean | ApplicationDocument$DocumentMappingArgs<ExtArgs>
  }
  export type ApplicationDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type ApplicationDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }

  export type $ApplicationDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApplicationDocument"
    objects: {
      Application: Prisma.$ApplicationPayload<ExtArgs>
      DocumentMapping: Prisma.$DocumentMappingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      name: string
      type: string
      content: Uint8Array
      status: string | null
      uploadedAt: Date
      uploadedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["applicationDocument"]>
    composites: {}
  }

  type ApplicationDocumentGetPayload<S extends boolean | null | undefined | ApplicationDocumentDefaultArgs> = $Result.GetResult<Prisma.$ApplicationDocumentPayload, S>

  type ApplicationDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicationDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationDocumentCountAggregateInputType | true
    }

  export interface ApplicationDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApplicationDocument'], meta: { name: 'ApplicationDocument' } }
    /**
     * Find zero or one ApplicationDocument that matches the filter.
     * @param {ApplicationDocumentFindUniqueArgs} args - Arguments to find a ApplicationDocument
     * @example
     * // Get one ApplicationDocument
     * const applicationDocument = await prisma.applicationDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationDocumentFindUniqueArgs>(args: SelectSubset<T, ApplicationDocumentFindUniqueArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApplicationDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicationDocumentFindUniqueOrThrowArgs} args - Arguments to find a ApplicationDocument
     * @example
     * // Get one ApplicationDocument
     * const applicationDocument = await prisma.applicationDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApplicationDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentFindFirstArgs} args - Arguments to find a ApplicationDocument
     * @example
     * // Get one ApplicationDocument
     * const applicationDocument = await prisma.applicationDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationDocumentFindFirstArgs>(args?: SelectSubset<T, ApplicationDocumentFindFirstArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApplicationDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentFindFirstOrThrowArgs} args - Arguments to find a ApplicationDocument
     * @example
     * // Get one ApplicationDocument
     * const applicationDocument = await prisma.applicationDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApplicationDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApplicationDocuments
     * const applicationDocuments = await prisma.applicationDocument.findMany()
     * 
     * // Get first 10 ApplicationDocuments
     * const applicationDocuments = await prisma.applicationDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationDocumentWithIdOnly = await prisma.applicationDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationDocumentFindManyArgs>(args?: SelectSubset<T, ApplicationDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApplicationDocument.
     * @param {ApplicationDocumentCreateArgs} args - Arguments to create a ApplicationDocument.
     * @example
     * // Create one ApplicationDocument
     * const ApplicationDocument = await prisma.applicationDocument.create({
     *   data: {
     *     // ... data to create a ApplicationDocument
     *   }
     * })
     * 
     */
    create<T extends ApplicationDocumentCreateArgs>(args: SelectSubset<T, ApplicationDocumentCreateArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApplicationDocuments.
     * @param {ApplicationDocumentCreateManyArgs} args - Arguments to create many ApplicationDocuments.
     * @example
     * // Create many ApplicationDocuments
     * const applicationDocument = await prisma.applicationDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationDocumentCreateManyArgs>(args?: SelectSubset<T, ApplicationDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApplicationDocuments and returns the data saved in the database.
     * @param {ApplicationDocumentCreateManyAndReturnArgs} args - Arguments to create many ApplicationDocuments.
     * @example
     * // Create many ApplicationDocuments
     * const applicationDocument = await prisma.applicationDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApplicationDocuments and only return the `id`
     * const applicationDocumentWithIdOnly = await prisma.applicationDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicationDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicationDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApplicationDocument.
     * @param {ApplicationDocumentDeleteArgs} args - Arguments to delete one ApplicationDocument.
     * @example
     * // Delete one ApplicationDocument
     * const ApplicationDocument = await prisma.applicationDocument.delete({
     *   where: {
     *     // ... filter to delete one ApplicationDocument
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDocumentDeleteArgs>(args: SelectSubset<T, ApplicationDocumentDeleteArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApplicationDocument.
     * @param {ApplicationDocumentUpdateArgs} args - Arguments to update one ApplicationDocument.
     * @example
     * // Update one ApplicationDocument
     * const applicationDocument = await prisma.applicationDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationDocumentUpdateArgs>(args: SelectSubset<T, ApplicationDocumentUpdateArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApplicationDocuments.
     * @param {ApplicationDocumentDeleteManyArgs} args - Arguments to filter ApplicationDocuments to delete.
     * @example
     * // Delete a few ApplicationDocuments
     * const { count } = await prisma.applicationDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDocumentDeleteManyArgs>(args?: SelectSubset<T, ApplicationDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApplicationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApplicationDocuments
     * const applicationDocument = await prisma.applicationDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationDocumentUpdateManyArgs>(args: SelectSubset<T, ApplicationDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApplicationDocuments and returns the data updated in the database.
     * @param {ApplicationDocumentUpdateManyAndReturnArgs} args - Arguments to update many ApplicationDocuments.
     * @example
     * // Update many ApplicationDocuments
     * const applicationDocument = await prisma.applicationDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApplicationDocuments and only return the `id`
     * const applicationDocumentWithIdOnly = await prisma.applicationDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApplicationDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, ApplicationDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApplicationDocument.
     * @param {ApplicationDocumentUpsertArgs} args - Arguments to update or create a ApplicationDocument.
     * @example
     * // Update or create a ApplicationDocument
     * const applicationDocument = await prisma.applicationDocument.upsert({
     *   create: {
     *     // ... data to create a ApplicationDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApplicationDocument we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationDocumentUpsertArgs>(args: SelectSubset<T, ApplicationDocumentUpsertArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApplicationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentCountArgs} args - Arguments to filter ApplicationDocuments to count.
     * @example
     * // Count the number of ApplicationDocuments
     * const count = await prisma.applicationDocument.count({
     *   where: {
     *     // ... the filter for the ApplicationDocuments we want to count
     *   }
     * })
    **/
    count<T extends ApplicationDocumentCountArgs>(
      args?: Subset<T, ApplicationDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApplicationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationDocumentAggregateArgs>(args: Subset<T, ApplicationDocumentAggregateArgs>): Prisma.PrismaPromise<GetApplicationDocumentAggregateType<T>>

    /**
     * Group by ApplicationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationDocumentGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApplicationDocument model
   */
  readonly fields: ApplicationDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApplicationDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Application<T extends ApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDefaultArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DocumentMapping<T extends ApplicationDocument$DocumentMappingArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDocument$DocumentMappingArgs<ExtArgs>>): Prisma__DocumentMappingClient<$Result.GetResult<Prisma.$DocumentMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApplicationDocument model
   */
  interface ApplicationDocumentFieldRefs {
    readonly id: FieldRef<"ApplicationDocument", 'String'>
    readonly applicationId: FieldRef<"ApplicationDocument", 'String'>
    readonly name: FieldRef<"ApplicationDocument", 'String'>
    readonly type: FieldRef<"ApplicationDocument", 'String'>
    readonly content: FieldRef<"ApplicationDocument", 'Bytes'>
    readonly status: FieldRef<"ApplicationDocument", 'String'>
    readonly uploadedAt: FieldRef<"ApplicationDocument", 'DateTime'>
    readonly uploadedBy: FieldRef<"ApplicationDocument", 'String'>
    readonly createdAt: FieldRef<"ApplicationDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"ApplicationDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApplicationDocument findUnique
   */
  export type ApplicationDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDocument to fetch.
     */
    where: ApplicationDocumentWhereUniqueInput
  }

  /**
   * ApplicationDocument findUniqueOrThrow
   */
  export type ApplicationDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDocument to fetch.
     */
    where: ApplicationDocumentWhereUniqueInput
  }

  /**
   * ApplicationDocument findFirst
   */
  export type ApplicationDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDocument to fetch.
     */
    where?: ApplicationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationDocuments to fetch.
     */
    orderBy?: ApplicationDocumentOrderByWithRelationInput | ApplicationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApplicationDocuments.
     */
    cursor?: ApplicationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApplicationDocuments.
     */
    distinct?: ApplicationDocumentScalarFieldEnum | ApplicationDocumentScalarFieldEnum[]
  }

  /**
   * ApplicationDocument findFirstOrThrow
   */
  export type ApplicationDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDocument to fetch.
     */
    where?: ApplicationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationDocuments to fetch.
     */
    orderBy?: ApplicationDocumentOrderByWithRelationInput | ApplicationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApplicationDocuments.
     */
    cursor?: ApplicationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApplicationDocuments.
     */
    distinct?: ApplicationDocumentScalarFieldEnum | ApplicationDocumentScalarFieldEnum[]
  }

  /**
   * ApplicationDocument findMany
   */
  export type ApplicationDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationDocuments to fetch.
     */
    where?: ApplicationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationDocuments to fetch.
     */
    orderBy?: ApplicationDocumentOrderByWithRelationInput | ApplicationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApplicationDocuments.
     */
    cursor?: ApplicationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationDocuments.
     */
    skip?: number
    distinct?: ApplicationDocumentScalarFieldEnum | ApplicationDocumentScalarFieldEnum[]
  }

  /**
   * ApplicationDocument create
   */
  export type ApplicationDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a ApplicationDocument.
     */
    data: XOR<ApplicationDocumentCreateInput, ApplicationDocumentUncheckedCreateInput>
  }

  /**
   * ApplicationDocument createMany
   */
  export type ApplicationDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApplicationDocuments.
     */
    data: ApplicationDocumentCreateManyInput | ApplicationDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApplicationDocument createManyAndReturn
   */
  export type ApplicationDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many ApplicationDocuments.
     */
    data: ApplicationDocumentCreateManyInput | ApplicationDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApplicationDocument update
   */
  export type ApplicationDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a ApplicationDocument.
     */
    data: XOR<ApplicationDocumentUpdateInput, ApplicationDocumentUncheckedUpdateInput>
    /**
     * Choose, which ApplicationDocument to update.
     */
    where: ApplicationDocumentWhereUniqueInput
  }

  /**
   * ApplicationDocument updateMany
   */
  export type ApplicationDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApplicationDocuments.
     */
    data: XOR<ApplicationDocumentUpdateManyMutationInput, ApplicationDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ApplicationDocuments to update
     */
    where?: ApplicationDocumentWhereInput
    /**
     * Limit how many ApplicationDocuments to update.
     */
    limit?: number
  }

  /**
   * ApplicationDocument updateManyAndReturn
   */
  export type ApplicationDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * The data used to update ApplicationDocuments.
     */
    data: XOR<ApplicationDocumentUpdateManyMutationInput, ApplicationDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ApplicationDocuments to update
     */
    where?: ApplicationDocumentWhereInput
    /**
     * Limit how many ApplicationDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApplicationDocument upsert
   */
  export type ApplicationDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the ApplicationDocument to update in case it exists.
     */
    where: ApplicationDocumentWhereUniqueInput
    /**
     * In case the ApplicationDocument found by the `where` argument doesn't exist, create a new ApplicationDocument with this data.
     */
    create: XOR<ApplicationDocumentCreateInput, ApplicationDocumentUncheckedCreateInput>
    /**
     * In case the ApplicationDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationDocumentUpdateInput, ApplicationDocumentUncheckedUpdateInput>
  }

  /**
   * ApplicationDocument delete
   */
  export type ApplicationDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
    /**
     * Filter which ApplicationDocument to delete.
     */
    where: ApplicationDocumentWhereUniqueInput
  }

  /**
   * ApplicationDocument deleteMany
   */
  export type ApplicationDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApplicationDocuments to delete
     */
    where?: ApplicationDocumentWhereInput
    /**
     * Limit how many ApplicationDocuments to delete.
     */
    limit?: number
  }

  /**
   * ApplicationDocument.DocumentMapping
   */
  export type ApplicationDocument$DocumentMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingInclude<ExtArgs> | null
    where?: DocumentMappingWhereInput
  }

  /**
   * ApplicationDocument without action
   */
  export type ApplicationDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationDocument
     */
    select?: ApplicationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicationDocument
     */
    omit?: ApplicationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: string | null
    emailThreadId: string | null
    filename: string | null
    content: Uint8Array | null
    createdAt: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: string | null
    emailThreadId: string | null
    filename: string | null
    content: Uint8Array | null
    createdAt: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    emailThreadId: number
    filename: number
    content: number
    createdAt: number
    _all: number
  }


  export type AttachmentMinAggregateInputType = {
    id?: true
    emailThreadId?: true
    filename?: true
    content?: true
    createdAt?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    emailThreadId?: true
    filename?: true
    content?: true
    createdAt?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    emailThreadId?: true
    filename?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: string
    emailThreadId: string
    filename: string
    content: Uint8Array
    createdAt: Date
    _count: AttachmentCountAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailThreadId?: boolean
    filename?: boolean
    content?: boolean
    createdAt?: boolean
    EmailThread?: boolean | EmailThreadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailThreadId?: boolean
    filename?: boolean
    content?: boolean
    createdAt?: boolean
    EmailThread?: boolean | EmailThreadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailThreadId?: boolean
    filename?: boolean
    content?: boolean
    createdAt?: boolean
    EmailThread?: boolean | EmailThreadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    emailThreadId?: boolean
    filename?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type AttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emailThreadId" | "filename" | "content" | "createdAt", ExtArgs["result"]["attachment"]>
  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmailThread?: boolean | EmailThreadDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmailThread?: boolean | EmailThreadDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmailThread?: boolean | EmailThreadDefaultArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      EmailThread: Prisma.$EmailThreadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emailThreadId: string
      filename: string
      content: Uint8Array
      createdAt: Date
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments and returns the data updated in the database.
     * @param {AttachmentUpdateManyAndReturnArgs} args - Arguments to update many Attachments.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EmailThread<T extends EmailThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailThreadDefaultArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'String'>
    readonly emailThreadId: FieldRef<"Attachment", 'String'>
    readonly filename: FieldRef<"Attachment", 'String'>
    readonly content: FieldRef<"Attachment", 'Bytes'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
  }

  /**
   * Attachment updateManyAndReturn
   */
  export type AttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to delete.
     */
    limit?: number
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model CardHolder
   */

  export type AggregateCardHolder = {
    _count: CardHolderCountAggregateOutputType | null
    _min: CardHolderMinAggregateOutputType | null
    _max: CardHolderMaxAggregateOutputType | null
  }

  export type CardHolderMinAggregateOutputType = {
    id: string | null
    name: string | null
    cardType: string | null
    cardNumber: string | null
    address: string | null
    zipcode: string | null
    applicationId: string | null
  }

  export type CardHolderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cardType: string | null
    cardNumber: string | null
    address: string | null
    zipcode: string | null
    applicationId: string | null
  }

  export type CardHolderCountAggregateOutputType = {
    id: number
    name: number
    cardType: number
    cardNumber: number
    address: number
    zipcode: number
    applicationId: number
    _all: number
  }


  export type CardHolderMinAggregateInputType = {
    id?: true
    name?: true
    cardType?: true
    cardNumber?: true
    address?: true
    zipcode?: true
    applicationId?: true
  }

  export type CardHolderMaxAggregateInputType = {
    id?: true
    name?: true
    cardType?: true
    cardNumber?: true
    address?: true
    zipcode?: true
    applicationId?: true
  }

  export type CardHolderCountAggregateInputType = {
    id?: true
    name?: true
    cardType?: true
    cardNumber?: true
    address?: true
    zipcode?: true
    applicationId?: true
    _all?: true
  }

  export type CardHolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardHolder to aggregate.
     */
    where?: CardHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardHolders to fetch.
     */
    orderBy?: CardHolderOrderByWithRelationInput | CardHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardHolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CardHolders
    **/
    _count?: true | CardHolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardHolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardHolderMaxAggregateInputType
  }

  export type GetCardHolderAggregateType<T extends CardHolderAggregateArgs> = {
        [P in keyof T & keyof AggregateCardHolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardHolder[P]>
      : GetScalarType<T[P], AggregateCardHolder[P]>
  }




  export type CardHolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardHolderWhereInput
    orderBy?: CardHolderOrderByWithAggregationInput | CardHolderOrderByWithAggregationInput[]
    by: CardHolderScalarFieldEnum[] | CardHolderScalarFieldEnum
    having?: CardHolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardHolderCountAggregateInputType | true
    _min?: CardHolderMinAggregateInputType
    _max?: CardHolderMaxAggregateInputType
  }

  export type CardHolderGroupByOutputType = {
    id: string
    name: string
    cardType: string
    cardNumber: string
    address: string
    zipcode: string
    applicationId: string
    _count: CardHolderCountAggregateOutputType | null
    _min: CardHolderMinAggregateOutputType | null
    _max: CardHolderMaxAggregateOutputType | null
  }

  type GetCardHolderGroupByPayload<T extends CardHolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardHolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardHolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardHolderGroupByOutputType[P]>
            : GetScalarType<T[P], CardHolderGroupByOutputType[P]>
        }
      >
    >


  export type CardHolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cardType?: boolean
    cardNumber?: boolean
    address?: boolean
    zipcode?: boolean
    applicationId?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardHolder"]>

  export type CardHolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cardType?: boolean
    cardNumber?: boolean
    address?: boolean
    zipcode?: boolean
    applicationId?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardHolder"]>

  export type CardHolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cardType?: boolean
    cardNumber?: boolean
    address?: boolean
    zipcode?: boolean
    applicationId?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardHolder"]>

  export type CardHolderSelectScalar = {
    id?: boolean
    name?: boolean
    cardType?: boolean
    cardNumber?: boolean
    address?: boolean
    zipcode?: boolean
    applicationId?: boolean
  }

  export type CardHolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "cardType" | "cardNumber" | "address" | "zipcode" | "applicationId", ExtArgs["result"]["cardHolder"]>
  export type CardHolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type CardHolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type CardHolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }

  export type $CardHolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CardHolder"
    objects: {
      Application: Prisma.$ApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      cardType: string
      cardNumber: string
      address: string
      zipcode: string
      applicationId: string
    }, ExtArgs["result"]["cardHolder"]>
    composites: {}
  }

  type CardHolderGetPayload<S extends boolean | null | undefined | CardHolderDefaultArgs> = $Result.GetResult<Prisma.$CardHolderPayload, S>

  type CardHolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardHolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardHolderCountAggregateInputType | true
    }

  export interface CardHolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CardHolder'], meta: { name: 'CardHolder' } }
    /**
     * Find zero or one CardHolder that matches the filter.
     * @param {CardHolderFindUniqueArgs} args - Arguments to find a CardHolder
     * @example
     * // Get one CardHolder
     * const cardHolder = await prisma.cardHolder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardHolderFindUniqueArgs>(args: SelectSubset<T, CardHolderFindUniqueArgs<ExtArgs>>): Prisma__CardHolderClient<$Result.GetResult<Prisma.$CardHolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CardHolder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardHolderFindUniqueOrThrowArgs} args - Arguments to find a CardHolder
     * @example
     * // Get one CardHolder
     * const cardHolder = await prisma.cardHolder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardHolderFindUniqueOrThrowArgs>(args: SelectSubset<T, CardHolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardHolderClient<$Result.GetResult<Prisma.$CardHolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardHolder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardHolderFindFirstArgs} args - Arguments to find a CardHolder
     * @example
     * // Get one CardHolder
     * const cardHolder = await prisma.cardHolder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardHolderFindFirstArgs>(args?: SelectSubset<T, CardHolderFindFirstArgs<ExtArgs>>): Prisma__CardHolderClient<$Result.GetResult<Prisma.$CardHolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardHolder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardHolderFindFirstOrThrowArgs} args - Arguments to find a CardHolder
     * @example
     * // Get one CardHolder
     * const cardHolder = await prisma.cardHolder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardHolderFindFirstOrThrowArgs>(args?: SelectSubset<T, CardHolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardHolderClient<$Result.GetResult<Prisma.$CardHolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CardHolders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardHolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CardHolders
     * const cardHolders = await prisma.cardHolder.findMany()
     * 
     * // Get first 10 CardHolders
     * const cardHolders = await prisma.cardHolder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardHolderWithIdOnly = await prisma.cardHolder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardHolderFindManyArgs>(args?: SelectSubset<T, CardHolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardHolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CardHolder.
     * @param {CardHolderCreateArgs} args - Arguments to create a CardHolder.
     * @example
     * // Create one CardHolder
     * const CardHolder = await prisma.cardHolder.create({
     *   data: {
     *     // ... data to create a CardHolder
     *   }
     * })
     * 
     */
    create<T extends CardHolderCreateArgs>(args: SelectSubset<T, CardHolderCreateArgs<ExtArgs>>): Prisma__CardHolderClient<$Result.GetResult<Prisma.$CardHolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CardHolders.
     * @param {CardHolderCreateManyArgs} args - Arguments to create many CardHolders.
     * @example
     * // Create many CardHolders
     * const cardHolder = await prisma.cardHolder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardHolderCreateManyArgs>(args?: SelectSubset<T, CardHolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CardHolders and returns the data saved in the database.
     * @param {CardHolderCreateManyAndReturnArgs} args - Arguments to create many CardHolders.
     * @example
     * // Create many CardHolders
     * const cardHolder = await prisma.cardHolder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CardHolders and only return the `id`
     * const cardHolderWithIdOnly = await prisma.cardHolder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CardHolderCreateManyAndReturnArgs>(args?: SelectSubset<T, CardHolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardHolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CardHolder.
     * @param {CardHolderDeleteArgs} args - Arguments to delete one CardHolder.
     * @example
     * // Delete one CardHolder
     * const CardHolder = await prisma.cardHolder.delete({
     *   where: {
     *     // ... filter to delete one CardHolder
     *   }
     * })
     * 
     */
    delete<T extends CardHolderDeleteArgs>(args: SelectSubset<T, CardHolderDeleteArgs<ExtArgs>>): Prisma__CardHolderClient<$Result.GetResult<Prisma.$CardHolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CardHolder.
     * @param {CardHolderUpdateArgs} args - Arguments to update one CardHolder.
     * @example
     * // Update one CardHolder
     * const cardHolder = await prisma.cardHolder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardHolderUpdateArgs>(args: SelectSubset<T, CardHolderUpdateArgs<ExtArgs>>): Prisma__CardHolderClient<$Result.GetResult<Prisma.$CardHolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CardHolders.
     * @param {CardHolderDeleteManyArgs} args - Arguments to filter CardHolders to delete.
     * @example
     * // Delete a few CardHolders
     * const { count } = await prisma.cardHolder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardHolderDeleteManyArgs>(args?: SelectSubset<T, CardHolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardHolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardHolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CardHolders
     * const cardHolder = await prisma.cardHolder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardHolderUpdateManyArgs>(args: SelectSubset<T, CardHolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardHolders and returns the data updated in the database.
     * @param {CardHolderUpdateManyAndReturnArgs} args - Arguments to update many CardHolders.
     * @example
     * // Update many CardHolders
     * const cardHolder = await prisma.cardHolder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CardHolders and only return the `id`
     * const cardHolderWithIdOnly = await prisma.cardHolder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CardHolderUpdateManyAndReturnArgs>(args: SelectSubset<T, CardHolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardHolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CardHolder.
     * @param {CardHolderUpsertArgs} args - Arguments to update or create a CardHolder.
     * @example
     * // Update or create a CardHolder
     * const cardHolder = await prisma.cardHolder.upsert({
     *   create: {
     *     // ... data to create a CardHolder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CardHolder we want to update
     *   }
     * })
     */
    upsert<T extends CardHolderUpsertArgs>(args: SelectSubset<T, CardHolderUpsertArgs<ExtArgs>>): Prisma__CardHolderClient<$Result.GetResult<Prisma.$CardHolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CardHolders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardHolderCountArgs} args - Arguments to filter CardHolders to count.
     * @example
     * // Count the number of CardHolders
     * const count = await prisma.cardHolder.count({
     *   where: {
     *     // ... the filter for the CardHolders we want to count
     *   }
     * })
    **/
    count<T extends CardHolderCountArgs>(
      args?: Subset<T, CardHolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardHolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CardHolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardHolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardHolderAggregateArgs>(args: Subset<T, CardHolderAggregateArgs>): Prisma.PrismaPromise<GetCardHolderAggregateType<T>>

    /**
     * Group by CardHolder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardHolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardHolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardHolderGroupByArgs['orderBy'] }
        : { orderBy?: CardHolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardHolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardHolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CardHolder model
   */
  readonly fields: CardHolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CardHolder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardHolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Application<T extends ApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDefaultArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CardHolder model
   */
  interface CardHolderFieldRefs {
    readonly id: FieldRef<"CardHolder", 'String'>
    readonly name: FieldRef<"CardHolder", 'String'>
    readonly cardType: FieldRef<"CardHolder", 'String'>
    readonly cardNumber: FieldRef<"CardHolder", 'String'>
    readonly address: FieldRef<"CardHolder", 'String'>
    readonly zipcode: FieldRef<"CardHolder", 'String'>
    readonly applicationId: FieldRef<"CardHolder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CardHolder findUnique
   */
  export type CardHolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderInclude<ExtArgs> | null
    /**
     * Filter, which CardHolder to fetch.
     */
    where: CardHolderWhereUniqueInput
  }

  /**
   * CardHolder findUniqueOrThrow
   */
  export type CardHolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderInclude<ExtArgs> | null
    /**
     * Filter, which CardHolder to fetch.
     */
    where: CardHolderWhereUniqueInput
  }

  /**
   * CardHolder findFirst
   */
  export type CardHolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderInclude<ExtArgs> | null
    /**
     * Filter, which CardHolder to fetch.
     */
    where?: CardHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardHolders to fetch.
     */
    orderBy?: CardHolderOrderByWithRelationInput | CardHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardHolders.
     */
    cursor?: CardHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardHolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardHolders.
     */
    distinct?: CardHolderScalarFieldEnum | CardHolderScalarFieldEnum[]
  }

  /**
   * CardHolder findFirstOrThrow
   */
  export type CardHolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderInclude<ExtArgs> | null
    /**
     * Filter, which CardHolder to fetch.
     */
    where?: CardHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardHolders to fetch.
     */
    orderBy?: CardHolderOrderByWithRelationInput | CardHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardHolders.
     */
    cursor?: CardHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardHolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardHolders.
     */
    distinct?: CardHolderScalarFieldEnum | CardHolderScalarFieldEnum[]
  }

  /**
   * CardHolder findMany
   */
  export type CardHolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderInclude<ExtArgs> | null
    /**
     * Filter, which CardHolders to fetch.
     */
    where?: CardHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardHolders to fetch.
     */
    orderBy?: CardHolderOrderByWithRelationInput | CardHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CardHolders.
     */
    cursor?: CardHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardHolders.
     */
    skip?: number
    distinct?: CardHolderScalarFieldEnum | CardHolderScalarFieldEnum[]
  }

  /**
   * CardHolder create
   */
  export type CardHolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderInclude<ExtArgs> | null
    /**
     * The data needed to create a CardHolder.
     */
    data: XOR<CardHolderCreateInput, CardHolderUncheckedCreateInput>
  }

  /**
   * CardHolder createMany
   */
  export type CardHolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CardHolders.
     */
    data: CardHolderCreateManyInput | CardHolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CardHolder createManyAndReturn
   */
  export type CardHolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * The data used to create many CardHolders.
     */
    data: CardHolderCreateManyInput | CardHolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardHolder update
   */
  export type CardHolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderInclude<ExtArgs> | null
    /**
     * The data needed to update a CardHolder.
     */
    data: XOR<CardHolderUpdateInput, CardHolderUncheckedUpdateInput>
    /**
     * Choose, which CardHolder to update.
     */
    where: CardHolderWhereUniqueInput
  }

  /**
   * CardHolder updateMany
   */
  export type CardHolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CardHolders.
     */
    data: XOR<CardHolderUpdateManyMutationInput, CardHolderUncheckedUpdateManyInput>
    /**
     * Filter which CardHolders to update
     */
    where?: CardHolderWhereInput
    /**
     * Limit how many CardHolders to update.
     */
    limit?: number
  }

  /**
   * CardHolder updateManyAndReturn
   */
  export type CardHolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * The data used to update CardHolders.
     */
    data: XOR<CardHolderUpdateManyMutationInput, CardHolderUncheckedUpdateManyInput>
    /**
     * Filter which CardHolders to update
     */
    where?: CardHolderWhereInput
    /**
     * Limit how many CardHolders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardHolder upsert
   */
  export type CardHolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderInclude<ExtArgs> | null
    /**
     * The filter to search for the CardHolder to update in case it exists.
     */
    where: CardHolderWhereUniqueInput
    /**
     * In case the CardHolder found by the `where` argument doesn't exist, create a new CardHolder with this data.
     */
    create: XOR<CardHolderCreateInput, CardHolderUncheckedCreateInput>
    /**
     * In case the CardHolder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardHolderUpdateInput, CardHolderUncheckedUpdateInput>
  }

  /**
   * CardHolder delete
   */
  export type CardHolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderInclude<ExtArgs> | null
    /**
     * Filter which CardHolder to delete.
     */
    where: CardHolderWhereUniqueInput
  }

  /**
   * CardHolder deleteMany
   */
  export type CardHolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardHolders to delete
     */
    where?: CardHolderWhereInput
    /**
     * Limit how many CardHolders to delete.
     */
    limit?: number
  }

  /**
   * CardHolder without action
   */
  export type CardHolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardHolder
     */
    select?: CardHolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardHolder
     */
    omit?: CardHolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardHolderInclude<ExtArgs> | null
  }


  /**
   * Model Case
   */

  export type AggregateCase = {
    _count: CaseCountAggregateOutputType | null
    _min: CaseMinAggregateOutputType | null
    _max: CaseMaxAggregateOutputType | null
  }

  export type CaseMinAggregateOutputType = {
    id: string | null
    gmailThreadId: string | null
    email: string | null
    subject: string | null
    status: string | null
    lastUpdate: Date | null
    websiteCreatedAt: string | null
    accountId: string | null
    applicationId: string | null
    assignedTo: string | null
    topic: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CaseMaxAggregateOutputType = {
    id: string | null
    gmailThreadId: string | null
    email: string | null
    subject: string | null
    status: string | null
    lastUpdate: Date | null
    websiteCreatedAt: string | null
    accountId: string | null
    applicationId: string | null
    assignedTo: string | null
    topic: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CaseCountAggregateOutputType = {
    id: number
    gmailThreadId: number
    email: number
    subject: number
    status: number
    lastUpdate: number
    websiteCreatedAt: number
    accountId: number
    applicationId: number
    assignedTo: number
    topic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CaseMinAggregateInputType = {
    id?: true
    gmailThreadId?: true
    email?: true
    subject?: true
    status?: true
    lastUpdate?: true
    websiteCreatedAt?: true
    accountId?: true
    applicationId?: true
    assignedTo?: true
    topic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CaseMaxAggregateInputType = {
    id?: true
    gmailThreadId?: true
    email?: true
    subject?: true
    status?: true
    lastUpdate?: true
    websiteCreatedAt?: true
    accountId?: true
    applicationId?: true
    assignedTo?: true
    topic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CaseCountAggregateInputType = {
    id?: true
    gmailThreadId?: true
    email?: true
    subject?: true
    status?: true
    lastUpdate?: true
    websiteCreatedAt?: true
    accountId?: true
    applicationId?: true
    assignedTo?: true
    topic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Case to aggregate.
     */
    where?: CaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cases to fetch.
     */
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cases
    **/
    _count?: true | CaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaseMaxAggregateInputType
  }

  export type GetCaseAggregateType<T extends CaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCase[P]>
      : GetScalarType<T[P], AggregateCase[P]>
  }




  export type CaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseWhereInput
    orderBy?: CaseOrderByWithAggregationInput | CaseOrderByWithAggregationInput[]
    by: CaseScalarFieldEnum[] | CaseScalarFieldEnum
    having?: CaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseCountAggregateInputType | true
    _min?: CaseMinAggregateInputType
    _max?: CaseMaxAggregateInputType
  }

  export type CaseGroupByOutputType = {
    id: string
    gmailThreadId: string | null
    email: string
    subject: string
    status: string
    lastUpdate: Date
    websiteCreatedAt: string
    accountId: string | null
    applicationId: string | null
    assignedTo: string | null
    topic: string | null
    createdAt: Date
    updatedAt: Date
    _count: CaseCountAggregateOutputType | null
    _min: CaseMinAggregateOutputType | null
    _max: CaseMaxAggregateOutputType | null
  }

  type GetCaseGroupByPayload<T extends CaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseGroupByOutputType[P]>
            : GetScalarType<T[P], CaseGroupByOutputType[P]>
        }
      >
    >


  export type CaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gmailThreadId?: boolean
    email?: boolean
    subject?: boolean
    status?: boolean
    lastUpdate?: boolean
    websiteCreatedAt?: boolean
    accountId?: boolean
    applicationId?: boolean
    assignedTo?: boolean
    topic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Account?: boolean | Case$AccountArgs<ExtArgs>
    Application?: boolean | Case$ApplicationArgs<ExtArgs>
    EmailThread?: boolean | Case$EmailThreadArgs<ExtArgs>
    _count?: boolean | CaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["case"]>

  export type CaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gmailThreadId?: boolean
    email?: boolean
    subject?: boolean
    status?: boolean
    lastUpdate?: boolean
    websiteCreatedAt?: boolean
    accountId?: boolean
    applicationId?: boolean
    assignedTo?: boolean
    topic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Account?: boolean | Case$AccountArgs<ExtArgs>
    Application?: boolean | Case$ApplicationArgs<ExtArgs>
  }, ExtArgs["result"]["case"]>

  export type CaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gmailThreadId?: boolean
    email?: boolean
    subject?: boolean
    status?: boolean
    lastUpdate?: boolean
    websiteCreatedAt?: boolean
    accountId?: boolean
    applicationId?: boolean
    assignedTo?: boolean
    topic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Account?: boolean | Case$AccountArgs<ExtArgs>
    Application?: boolean | Case$ApplicationArgs<ExtArgs>
  }, ExtArgs["result"]["case"]>

  export type CaseSelectScalar = {
    id?: boolean
    gmailThreadId?: boolean
    email?: boolean
    subject?: boolean
    status?: boolean
    lastUpdate?: boolean
    websiteCreatedAt?: boolean
    accountId?: boolean
    applicationId?: boolean
    assignedTo?: boolean
    topic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gmailThreadId" | "email" | "subject" | "status" | "lastUpdate" | "websiteCreatedAt" | "accountId" | "applicationId" | "assignedTo" | "topic" | "createdAt" | "updatedAt", ExtArgs["result"]["case"]>
  export type CaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | Case$AccountArgs<ExtArgs>
    Application?: boolean | Case$ApplicationArgs<ExtArgs>
    EmailThread?: boolean | Case$EmailThreadArgs<ExtArgs>
    _count?: boolean | CaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | Case$AccountArgs<ExtArgs>
    Application?: boolean | Case$ApplicationArgs<ExtArgs>
  }
  export type CaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | Case$AccountArgs<ExtArgs>
    Application?: boolean | Case$ApplicationArgs<ExtArgs>
  }

  export type $CasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Case"
    objects: {
      Account: Prisma.$AccountPayload<ExtArgs> | null
      Application: Prisma.$ApplicationPayload<ExtArgs> | null
      EmailThread: Prisma.$EmailThreadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gmailThreadId: string | null
      email: string
      subject: string
      status: string
      lastUpdate: Date
      websiteCreatedAt: string
      accountId: string | null
      applicationId: string | null
      assignedTo: string | null
      topic: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["case"]>
    composites: {}
  }

  type CaseGetPayload<S extends boolean | null | undefined | CaseDefaultArgs> = $Result.GetResult<Prisma.$CasePayload, S>

  type CaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseCountAggregateInputType | true
    }

  export interface CaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Case'], meta: { name: 'Case' } }
    /**
     * Find zero or one Case that matches the filter.
     * @param {CaseFindUniqueArgs} args - Arguments to find a Case
     * @example
     * // Get one Case
     * const case = await prisma.case.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseFindUniqueArgs>(args: SelectSubset<T, CaseFindUniqueArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Case that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseFindUniqueOrThrowArgs} args - Arguments to find a Case
     * @example
     * // Get one Case
     * const case = await prisma.case.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Case that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseFindFirstArgs} args - Arguments to find a Case
     * @example
     * // Get one Case
     * const case = await prisma.case.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseFindFirstArgs>(args?: SelectSubset<T, CaseFindFirstArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Case that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseFindFirstOrThrowArgs} args - Arguments to find a Case
     * @example
     * // Get one Case
     * const case = await prisma.case.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cases
     * const cases = await prisma.case.findMany()
     * 
     * // Get first 10 Cases
     * const cases = await prisma.case.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caseWithIdOnly = await prisma.case.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaseFindManyArgs>(args?: SelectSubset<T, CaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Case.
     * @param {CaseCreateArgs} args - Arguments to create a Case.
     * @example
     * // Create one Case
     * const Case = await prisma.case.create({
     *   data: {
     *     // ... data to create a Case
     *   }
     * })
     * 
     */
    create<T extends CaseCreateArgs>(args: SelectSubset<T, CaseCreateArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cases.
     * @param {CaseCreateManyArgs} args - Arguments to create many Cases.
     * @example
     * // Create many Cases
     * const case = await prisma.case.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaseCreateManyArgs>(args?: SelectSubset<T, CaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cases and returns the data saved in the database.
     * @param {CaseCreateManyAndReturnArgs} args - Arguments to create many Cases.
     * @example
     * // Create many Cases
     * const case = await prisma.case.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cases and only return the `id`
     * const caseWithIdOnly = await prisma.case.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Case.
     * @param {CaseDeleteArgs} args - Arguments to delete one Case.
     * @example
     * // Delete one Case
     * const Case = await prisma.case.delete({
     *   where: {
     *     // ... filter to delete one Case
     *   }
     * })
     * 
     */
    delete<T extends CaseDeleteArgs>(args: SelectSubset<T, CaseDeleteArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Case.
     * @param {CaseUpdateArgs} args - Arguments to update one Case.
     * @example
     * // Update one Case
     * const case = await prisma.case.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaseUpdateArgs>(args: SelectSubset<T, CaseUpdateArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cases.
     * @param {CaseDeleteManyArgs} args - Arguments to filter Cases to delete.
     * @example
     * // Delete a few Cases
     * const { count } = await prisma.case.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaseDeleteManyArgs>(args?: SelectSubset<T, CaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cases
     * const case = await prisma.case.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaseUpdateManyArgs>(args: SelectSubset<T, CaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cases and returns the data updated in the database.
     * @param {CaseUpdateManyAndReturnArgs} args - Arguments to update many Cases.
     * @example
     * // Update many Cases
     * const case = await prisma.case.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cases and only return the `id`
     * const caseWithIdOnly = await prisma.case.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CaseUpdateManyAndReturnArgs>(args: SelectSubset<T, CaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Case.
     * @param {CaseUpsertArgs} args - Arguments to update or create a Case.
     * @example
     * // Update or create a Case
     * const case = await prisma.case.upsert({
     *   create: {
     *     // ... data to create a Case
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Case we want to update
     *   }
     * })
     */
    upsert<T extends CaseUpsertArgs>(args: SelectSubset<T, CaseUpsertArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseCountArgs} args - Arguments to filter Cases to count.
     * @example
     * // Count the number of Cases
     * const count = await prisma.case.count({
     *   where: {
     *     // ... the filter for the Cases we want to count
     *   }
     * })
    **/
    count<T extends CaseCountArgs>(
      args?: Subset<T, CaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Case.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseAggregateArgs>(args: Subset<T, CaseAggregateArgs>): Prisma.PrismaPromise<GetCaseAggregateType<T>>

    /**
     * Group by Case.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseGroupByArgs['orderBy'] }
        : { orderBy?: CaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Case model
   */
  readonly fields: CaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Case.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Account<T extends Case$AccountArgs<ExtArgs> = {}>(args?: Subset<T, Case$AccountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Application<T extends Case$ApplicationArgs<ExtArgs> = {}>(args?: Subset<T, Case$ApplicationArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    EmailThread<T extends Case$EmailThreadArgs<ExtArgs> = {}>(args?: Subset<T, Case$EmailThreadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Case model
   */
  interface CaseFieldRefs {
    readonly id: FieldRef<"Case", 'String'>
    readonly gmailThreadId: FieldRef<"Case", 'String'>
    readonly email: FieldRef<"Case", 'String'>
    readonly subject: FieldRef<"Case", 'String'>
    readonly status: FieldRef<"Case", 'String'>
    readonly lastUpdate: FieldRef<"Case", 'DateTime'>
    readonly websiteCreatedAt: FieldRef<"Case", 'String'>
    readonly accountId: FieldRef<"Case", 'String'>
    readonly applicationId: FieldRef<"Case", 'String'>
    readonly assignedTo: FieldRef<"Case", 'String'>
    readonly topic: FieldRef<"Case", 'String'>
    readonly createdAt: FieldRef<"Case", 'DateTime'>
    readonly updatedAt: FieldRef<"Case", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Case findUnique
   */
  export type CaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Case to fetch.
     */
    where: CaseWhereUniqueInput
  }

  /**
   * Case findUniqueOrThrow
   */
  export type CaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Case to fetch.
     */
    where: CaseWhereUniqueInput
  }

  /**
   * Case findFirst
   */
  export type CaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Case to fetch.
     */
    where?: CaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cases to fetch.
     */
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cases.
     */
    cursor?: CaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cases.
     */
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * Case findFirstOrThrow
   */
  export type CaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Case to fetch.
     */
    where?: CaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cases to fetch.
     */
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cases.
     */
    cursor?: CaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cases.
     */
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * Case findMany
   */
  export type CaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter, which Cases to fetch.
     */
    where?: CaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cases to fetch.
     */
    orderBy?: CaseOrderByWithRelationInput | CaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cases.
     */
    cursor?: CaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cases.
     */
    skip?: number
    distinct?: CaseScalarFieldEnum | CaseScalarFieldEnum[]
  }

  /**
   * Case create
   */
  export type CaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Case.
     */
    data: XOR<CaseCreateInput, CaseUncheckedCreateInput>
  }

  /**
   * Case createMany
   */
  export type CaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cases.
     */
    data: CaseCreateManyInput | CaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Case createManyAndReturn
   */
  export type CaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * The data used to create many Cases.
     */
    data: CaseCreateManyInput | CaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Case update
   */
  export type CaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Case.
     */
    data: XOR<CaseUpdateInput, CaseUncheckedUpdateInput>
    /**
     * Choose, which Case to update.
     */
    where: CaseWhereUniqueInput
  }

  /**
   * Case updateMany
   */
  export type CaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cases.
     */
    data: XOR<CaseUpdateManyMutationInput, CaseUncheckedUpdateManyInput>
    /**
     * Filter which Cases to update
     */
    where?: CaseWhereInput
    /**
     * Limit how many Cases to update.
     */
    limit?: number
  }

  /**
   * Case updateManyAndReturn
   */
  export type CaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * The data used to update Cases.
     */
    data: XOR<CaseUpdateManyMutationInput, CaseUncheckedUpdateManyInput>
    /**
     * Filter which Cases to update
     */
    where?: CaseWhereInput
    /**
     * Limit how many Cases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Case upsert
   */
  export type CaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Case to update in case it exists.
     */
    where: CaseWhereUniqueInput
    /**
     * In case the Case found by the `where` argument doesn't exist, create a new Case with this data.
     */
    create: XOR<CaseCreateInput, CaseUncheckedCreateInput>
    /**
     * In case the Case was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseUpdateInput, CaseUncheckedUpdateInput>
  }

  /**
   * Case delete
   */
  export type CaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
    /**
     * Filter which Case to delete.
     */
    where: CaseWhereUniqueInput
  }

  /**
   * Case deleteMany
   */
  export type CaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cases to delete
     */
    where?: CaseWhereInput
    /**
     * Limit how many Cases to delete.
     */
    limit?: number
  }

  /**
   * Case.Account
   */
  export type Case$AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Case.Application
   */
  export type Case$ApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
  }

  /**
   * Case.EmailThread
   */
  export type Case$EmailThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    where?: EmailThreadWhereInput
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    cursor?: EmailThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }

  /**
   * Case without action
   */
  export type CaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Case
     */
    select?: CaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Case
     */
    omit?: CaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInclude<ExtArgs> | null
  }


  /**
   * Model CaseSequence
   */

  export type AggregateCaseSequence = {
    _count: CaseSequenceCountAggregateOutputType | null
    _avg: CaseSequenceAvgAggregateOutputType | null
    _sum: CaseSequenceSumAggregateOutputType | null
    _min: CaseSequenceMinAggregateOutputType | null
    _max: CaseSequenceMaxAggregateOutputType | null
  }

  export type CaseSequenceAvgAggregateOutputType = {
    year: number | null
    currentSequence: number | null
  }

  export type CaseSequenceSumAggregateOutputType = {
    year: number | null
    currentSequence: number | null
  }

  export type CaseSequenceMinAggregateOutputType = {
    year: number | null
    currentSequence: number | null
    updatedAt: Date | null
  }

  export type CaseSequenceMaxAggregateOutputType = {
    year: number | null
    currentSequence: number | null
    updatedAt: Date | null
  }

  export type CaseSequenceCountAggregateOutputType = {
    year: number
    currentSequence: number
    updatedAt: number
    _all: number
  }


  export type CaseSequenceAvgAggregateInputType = {
    year?: true
    currentSequence?: true
  }

  export type CaseSequenceSumAggregateInputType = {
    year?: true
    currentSequence?: true
  }

  export type CaseSequenceMinAggregateInputType = {
    year?: true
    currentSequence?: true
    updatedAt?: true
  }

  export type CaseSequenceMaxAggregateInputType = {
    year?: true
    currentSequence?: true
    updatedAt?: true
  }

  export type CaseSequenceCountAggregateInputType = {
    year?: true
    currentSequence?: true
    updatedAt?: true
    _all?: true
  }

  export type CaseSequenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseSequence to aggregate.
     */
    where?: CaseSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseSequences to fetch.
     */
    orderBy?: CaseSequenceOrderByWithRelationInput | CaseSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaseSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CaseSequences
    **/
    _count?: true | CaseSequenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CaseSequenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CaseSequenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaseSequenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaseSequenceMaxAggregateInputType
  }

  export type GetCaseSequenceAggregateType<T extends CaseSequenceAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseSequence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseSequence[P]>
      : GetScalarType<T[P], AggregateCaseSequence[P]>
  }




  export type CaseSequenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseSequenceWhereInput
    orderBy?: CaseSequenceOrderByWithAggregationInput | CaseSequenceOrderByWithAggregationInput[]
    by: CaseSequenceScalarFieldEnum[] | CaseSequenceScalarFieldEnum
    having?: CaseSequenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseSequenceCountAggregateInputType | true
    _avg?: CaseSequenceAvgAggregateInputType
    _sum?: CaseSequenceSumAggregateInputType
    _min?: CaseSequenceMinAggregateInputType
    _max?: CaseSequenceMaxAggregateInputType
  }

  export type CaseSequenceGroupByOutputType = {
    year: number
    currentSequence: number | null
    updatedAt: Date
    _count: CaseSequenceCountAggregateOutputType | null
    _avg: CaseSequenceAvgAggregateOutputType | null
    _sum: CaseSequenceSumAggregateOutputType | null
    _min: CaseSequenceMinAggregateOutputType | null
    _max: CaseSequenceMaxAggregateOutputType | null
  }

  type GetCaseSequenceGroupByPayload<T extends CaseSequenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseSequenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseSequenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseSequenceGroupByOutputType[P]>
            : GetScalarType<T[P], CaseSequenceGroupByOutputType[P]>
        }
      >
    >


  export type CaseSequenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    year?: boolean
    currentSequence?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["caseSequence"]>

  export type CaseSequenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    year?: boolean
    currentSequence?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["caseSequence"]>

  export type CaseSequenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    year?: boolean
    currentSequence?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["caseSequence"]>

  export type CaseSequenceSelectScalar = {
    year?: boolean
    currentSequence?: boolean
    updatedAt?: boolean
  }

  export type CaseSequenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"year" | "currentSequence" | "updatedAt", ExtArgs["result"]["caseSequence"]>

  export type $CaseSequencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseSequence"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      year: number
      currentSequence: number | null
      updatedAt: Date
    }, ExtArgs["result"]["caseSequence"]>
    composites: {}
  }

  type CaseSequenceGetPayload<S extends boolean | null | undefined | CaseSequenceDefaultArgs> = $Result.GetResult<Prisma.$CaseSequencePayload, S>

  type CaseSequenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseSequenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseSequenceCountAggregateInputType | true
    }

  export interface CaseSequenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseSequence'], meta: { name: 'CaseSequence' } }
    /**
     * Find zero or one CaseSequence that matches the filter.
     * @param {CaseSequenceFindUniqueArgs} args - Arguments to find a CaseSequence
     * @example
     * // Get one CaseSequence
     * const caseSequence = await prisma.caseSequence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseSequenceFindUniqueArgs>(args: SelectSubset<T, CaseSequenceFindUniqueArgs<ExtArgs>>): Prisma__CaseSequenceClient<$Result.GetResult<Prisma.$CaseSequencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseSequence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseSequenceFindUniqueOrThrowArgs} args - Arguments to find a CaseSequence
     * @example
     * // Get one CaseSequence
     * const caseSequence = await prisma.caseSequence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseSequenceFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseSequenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseSequenceClient<$Result.GetResult<Prisma.$CaseSequencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseSequence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseSequenceFindFirstArgs} args - Arguments to find a CaseSequence
     * @example
     * // Get one CaseSequence
     * const caseSequence = await prisma.caseSequence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseSequenceFindFirstArgs>(args?: SelectSubset<T, CaseSequenceFindFirstArgs<ExtArgs>>): Prisma__CaseSequenceClient<$Result.GetResult<Prisma.$CaseSequencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseSequence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseSequenceFindFirstOrThrowArgs} args - Arguments to find a CaseSequence
     * @example
     * // Get one CaseSequence
     * const caseSequence = await prisma.caseSequence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseSequenceFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseSequenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseSequenceClient<$Result.GetResult<Prisma.$CaseSequencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseSequences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseSequenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseSequences
     * const caseSequences = await prisma.caseSequence.findMany()
     * 
     * // Get first 10 CaseSequences
     * const caseSequences = await prisma.caseSequence.findMany({ take: 10 })
     * 
     * // Only select the `year`
     * const caseSequenceWithYearOnly = await prisma.caseSequence.findMany({ select: { year: true } })
     * 
     */
    findMany<T extends CaseSequenceFindManyArgs>(args?: SelectSubset<T, CaseSequenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseSequencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseSequence.
     * @param {CaseSequenceCreateArgs} args - Arguments to create a CaseSequence.
     * @example
     * // Create one CaseSequence
     * const CaseSequence = await prisma.caseSequence.create({
     *   data: {
     *     // ... data to create a CaseSequence
     *   }
     * })
     * 
     */
    create<T extends CaseSequenceCreateArgs>(args: SelectSubset<T, CaseSequenceCreateArgs<ExtArgs>>): Prisma__CaseSequenceClient<$Result.GetResult<Prisma.$CaseSequencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseSequences.
     * @param {CaseSequenceCreateManyArgs} args - Arguments to create many CaseSequences.
     * @example
     * // Create many CaseSequences
     * const caseSequence = await prisma.caseSequence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaseSequenceCreateManyArgs>(args?: SelectSubset<T, CaseSequenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseSequences and returns the data saved in the database.
     * @param {CaseSequenceCreateManyAndReturnArgs} args - Arguments to create many CaseSequences.
     * @example
     * // Create many CaseSequences
     * const caseSequence = await prisma.caseSequence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CaseSequences and only return the `year`
     * const caseSequenceWithYearOnly = await prisma.caseSequence.createManyAndReturn({
     *   select: { year: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaseSequenceCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseSequenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseSequencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseSequence.
     * @param {CaseSequenceDeleteArgs} args - Arguments to delete one CaseSequence.
     * @example
     * // Delete one CaseSequence
     * const CaseSequence = await prisma.caseSequence.delete({
     *   where: {
     *     // ... filter to delete one CaseSequence
     *   }
     * })
     * 
     */
    delete<T extends CaseSequenceDeleteArgs>(args: SelectSubset<T, CaseSequenceDeleteArgs<ExtArgs>>): Prisma__CaseSequenceClient<$Result.GetResult<Prisma.$CaseSequencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseSequence.
     * @param {CaseSequenceUpdateArgs} args - Arguments to update one CaseSequence.
     * @example
     * // Update one CaseSequence
     * const caseSequence = await prisma.caseSequence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaseSequenceUpdateArgs>(args: SelectSubset<T, CaseSequenceUpdateArgs<ExtArgs>>): Prisma__CaseSequenceClient<$Result.GetResult<Prisma.$CaseSequencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseSequences.
     * @param {CaseSequenceDeleteManyArgs} args - Arguments to filter CaseSequences to delete.
     * @example
     * // Delete a few CaseSequences
     * const { count } = await prisma.caseSequence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaseSequenceDeleteManyArgs>(args?: SelectSubset<T, CaseSequenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseSequences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseSequenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseSequences
     * const caseSequence = await prisma.caseSequence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaseSequenceUpdateManyArgs>(args: SelectSubset<T, CaseSequenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseSequences and returns the data updated in the database.
     * @param {CaseSequenceUpdateManyAndReturnArgs} args - Arguments to update many CaseSequences.
     * @example
     * // Update many CaseSequences
     * const caseSequence = await prisma.caseSequence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CaseSequences and only return the `year`
     * const caseSequenceWithYearOnly = await prisma.caseSequence.updateManyAndReturn({
     *   select: { year: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CaseSequenceUpdateManyAndReturnArgs>(args: SelectSubset<T, CaseSequenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseSequencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CaseSequence.
     * @param {CaseSequenceUpsertArgs} args - Arguments to update or create a CaseSequence.
     * @example
     * // Update or create a CaseSequence
     * const caseSequence = await prisma.caseSequence.upsert({
     *   create: {
     *     // ... data to create a CaseSequence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseSequence we want to update
     *   }
     * })
     */
    upsert<T extends CaseSequenceUpsertArgs>(args: SelectSubset<T, CaseSequenceUpsertArgs<ExtArgs>>): Prisma__CaseSequenceClient<$Result.GetResult<Prisma.$CaseSequencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseSequences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseSequenceCountArgs} args - Arguments to filter CaseSequences to count.
     * @example
     * // Count the number of CaseSequences
     * const count = await prisma.caseSequence.count({
     *   where: {
     *     // ... the filter for the CaseSequences we want to count
     *   }
     * })
    **/
    count<T extends CaseSequenceCountArgs>(
      args?: Subset<T, CaseSequenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseSequenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseSequence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseSequenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseSequenceAggregateArgs>(args: Subset<T, CaseSequenceAggregateArgs>): Prisma.PrismaPromise<GetCaseSequenceAggregateType<T>>

    /**
     * Group by CaseSequence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseSequenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaseSequenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseSequenceGroupByArgs['orderBy'] }
        : { orderBy?: CaseSequenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseSequenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseSequenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseSequence model
   */
  readonly fields: CaseSequenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseSequence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseSequenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseSequence model
   */
  interface CaseSequenceFieldRefs {
    readonly year: FieldRef<"CaseSequence", 'Int'>
    readonly currentSequence: FieldRef<"CaseSequence", 'Int'>
    readonly updatedAt: FieldRef<"CaseSequence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CaseSequence findUnique
   */
  export type CaseSequenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseSequence
     */
    select?: CaseSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseSequence
     */
    omit?: CaseSequenceOmit<ExtArgs> | null
    /**
     * Filter, which CaseSequence to fetch.
     */
    where: CaseSequenceWhereUniqueInput
  }

  /**
   * CaseSequence findUniqueOrThrow
   */
  export type CaseSequenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseSequence
     */
    select?: CaseSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseSequence
     */
    omit?: CaseSequenceOmit<ExtArgs> | null
    /**
     * Filter, which CaseSequence to fetch.
     */
    where: CaseSequenceWhereUniqueInput
  }

  /**
   * CaseSequence findFirst
   */
  export type CaseSequenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseSequence
     */
    select?: CaseSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseSequence
     */
    omit?: CaseSequenceOmit<ExtArgs> | null
    /**
     * Filter, which CaseSequence to fetch.
     */
    where?: CaseSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseSequences to fetch.
     */
    orderBy?: CaseSequenceOrderByWithRelationInput | CaseSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaseSequences.
     */
    cursor?: CaseSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaseSequences.
     */
    distinct?: CaseSequenceScalarFieldEnum | CaseSequenceScalarFieldEnum[]
  }

  /**
   * CaseSequence findFirstOrThrow
   */
  export type CaseSequenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseSequence
     */
    select?: CaseSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseSequence
     */
    omit?: CaseSequenceOmit<ExtArgs> | null
    /**
     * Filter, which CaseSequence to fetch.
     */
    where?: CaseSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseSequences to fetch.
     */
    orderBy?: CaseSequenceOrderByWithRelationInput | CaseSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaseSequences.
     */
    cursor?: CaseSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaseSequences.
     */
    distinct?: CaseSequenceScalarFieldEnum | CaseSequenceScalarFieldEnum[]
  }

  /**
   * CaseSequence findMany
   */
  export type CaseSequenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseSequence
     */
    select?: CaseSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseSequence
     */
    omit?: CaseSequenceOmit<ExtArgs> | null
    /**
     * Filter, which CaseSequences to fetch.
     */
    where?: CaseSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseSequences to fetch.
     */
    orderBy?: CaseSequenceOrderByWithRelationInput | CaseSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CaseSequences.
     */
    cursor?: CaseSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseSequences.
     */
    skip?: number
    distinct?: CaseSequenceScalarFieldEnum | CaseSequenceScalarFieldEnum[]
  }

  /**
   * CaseSequence create
   */
  export type CaseSequenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseSequence
     */
    select?: CaseSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseSequence
     */
    omit?: CaseSequenceOmit<ExtArgs> | null
    /**
     * The data needed to create a CaseSequence.
     */
    data: XOR<CaseSequenceCreateInput, CaseSequenceUncheckedCreateInput>
  }

  /**
   * CaseSequence createMany
   */
  export type CaseSequenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseSequences.
     */
    data: CaseSequenceCreateManyInput | CaseSequenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseSequence createManyAndReturn
   */
  export type CaseSequenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseSequence
     */
    select?: CaseSequenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseSequence
     */
    omit?: CaseSequenceOmit<ExtArgs> | null
    /**
     * The data used to create many CaseSequences.
     */
    data: CaseSequenceCreateManyInput | CaseSequenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseSequence update
   */
  export type CaseSequenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseSequence
     */
    select?: CaseSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseSequence
     */
    omit?: CaseSequenceOmit<ExtArgs> | null
    /**
     * The data needed to update a CaseSequence.
     */
    data: XOR<CaseSequenceUpdateInput, CaseSequenceUncheckedUpdateInput>
    /**
     * Choose, which CaseSequence to update.
     */
    where: CaseSequenceWhereUniqueInput
  }

  /**
   * CaseSequence updateMany
   */
  export type CaseSequenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseSequences.
     */
    data: XOR<CaseSequenceUpdateManyMutationInput, CaseSequenceUncheckedUpdateManyInput>
    /**
     * Filter which CaseSequences to update
     */
    where?: CaseSequenceWhereInput
    /**
     * Limit how many CaseSequences to update.
     */
    limit?: number
  }

  /**
   * CaseSequence updateManyAndReturn
   */
  export type CaseSequenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseSequence
     */
    select?: CaseSequenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseSequence
     */
    omit?: CaseSequenceOmit<ExtArgs> | null
    /**
     * The data used to update CaseSequences.
     */
    data: XOR<CaseSequenceUpdateManyMutationInput, CaseSequenceUncheckedUpdateManyInput>
    /**
     * Filter which CaseSequences to update
     */
    where?: CaseSequenceWhereInput
    /**
     * Limit how many CaseSequences to update.
     */
    limit?: number
  }

  /**
   * CaseSequence upsert
   */
  export type CaseSequenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseSequence
     */
    select?: CaseSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseSequence
     */
    omit?: CaseSequenceOmit<ExtArgs> | null
    /**
     * The filter to search for the CaseSequence to update in case it exists.
     */
    where: CaseSequenceWhereUniqueInput
    /**
     * In case the CaseSequence found by the `where` argument doesn't exist, create a new CaseSequence with this data.
     */
    create: XOR<CaseSequenceCreateInput, CaseSequenceUncheckedCreateInput>
    /**
     * In case the CaseSequence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseSequenceUpdateInput, CaseSequenceUncheckedUpdateInput>
  }

  /**
   * CaseSequence delete
   */
  export type CaseSequenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseSequence
     */
    select?: CaseSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseSequence
     */
    omit?: CaseSequenceOmit<ExtArgs> | null
    /**
     * Filter which CaseSequence to delete.
     */
    where: CaseSequenceWhereUniqueInput
  }

  /**
   * CaseSequence deleteMany
   */
  export type CaseSequenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseSequences to delete
     */
    where?: CaseSequenceWhereInput
    /**
     * Limit how many CaseSequences to delete.
     */
    limit?: number
  }

  /**
   * CaseSequence without action
   */
  export type CaseSequenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseSequence
     */
    select?: CaseSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseSequence
     */
    omit?: CaseSequenceOmit<ExtArgs> | null
  }


  /**
   * Model CustomRequirement
   */

  export type AggregateCustomRequirement = {
    _count: CustomRequirementCountAggregateOutputType | null
    _min: CustomRequirementMinAggregateOutputType | null
    _max: CustomRequirementMaxAggregateOutputType | null
  }

  export type CustomRequirementMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    passengerId: string | null
    title: string | null
    createdAt: Date | null
  }

  export type CustomRequirementMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    passengerId: string | null
    title: string | null
    createdAt: Date | null
  }

  export type CustomRequirementCountAggregateOutputType = {
    id: number
    applicationId: number
    passengerId: number
    title: number
    createdAt: number
    _all: number
  }


  export type CustomRequirementMinAggregateInputType = {
    id?: true
    applicationId?: true
    passengerId?: true
    title?: true
    createdAt?: true
  }

  export type CustomRequirementMaxAggregateInputType = {
    id?: true
    applicationId?: true
    passengerId?: true
    title?: true
    createdAt?: true
  }

  export type CustomRequirementCountAggregateInputType = {
    id?: true
    applicationId?: true
    passengerId?: true
    title?: true
    createdAt?: true
    _all?: true
  }

  export type CustomRequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomRequirement to aggregate.
     */
    where?: CustomRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomRequirements to fetch.
     */
    orderBy?: CustomRequirementOrderByWithRelationInput | CustomRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomRequirements
    **/
    _count?: true | CustomRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomRequirementMaxAggregateInputType
  }

  export type GetCustomRequirementAggregateType<T extends CustomRequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomRequirement[P]>
      : GetScalarType<T[P], AggregateCustomRequirement[P]>
  }




  export type CustomRequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomRequirementWhereInput
    orderBy?: CustomRequirementOrderByWithAggregationInput | CustomRequirementOrderByWithAggregationInput[]
    by: CustomRequirementScalarFieldEnum[] | CustomRequirementScalarFieldEnum
    having?: CustomRequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomRequirementCountAggregateInputType | true
    _min?: CustomRequirementMinAggregateInputType
    _max?: CustomRequirementMaxAggregateInputType
  }

  export type CustomRequirementGroupByOutputType = {
    id: string
    applicationId: string
    passengerId: string
    title: string
    createdAt: Date
    _count: CustomRequirementCountAggregateOutputType | null
    _min: CustomRequirementMinAggregateOutputType | null
    _max: CustomRequirementMaxAggregateOutputType | null
  }

  type GetCustomRequirementGroupByPayload<T extends CustomRequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomRequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomRequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomRequirementGroupByOutputType[P]>
            : GetScalarType<T[P], CustomRequirementGroupByOutputType[P]>
        }
      >
    >


  export type CustomRequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    passengerId?: boolean
    title?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["customRequirement"]>

  export type CustomRequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    passengerId?: boolean
    title?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["customRequirement"]>

  export type CustomRequirementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    passengerId?: boolean
    title?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["customRequirement"]>

  export type CustomRequirementSelectScalar = {
    id?: boolean
    applicationId?: boolean
    passengerId?: boolean
    title?: boolean
    createdAt?: boolean
  }

  export type CustomRequirementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationId" | "passengerId" | "title" | "createdAt", ExtArgs["result"]["customRequirement"]>

  export type $CustomRequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomRequirement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      passengerId: string
      title: string
      createdAt: Date
    }, ExtArgs["result"]["customRequirement"]>
    composites: {}
  }

  type CustomRequirementGetPayload<S extends boolean | null | undefined | CustomRequirementDefaultArgs> = $Result.GetResult<Prisma.$CustomRequirementPayload, S>

  type CustomRequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomRequirementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomRequirementCountAggregateInputType | true
    }

  export interface CustomRequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomRequirement'], meta: { name: 'CustomRequirement' } }
    /**
     * Find zero or one CustomRequirement that matches the filter.
     * @param {CustomRequirementFindUniqueArgs} args - Arguments to find a CustomRequirement
     * @example
     * // Get one CustomRequirement
     * const customRequirement = await prisma.customRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomRequirementFindUniqueArgs>(args: SelectSubset<T, CustomRequirementFindUniqueArgs<ExtArgs>>): Prisma__CustomRequirementClient<$Result.GetResult<Prisma.$CustomRequirementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomRequirement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomRequirementFindUniqueOrThrowArgs} args - Arguments to find a CustomRequirement
     * @example
     * // Get one CustomRequirement
     * const customRequirement = await prisma.customRequirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomRequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomRequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomRequirementClient<$Result.GetResult<Prisma.$CustomRequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRequirementFindFirstArgs} args - Arguments to find a CustomRequirement
     * @example
     * // Get one CustomRequirement
     * const customRequirement = await prisma.customRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomRequirementFindFirstArgs>(args?: SelectSubset<T, CustomRequirementFindFirstArgs<ExtArgs>>): Prisma__CustomRequirementClient<$Result.GetResult<Prisma.$CustomRequirementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomRequirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRequirementFindFirstOrThrowArgs} args - Arguments to find a CustomRequirement
     * @example
     * // Get one CustomRequirement
     * const customRequirement = await prisma.customRequirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomRequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomRequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomRequirementClient<$Result.GetResult<Prisma.$CustomRequirementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomRequirements
     * const customRequirements = await prisma.customRequirement.findMany()
     * 
     * // Get first 10 CustomRequirements
     * const customRequirements = await prisma.customRequirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customRequirementWithIdOnly = await prisma.customRequirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomRequirementFindManyArgs>(args?: SelectSubset<T, CustomRequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomRequirement.
     * @param {CustomRequirementCreateArgs} args - Arguments to create a CustomRequirement.
     * @example
     * // Create one CustomRequirement
     * const CustomRequirement = await prisma.customRequirement.create({
     *   data: {
     *     // ... data to create a CustomRequirement
     *   }
     * })
     * 
     */
    create<T extends CustomRequirementCreateArgs>(args: SelectSubset<T, CustomRequirementCreateArgs<ExtArgs>>): Prisma__CustomRequirementClient<$Result.GetResult<Prisma.$CustomRequirementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomRequirements.
     * @param {CustomRequirementCreateManyArgs} args - Arguments to create many CustomRequirements.
     * @example
     * // Create many CustomRequirements
     * const customRequirement = await prisma.customRequirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomRequirementCreateManyArgs>(args?: SelectSubset<T, CustomRequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomRequirements and returns the data saved in the database.
     * @param {CustomRequirementCreateManyAndReturnArgs} args - Arguments to create many CustomRequirements.
     * @example
     * // Create many CustomRequirements
     * const customRequirement = await prisma.customRequirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomRequirements and only return the `id`
     * const customRequirementWithIdOnly = await prisma.customRequirement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomRequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomRequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomRequirementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomRequirement.
     * @param {CustomRequirementDeleteArgs} args - Arguments to delete one CustomRequirement.
     * @example
     * // Delete one CustomRequirement
     * const CustomRequirement = await prisma.customRequirement.delete({
     *   where: {
     *     // ... filter to delete one CustomRequirement
     *   }
     * })
     * 
     */
    delete<T extends CustomRequirementDeleteArgs>(args: SelectSubset<T, CustomRequirementDeleteArgs<ExtArgs>>): Prisma__CustomRequirementClient<$Result.GetResult<Prisma.$CustomRequirementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomRequirement.
     * @param {CustomRequirementUpdateArgs} args - Arguments to update one CustomRequirement.
     * @example
     * // Update one CustomRequirement
     * const customRequirement = await prisma.customRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomRequirementUpdateArgs>(args: SelectSubset<T, CustomRequirementUpdateArgs<ExtArgs>>): Prisma__CustomRequirementClient<$Result.GetResult<Prisma.$CustomRequirementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomRequirements.
     * @param {CustomRequirementDeleteManyArgs} args - Arguments to filter CustomRequirements to delete.
     * @example
     * // Delete a few CustomRequirements
     * const { count } = await prisma.customRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomRequirementDeleteManyArgs>(args?: SelectSubset<T, CustomRequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomRequirements
     * const customRequirement = await prisma.customRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomRequirementUpdateManyArgs>(args: SelectSubset<T, CustomRequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomRequirements and returns the data updated in the database.
     * @param {CustomRequirementUpdateManyAndReturnArgs} args - Arguments to update many CustomRequirements.
     * @example
     * // Update many CustomRequirements
     * const customRequirement = await prisma.customRequirement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomRequirements and only return the `id`
     * const customRequirementWithIdOnly = await prisma.customRequirement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomRequirementUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomRequirementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomRequirementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomRequirement.
     * @param {CustomRequirementUpsertArgs} args - Arguments to update or create a CustomRequirement.
     * @example
     * // Update or create a CustomRequirement
     * const customRequirement = await prisma.customRequirement.upsert({
     *   create: {
     *     // ... data to create a CustomRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomRequirement we want to update
     *   }
     * })
     */
    upsert<T extends CustomRequirementUpsertArgs>(args: SelectSubset<T, CustomRequirementUpsertArgs<ExtArgs>>): Prisma__CustomRequirementClient<$Result.GetResult<Prisma.$CustomRequirementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRequirementCountArgs} args - Arguments to filter CustomRequirements to count.
     * @example
     * // Count the number of CustomRequirements
     * const count = await prisma.customRequirement.count({
     *   where: {
     *     // ... the filter for the CustomRequirements we want to count
     *   }
     * })
    **/
    count<T extends CustomRequirementCountArgs>(
      args?: Subset<T, CustomRequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomRequirementAggregateArgs>(args: Subset<T, CustomRequirementAggregateArgs>): Prisma.PrismaPromise<GetCustomRequirementAggregateType<T>>

    /**
     * Group by CustomRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomRequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomRequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomRequirementGroupByArgs['orderBy'] }
        : { orderBy?: CustomRequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomRequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomRequirement model
   */
  readonly fields: CustomRequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomRequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomRequirement model
   */
  interface CustomRequirementFieldRefs {
    readonly id: FieldRef<"CustomRequirement", 'String'>
    readonly applicationId: FieldRef<"CustomRequirement", 'String'>
    readonly passengerId: FieldRef<"CustomRequirement", 'String'>
    readonly title: FieldRef<"CustomRequirement", 'String'>
    readonly createdAt: FieldRef<"CustomRequirement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomRequirement findUnique
   */
  export type CustomRequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRequirement
     */
    select?: CustomRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRequirement
     */
    omit?: CustomRequirementOmit<ExtArgs> | null
    /**
     * Filter, which CustomRequirement to fetch.
     */
    where: CustomRequirementWhereUniqueInput
  }

  /**
   * CustomRequirement findUniqueOrThrow
   */
  export type CustomRequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRequirement
     */
    select?: CustomRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRequirement
     */
    omit?: CustomRequirementOmit<ExtArgs> | null
    /**
     * Filter, which CustomRequirement to fetch.
     */
    where: CustomRequirementWhereUniqueInput
  }

  /**
   * CustomRequirement findFirst
   */
  export type CustomRequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRequirement
     */
    select?: CustomRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRequirement
     */
    omit?: CustomRequirementOmit<ExtArgs> | null
    /**
     * Filter, which CustomRequirement to fetch.
     */
    where?: CustomRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomRequirements to fetch.
     */
    orderBy?: CustomRequirementOrderByWithRelationInput | CustomRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomRequirements.
     */
    cursor?: CustomRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomRequirements.
     */
    distinct?: CustomRequirementScalarFieldEnum | CustomRequirementScalarFieldEnum[]
  }

  /**
   * CustomRequirement findFirstOrThrow
   */
  export type CustomRequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRequirement
     */
    select?: CustomRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRequirement
     */
    omit?: CustomRequirementOmit<ExtArgs> | null
    /**
     * Filter, which CustomRequirement to fetch.
     */
    where?: CustomRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomRequirements to fetch.
     */
    orderBy?: CustomRequirementOrderByWithRelationInput | CustomRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomRequirements.
     */
    cursor?: CustomRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomRequirements.
     */
    distinct?: CustomRequirementScalarFieldEnum | CustomRequirementScalarFieldEnum[]
  }

  /**
   * CustomRequirement findMany
   */
  export type CustomRequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRequirement
     */
    select?: CustomRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRequirement
     */
    omit?: CustomRequirementOmit<ExtArgs> | null
    /**
     * Filter, which CustomRequirements to fetch.
     */
    where?: CustomRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomRequirements to fetch.
     */
    orderBy?: CustomRequirementOrderByWithRelationInput | CustomRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomRequirements.
     */
    cursor?: CustomRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomRequirements.
     */
    skip?: number
    distinct?: CustomRequirementScalarFieldEnum | CustomRequirementScalarFieldEnum[]
  }

  /**
   * CustomRequirement create
   */
  export type CustomRequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRequirement
     */
    select?: CustomRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRequirement
     */
    omit?: CustomRequirementOmit<ExtArgs> | null
    /**
     * The data needed to create a CustomRequirement.
     */
    data: XOR<CustomRequirementCreateInput, CustomRequirementUncheckedCreateInput>
  }

  /**
   * CustomRequirement createMany
   */
  export type CustomRequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomRequirements.
     */
    data: CustomRequirementCreateManyInput | CustomRequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomRequirement createManyAndReturn
   */
  export type CustomRequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRequirement
     */
    select?: CustomRequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRequirement
     */
    omit?: CustomRequirementOmit<ExtArgs> | null
    /**
     * The data used to create many CustomRequirements.
     */
    data: CustomRequirementCreateManyInput | CustomRequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomRequirement update
   */
  export type CustomRequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRequirement
     */
    select?: CustomRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRequirement
     */
    omit?: CustomRequirementOmit<ExtArgs> | null
    /**
     * The data needed to update a CustomRequirement.
     */
    data: XOR<CustomRequirementUpdateInput, CustomRequirementUncheckedUpdateInput>
    /**
     * Choose, which CustomRequirement to update.
     */
    where: CustomRequirementWhereUniqueInput
  }

  /**
   * CustomRequirement updateMany
   */
  export type CustomRequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomRequirements.
     */
    data: XOR<CustomRequirementUpdateManyMutationInput, CustomRequirementUncheckedUpdateManyInput>
    /**
     * Filter which CustomRequirements to update
     */
    where?: CustomRequirementWhereInput
    /**
     * Limit how many CustomRequirements to update.
     */
    limit?: number
  }

  /**
   * CustomRequirement updateManyAndReturn
   */
  export type CustomRequirementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRequirement
     */
    select?: CustomRequirementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRequirement
     */
    omit?: CustomRequirementOmit<ExtArgs> | null
    /**
     * The data used to update CustomRequirements.
     */
    data: XOR<CustomRequirementUpdateManyMutationInput, CustomRequirementUncheckedUpdateManyInput>
    /**
     * Filter which CustomRequirements to update
     */
    where?: CustomRequirementWhereInput
    /**
     * Limit how many CustomRequirements to update.
     */
    limit?: number
  }

  /**
   * CustomRequirement upsert
   */
  export type CustomRequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRequirement
     */
    select?: CustomRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRequirement
     */
    omit?: CustomRequirementOmit<ExtArgs> | null
    /**
     * The filter to search for the CustomRequirement to update in case it exists.
     */
    where: CustomRequirementWhereUniqueInput
    /**
     * In case the CustomRequirement found by the `where` argument doesn't exist, create a new CustomRequirement with this data.
     */
    create: XOR<CustomRequirementCreateInput, CustomRequirementUncheckedCreateInput>
    /**
     * In case the CustomRequirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomRequirementUpdateInput, CustomRequirementUncheckedUpdateInput>
  }

  /**
   * CustomRequirement delete
   */
  export type CustomRequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRequirement
     */
    select?: CustomRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRequirement
     */
    omit?: CustomRequirementOmit<ExtArgs> | null
    /**
     * Filter which CustomRequirement to delete.
     */
    where: CustomRequirementWhereUniqueInput
  }

  /**
   * CustomRequirement deleteMany
   */
  export type CustomRequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomRequirements to delete
     */
    where?: CustomRequirementWhereInput
    /**
     * Limit how many CustomRequirements to delete.
     */
    limit?: number
  }

  /**
   * CustomRequirement without action
   */
  export type CustomRequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomRequirement
     */
    select?: CustomRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomRequirement
     */
    omit?: CustomRequirementOmit<ExtArgs> | null
  }


  /**
   * Model Destination
   */

  export type AggregateDestination = {
    _count: DestinationCountAggregateOutputType | null
    _min: DestinationMinAggregateOutputType | null
    _max: DestinationMaxAggregateOutputType | null
  }

  export type DestinationMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
  }

  export type DestinationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
  }

  export type DestinationCountAggregateOutputType = {
    id: number
    name: number
    code: number
    _all: number
  }


  export type DestinationMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type DestinationMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type DestinationCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    _all?: true
  }

  export type DestinationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Destination to aggregate.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Destinations
    **/
    _count?: true | DestinationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DestinationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DestinationMaxAggregateInputType
  }

  export type GetDestinationAggregateType<T extends DestinationAggregateArgs> = {
        [P in keyof T & keyof AggregateDestination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDestination[P]>
      : GetScalarType<T[P], AggregateDestination[P]>
  }




  export type DestinationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationWhereInput
    orderBy?: DestinationOrderByWithAggregationInput | DestinationOrderByWithAggregationInput[]
    by: DestinationScalarFieldEnum[] | DestinationScalarFieldEnum
    having?: DestinationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DestinationCountAggregateInputType | true
    _min?: DestinationMinAggregateInputType
    _max?: DestinationMaxAggregateInputType
  }

  export type DestinationGroupByOutputType = {
    id: string
    name: string
    code: string | null
    _count: DestinationCountAggregateOutputType | null
    _min: DestinationMinAggregateOutputType | null
    _max: DestinationMaxAggregateOutputType | null
  }

  type GetDestinationGroupByPayload<T extends DestinationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DestinationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DestinationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DestinationGroupByOutputType[P]>
            : GetScalarType<T[P], DestinationGroupByOutputType[P]>
        }
      >
    >


  export type DestinationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    Application?: boolean | Destination$ApplicationArgs<ExtArgs>
    VisaType?: boolean | Destination$VisaTypeArgs<ExtArgs>
    _count?: boolean | DestinationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["destination"]>

  export type DestinationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["destination"]>

  export type DestinationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["destination"]>

  export type DestinationSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
  }

  export type DestinationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code", ExtArgs["result"]["destination"]>
  export type DestinationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | Destination$ApplicationArgs<ExtArgs>
    VisaType?: boolean | Destination$VisaTypeArgs<ExtArgs>
    _count?: boolean | DestinationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DestinationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DestinationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DestinationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Destination"
    objects: {
      Application: Prisma.$ApplicationPayload<ExtArgs>[]
      VisaType: Prisma.$VisaTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
    }, ExtArgs["result"]["destination"]>
    composites: {}
  }

  type DestinationGetPayload<S extends boolean | null | undefined | DestinationDefaultArgs> = $Result.GetResult<Prisma.$DestinationPayload, S>

  type DestinationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DestinationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DestinationCountAggregateInputType | true
    }

  export interface DestinationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Destination'], meta: { name: 'Destination' } }
    /**
     * Find zero or one Destination that matches the filter.
     * @param {DestinationFindUniqueArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DestinationFindUniqueArgs>(args: SelectSubset<T, DestinationFindUniqueArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Destination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DestinationFindUniqueOrThrowArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DestinationFindUniqueOrThrowArgs>(args: SelectSubset<T, DestinationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Destination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindFirstArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DestinationFindFirstArgs>(args?: SelectSubset<T, DestinationFindFirstArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Destination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindFirstOrThrowArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DestinationFindFirstOrThrowArgs>(args?: SelectSubset<T, DestinationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Destinations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Destinations
     * const destinations = await prisma.destination.findMany()
     * 
     * // Get first 10 Destinations
     * const destinations = await prisma.destination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const destinationWithIdOnly = await prisma.destination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DestinationFindManyArgs>(args?: SelectSubset<T, DestinationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Destination.
     * @param {DestinationCreateArgs} args - Arguments to create a Destination.
     * @example
     * // Create one Destination
     * const Destination = await prisma.destination.create({
     *   data: {
     *     // ... data to create a Destination
     *   }
     * })
     * 
     */
    create<T extends DestinationCreateArgs>(args: SelectSubset<T, DestinationCreateArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Destinations.
     * @param {DestinationCreateManyArgs} args - Arguments to create many Destinations.
     * @example
     * // Create many Destinations
     * const destination = await prisma.destination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DestinationCreateManyArgs>(args?: SelectSubset<T, DestinationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Destinations and returns the data saved in the database.
     * @param {DestinationCreateManyAndReturnArgs} args - Arguments to create many Destinations.
     * @example
     * // Create many Destinations
     * const destination = await prisma.destination.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Destinations and only return the `id`
     * const destinationWithIdOnly = await prisma.destination.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DestinationCreateManyAndReturnArgs>(args?: SelectSubset<T, DestinationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Destination.
     * @param {DestinationDeleteArgs} args - Arguments to delete one Destination.
     * @example
     * // Delete one Destination
     * const Destination = await prisma.destination.delete({
     *   where: {
     *     // ... filter to delete one Destination
     *   }
     * })
     * 
     */
    delete<T extends DestinationDeleteArgs>(args: SelectSubset<T, DestinationDeleteArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Destination.
     * @param {DestinationUpdateArgs} args - Arguments to update one Destination.
     * @example
     * // Update one Destination
     * const destination = await prisma.destination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DestinationUpdateArgs>(args: SelectSubset<T, DestinationUpdateArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Destinations.
     * @param {DestinationDeleteManyArgs} args - Arguments to filter Destinations to delete.
     * @example
     * // Delete a few Destinations
     * const { count } = await prisma.destination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DestinationDeleteManyArgs>(args?: SelectSubset<T, DestinationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Destinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Destinations
     * const destination = await prisma.destination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DestinationUpdateManyArgs>(args: SelectSubset<T, DestinationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Destinations and returns the data updated in the database.
     * @param {DestinationUpdateManyAndReturnArgs} args - Arguments to update many Destinations.
     * @example
     * // Update many Destinations
     * const destination = await prisma.destination.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Destinations and only return the `id`
     * const destinationWithIdOnly = await prisma.destination.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DestinationUpdateManyAndReturnArgs>(args: SelectSubset<T, DestinationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Destination.
     * @param {DestinationUpsertArgs} args - Arguments to update or create a Destination.
     * @example
     * // Update or create a Destination
     * const destination = await prisma.destination.upsert({
     *   create: {
     *     // ... data to create a Destination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Destination we want to update
     *   }
     * })
     */
    upsert<T extends DestinationUpsertArgs>(args: SelectSubset<T, DestinationUpsertArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Destinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationCountArgs} args - Arguments to filter Destinations to count.
     * @example
     * // Count the number of Destinations
     * const count = await prisma.destination.count({
     *   where: {
     *     // ... the filter for the Destinations we want to count
     *   }
     * })
    **/
    count<T extends DestinationCountArgs>(
      args?: Subset<T, DestinationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DestinationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Destination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DestinationAggregateArgs>(args: Subset<T, DestinationAggregateArgs>): Prisma.PrismaPromise<GetDestinationAggregateType<T>>

    /**
     * Group by Destination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DestinationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DestinationGroupByArgs['orderBy'] }
        : { orderBy?: DestinationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DestinationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDestinationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Destination model
   */
  readonly fields: DestinationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Destination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DestinationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Application<T extends Destination$ApplicationArgs<ExtArgs> = {}>(args?: Subset<T, Destination$ApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    VisaType<T extends Destination$VisaTypeArgs<ExtArgs> = {}>(args?: Subset<T, Destination$VisaTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Destination model
   */
  interface DestinationFieldRefs {
    readonly id: FieldRef<"Destination", 'String'>
    readonly name: FieldRef<"Destination", 'String'>
    readonly code: FieldRef<"Destination", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Destination findUnique
   */
  export type DestinationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination findUniqueOrThrow
   */
  export type DestinationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination findFirst
   */
  export type DestinationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Destinations.
     */
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination findFirstOrThrow
   */
  export type DestinationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Destinations.
     */
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination findMany
   */
  export type DestinationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter, which Destinations to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination create
   */
  export type DestinationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * The data needed to create a Destination.
     */
    data: XOR<DestinationCreateInput, DestinationUncheckedCreateInput>
  }

  /**
   * Destination createMany
   */
  export type DestinationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Destinations.
     */
    data: DestinationCreateManyInput | DestinationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Destination createManyAndReturn
   */
  export type DestinationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * The data used to create many Destinations.
     */
    data: DestinationCreateManyInput | DestinationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Destination update
   */
  export type DestinationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * The data needed to update a Destination.
     */
    data: XOR<DestinationUpdateInput, DestinationUncheckedUpdateInput>
    /**
     * Choose, which Destination to update.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination updateMany
   */
  export type DestinationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Destinations.
     */
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyInput>
    /**
     * Filter which Destinations to update
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to update.
     */
    limit?: number
  }

  /**
   * Destination updateManyAndReturn
   */
  export type DestinationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * The data used to update Destinations.
     */
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyInput>
    /**
     * Filter which Destinations to update
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to update.
     */
    limit?: number
  }

  /**
   * Destination upsert
   */
  export type DestinationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * The filter to search for the Destination to update in case it exists.
     */
    where: DestinationWhereUniqueInput
    /**
     * In case the Destination found by the `where` argument doesn't exist, create a new Destination with this data.
     */
    create: XOR<DestinationCreateInput, DestinationUncheckedCreateInput>
    /**
     * In case the Destination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DestinationUpdateInput, DestinationUncheckedUpdateInput>
  }

  /**
   * Destination delete
   */
  export type DestinationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
    /**
     * Filter which Destination to delete.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination deleteMany
   */
  export type DestinationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Destinations to delete
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to delete.
     */
    limit?: number
  }

  /**
   * Destination.Application
   */
  export type Destination$ApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Destination.VisaType
   */
  export type Destination$VisaTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeInclude<ExtArgs> | null
    where?: VisaTypeWhereInput
    orderBy?: VisaTypeOrderByWithRelationInput | VisaTypeOrderByWithRelationInput[]
    cursor?: VisaTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisaTypeScalarFieldEnum | VisaTypeScalarFieldEnum[]
  }

  /**
   * Destination without action
   */
  export type DestinationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DestinationInclude<ExtArgs> | null
  }


  /**
   * Model DocumentMapping
   */

  export type AggregateDocumentMapping = {
    _count: DocumentMappingCountAggregateOutputType | null
    _min: DocumentMappingMinAggregateOutputType | null
    _max: DocumentMappingMaxAggregateOutputType | null
  }

  export type DocumentMappingMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    mappedTo: string | null
    isInvalid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMappingMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    mappedTo: string | null
    isInvalid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMappingCountAggregateOutputType = {
    id: number
    documentId: number
    mappedTo: number
    isInvalid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentMappingMinAggregateInputType = {
    id?: true
    documentId?: true
    mappedTo?: true
    isInvalid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMappingMaxAggregateInputType = {
    id?: true
    documentId?: true
    mappedTo?: true
    isInvalid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMappingCountAggregateInputType = {
    id?: true
    documentId?: true
    mappedTo?: true
    isInvalid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentMapping to aggregate.
     */
    where?: DocumentMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentMappings to fetch.
     */
    orderBy?: DocumentMappingOrderByWithRelationInput | DocumentMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentMappings
    **/
    _count?: true | DocumentMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMappingMaxAggregateInputType
  }

  export type GetDocumentMappingAggregateType<T extends DocumentMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentMapping[P]>
      : GetScalarType<T[P], AggregateDocumentMapping[P]>
  }




  export type DocumentMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentMappingWhereInput
    orderBy?: DocumentMappingOrderByWithAggregationInput | DocumentMappingOrderByWithAggregationInput[]
    by: DocumentMappingScalarFieldEnum[] | DocumentMappingScalarFieldEnum
    having?: DocumentMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentMappingCountAggregateInputType | true
    _min?: DocumentMappingMinAggregateInputType
    _max?: DocumentMappingMaxAggregateInputType
  }

  export type DocumentMappingGroupByOutputType = {
    id: string
    documentId: string
    mappedTo: string | null
    isInvalid: boolean
    createdAt: Date
    updatedAt: Date
    _count: DocumentMappingCountAggregateOutputType | null
    _min: DocumentMappingMinAggregateOutputType | null
    _max: DocumentMappingMaxAggregateOutputType | null
  }

  type GetDocumentMappingGroupByPayload<T extends DocumentMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentMappingGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentMappingGroupByOutputType[P]>
        }
      >
    >


  export type DocumentMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    mappedTo?: boolean
    isInvalid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ApplicationDocument?: boolean | ApplicationDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentMapping"]>

  export type DocumentMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    mappedTo?: boolean
    isInvalid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ApplicationDocument?: boolean | ApplicationDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentMapping"]>

  export type DocumentMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    mappedTo?: boolean
    isInvalid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ApplicationDocument?: boolean | ApplicationDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentMapping"]>

  export type DocumentMappingSelectScalar = {
    id?: boolean
    documentId?: boolean
    mappedTo?: boolean
    isInvalid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "mappedTo" | "isInvalid" | "createdAt" | "updatedAt", ExtArgs["result"]["documentMapping"]>
  export type DocumentMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ApplicationDocument?: boolean | ApplicationDocumentDefaultArgs<ExtArgs>
  }
  export type DocumentMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ApplicationDocument?: boolean | ApplicationDocumentDefaultArgs<ExtArgs>
  }
  export type DocumentMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ApplicationDocument?: boolean | ApplicationDocumentDefaultArgs<ExtArgs>
  }

  export type $DocumentMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentMapping"
    objects: {
      ApplicationDocument: Prisma.$ApplicationDocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      mappedTo: string | null
      isInvalid: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentMapping"]>
    composites: {}
  }

  type DocumentMappingGetPayload<S extends boolean | null | undefined | DocumentMappingDefaultArgs> = $Result.GetResult<Prisma.$DocumentMappingPayload, S>

  type DocumentMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentMappingCountAggregateInputType | true
    }

  export interface DocumentMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentMapping'], meta: { name: 'DocumentMapping' } }
    /**
     * Find zero or one DocumentMapping that matches the filter.
     * @param {DocumentMappingFindUniqueArgs} args - Arguments to find a DocumentMapping
     * @example
     * // Get one DocumentMapping
     * const documentMapping = await prisma.documentMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentMappingFindUniqueArgs>(args: SelectSubset<T, DocumentMappingFindUniqueArgs<ExtArgs>>): Prisma__DocumentMappingClient<$Result.GetResult<Prisma.$DocumentMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentMappingFindUniqueOrThrowArgs} args - Arguments to find a DocumentMapping
     * @example
     * // Get one DocumentMapping
     * const documentMapping = await prisma.documentMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentMappingClient<$Result.GetResult<Prisma.$DocumentMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMappingFindFirstArgs} args - Arguments to find a DocumentMapping
     * @example
     * // Get one DocumentMapping
     * const documentMapping = await prisma.documentMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentMappingFindFirstArgs>(args?: SelectSubset<T, DocumentMappingFindFirstArgs<ExtArgs>>): Prisma__DocumentMappingClient<$Result.GetResult<Prisma.$DocumentMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMappingFindFirstOrThrowArgs} args - Arguments to find a DocumentMapping
     * @example
     * // Get one DocumentMapping
     * const documentMapping = await prisma.documentMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentMappingClient<$Result.GetResult<Prisma.$DocumentMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentMappings
     * const documentMappings = await prisma.documentMapping.findMany()
     * 
     * // Get first 10 DocumentMappings
     * const documentMappings = await prisma.documentMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentMappingWithIdOnly = await prisma.documentMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentMappingFindManyArgs>(args?: SelectSubset<T, DocumentMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentMapping.
     * @param {DocumentMappingCreateArgs} args - Arguments to create a DocumentMapping.
     * @example
     * // Create one DocumentMapping
     * const DocumentMapping = await prisma.documentMapping.create({
     *   data: {
     *     // ... data to create a DocumentMapping
     *   }
     * })
     * 
     */
    create<T extends DocumentMappingCreateArgs>(args: SelectSubset<T, DocumentMappingCreateArgs<ExtArgs>>): Prisma__DocumentMappingClient<$Result.GetResult<Prisma.$DocumentMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentMappings.
     * @param {DocumentMappingCreateManyArgs} args - Arguments to create many DocumentMappings.
     * @example
     * // Create many DocumentMappings
     * const documentMapping = await prisma.documentMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentMappingCreateManyArgs>(args?: SelectSubset<T, DocumentMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentMappings and returns the data saved in the database.
     * @param {DocumentMappingCreateManyAndReturnArgs} args - Arguments to create many DocumentMappings.
     * @example
     * // Create many DocumentMappings
     * const documentMapping = await prisma.documentMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentMappings and only return the `id`
     * const documentMappingWithIdOnly = await prisma.documentMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentMapping.
     * @param {DocumentMappingDeleteArgs} args - Arguments to delete one DocumentMapping.
     * @example
     * // Delete one DocumentMapping
     * const DocumentMapping = await prisma.documentMapping.delete({
     *   where: {
     *     // ... filter to delete one DocumentMapping
     *   }
     * })
     * 
     */
    delete<T extends DocumentMappingDeleteArgs>(args: SelectSubset<T, DocumentMappingDeleteArgs<ExtArgs>>): Prisma__DocumentMappingClient<$Result.GetResult<Prisma.$DocumentMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentMapping.
     * @param {DocumentMappingUpdateArgs} args - Arguments to update one DocumentMapping.
     * @example
     * // Update one DocumentMapping
     * const documentMapping = await prisma.documentMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentMappingUpdateArgs>(args: SelectSubset<T, DocumentMappingUpdateArgs<ExtArgs>>): Prisma__DocumentMappingClient<$Result.GetResult<Prisma.$DocumentMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentMappings.
     * @param {DocumentMappingDeleteManyArgs} args - Arguments to filter DocumentMappings to delete.
     * @example
     * // Delete a few DocumentMappings
     * const { count } = await prisma.documentMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentMappingDeleteManyArgs>(args?: SelectSubset<T, DocumentMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentMappings
     * const documentMapping = await prisma.documentMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentMappingUpdateManyArgs>(args: SelectSubset<T, DocumentMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentMappings and returns the data updated in the database.
     * @param {DocumentMappingUpdateManyAndReturnArgs} args - Arguments to update many DocumentMappings.
     * @example
     * // Update many DocumentMappings
     * const documentMapping = await prisma.documentMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentMappings and only return the `id`
     * const documentMappingWithIdOnly = await prisma.documentMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentMapping.
     * @param {DocumentMappingUpsertArgs} args - Arguments to update or create a DocumentMapping.
     * @example
     * // Update or create a DocumentMapping
     * const documentMapping = await prisma.documentMapping.upsert({
     *   create: {
     *     // ... data to create a DocumentMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentMapping we want to update
     *   }
     * })
     */
    upsert<T extends DocumentMappingUpsertArgs>(args: SelectSubset<T, DocumentMappingUpsertArgs<ExtArgs>>): Prisma__DocumentMappingClient<$Result.GetResult<Prisma.$DocumentMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMappingCountArgs} args - Arguments to filter DocumentMappings to count.
     * @example
     * // Count the number of DocumentMappings
     * const count = await prisma.documentMapping.count({
     *   where: {
     *     // ... the filter for the DocumentMappings we want to count
     *   }
     * })
    **/
    count<T extends DocumentMappingCountArgs>(
      args?: Subset<T, DocumentMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentMappingAggregateArgs>(args: Subset<T, DocumentMappingAggregateArgs>): Prisma.PrismaPromise<GetDocumentMappingAggregateType<T>>

    /**
     * Group by DocumentMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentMappingGroupByArgs['orderBy'] }
        : { orderBy?: DocumentMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentMapping model
   */
  readonly fields: DocumentMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ApplicationDocument<T extends ApplicationDocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDocumentDefaultArgs<ExtArgs>>): Prisma__ApplicationDocumentClient<$Result.GetResult<Prisma.$ApplicationDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentMapping model
   */
  interface DocumentMappingFieldRefs {
    readonly id: FieldRef<"DocumentMapping", 'String'>
    readonly documentId: FieldRef<"DocumentMapping", 'String'>
    readonly mappedTo: FieldRef<"DocumentMapping", 'String'>
    readonly isInvalid: FieldRef<"DocumentMapping", 'Boolean'>
    readonly createdAt: FieldRef<"DocumentMapping", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentMapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentMapping findUnique
   */
  export type DocumentMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingInclude<ExtArgs> | null
    /**
     * Filter, which DocumentMapping to fetch.
     */
    where: DocumentMappingWhereUniqueInput
  }

  /**
   * DocumentMapping findUniqueOrThrow
   */
  export type DocumentMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingInclude<ExtArgs> | null
    /**
     * Filter, which DocumentMapping to fetch.
     */
    where: DocumentMappingWhereUniqueInput
  }

  /**
   * DocumentMapping findFirst
   */
  export type DocumentMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingInclude<ExtArgs> | null
    /**
     * Filter, which DocumentMapping to fetch.
     */
    where?: DocumentMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentMappings to fetch.
     */
    orderBy?: DocumentMappingOrderByWithRelationInput | DocumentMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentMappings.
     */
    cursor?: DocumentMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentMappings.
     */
    distinct?: DocumentMappingScalarFieldEnum | DocumentMappingScalarFieldEnum[]
  }

  /**
   * DocumentMapping findFirstOrThrow
   */
  export type DocumentMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingInclude<ExtArgs> | null
    /**
     * Filter, which DocumentMapping to fetch.
     */
    where?: DocumentMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentMappings to fetch.
     */
    orderBy?: DocumentMappingOrderByWithRelationInput | DocumentMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentMappings.
     */
    cursor?: DocumentMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentMappings.
     */
    distinct?: DocumentMappingScalarFieldEnum | DocumentMappingScalarFieldEnum[]
  }

  /**
   * DocumentMapping findMany
   */
  export type DocumentMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingInclude<ExtArgs> | null
    /**
     * Filter, which DocumentMappings to fetch.
     */
    where?: DocumentMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentMappings to fetch.
     */
    orderBy?: DocumentMappingOrderByWithRelationInput | DocumentMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentMappings.
     */
    cursor?: DocumentMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentMappings.
     */
    skip?: number
    distinct?: DocumentMappingScalarFieldEnum | DocumentMappingScalarFieldEnum[]
  }

  /**
   * DocumentMapping create
   */
  export type DocumentMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentMapping.
     */
    data: XOR<DocumentMappingCreateInput, DocumentMappingUncheckedCreateInput>
  }

  /**
   * DocumentMapping createMany
   */
  export type DocumentMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentMappings.
     */
    data: DocumentMappingCreateManyInput | DocumentMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentMapping createManyAndReturn
   */
  export type DocumentMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentMappings.
     */
    data: DocumentMappingCreateManyInput | DocumentMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentMapping update
   */
  export type DocumentMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentMapping.
     */
    data: XOR<DocumentMappingUpdateInput, DocumentMappingUncheckedUpdateInput>
    /**
     * Choose, which DocumentMapping to update.
     */
    where: DocumentMappingWhereUniqueInput
  }

  /**
   * DocumentMapping updateMany
   */
  export type DocumentMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentMappings.
     */
    data: XOR<DocumentMappingUpdateManyMutationInput, DocumentMappingUncheckedUpdateManyInput>
    /**
     * Filter which DocumentMappings to update
     */
    where?: DocumentMappingWhereInput
    /**
     * Limit how many DocumentMappings to update.
     */
    limit?: number
  }

  /**
   * DocumentMapping updateManyAndReturn
   */
  export type DocumentMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * The data used to update DocumentMappings.
     */
    data: XOR<DocumentMappingUpdateManyMutationInput, DocumentMappingUncheckedUpdateManyInput>
    /**
     * Filter which DocumentMappings to update
     */
    where?: DocumentMappingWhereInput
    /**
     * Limit how many DocumentMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentMapping upsert
   */
  export type DocumentMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentMapping to update in case it exists.
     */
    where: DocumentMappingWhereUniqueInput
    /**
     * In case the DocumentMapping found by the `where` argument doesn't exist, create a new DocumentMapping with this data.
     */
    create: XOR<DocumentMappingCreateInput, DocumentMappingUncheckedCreateInput>
    /**
     * In case the DocumentMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentMappingUpdateInput, DocumentMappingUncheckedUpdateInput>
  }

  /**
   * DocumentMapping delete
   */
  export type DocumentMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingInclude<ExtArgs> | null
    /**
     * Filter which DocumentMapping to delete.
     */
    where: DocumentMappingWhereUniqueInput
  }

  /**
   * DocumentMapping deleteMany
   */
  export type DocumentMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentMappings to delete
     */
    where?: DocumentMappingWhereInput
    /**
     * Limit how many DocumentMappings to delete.
     */
    limit?: number
  }

  /**
   * DocumentMapping without action
   */
  export type DocumentMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMapping
     */
    select?: DocumentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentMapping
     */
    omit?: DocumentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentMappingInclude<ExtArgs> | null
  }


  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    body: string | null
    websiteCreatedAt: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    body: string | null
    websiteCreatedAt: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    body: number
    websiteCreatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTemplateMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    websiteCreatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    websiteCreatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    websiteCreatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    name: string
    subject: string
    body: string
    websiteCreatedAt: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    websiteCreatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    websiteCreatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    websiteCreatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    websiteCreatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subject" | "body" | "websiteCreatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["emailTemplate"]>

  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      body: string
      websiteCreatedAt: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }

  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTemplateFindUniqueArgs>(args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTemplateFindFirstArgs>(args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTemplateFindManyArgs>(args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
     */
    create<T extends EmailTemplateCreateArgs>(args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTemplateCreateManyArgs>(args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends EmailTemplateDeleteArgs>(args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTemplateUpdateArgs>(args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTemplateDeleteManyArgs>(args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTemplateUpdateManyArgs>(args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates and returns the data updated in the database.
     * @param {EmailTemplateUpdateManyAndReturnArgs} args - Arguments to update many EmailTemplates.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EmailTemplateUpsertArgs>(args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTemplate model
   */
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly body: FieldRef<"EmailTemplate", 'String'>
    readonly websiteCreatedAt: FieldRef<"EmailTemplate", 'String'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate updateManyAndReturn
   */
  export type EmailTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to delete.
     */
    limit?: number
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
  }


  /**
   * Model EmailThread
   */

  export type AggregateEmailThread = {
    _count: EmailThreadCountAggregateOutputType | null
    _min: EmailThreadMinAggregateOutputType | null
    _max: EmailThreadMaxAggregateOutputType | null
  }

  export type EmailThreadMinAggregateOutputType = {
    id: string | null
    caseId: string | null
    messageId: string | null
    fromEmail: string | null
    toEmail: string | null
    subject: string | null
    body: string | null
    timestamp: Date | null
    direction: string | null
    cc: string | null
    bcc: string | null
  }

  export type EmailThreadMaxAggregateOutputType = {
    id: string | null
    caseId: string | null
    messageId: string | null
    fromEmail: string | null
    toEmail: string | null
    subject: string | null
    body: string | null
    timestamp: Date | null
    direction: string | null
    cc: string | null
    bcc: string | null
  }

  export type EmailThreadCountAggregateOutputType = {
    id: number
    caseId: number
    messageId: number
    fromEmail: number
    toEmail: number
    subject: number
    body: number
    timestamp: number
    direction: number
    cc: number
    bcc: number
    _all: number
  }


  export type EmailThreadMinAggregateInputType = {
    id?: true
    caseId?: true
    messageId?: true
    fromEmail?: true
    toEmail?: true
    subject?: true
    body?: true
    timestamp?: true
    direction?: true
    cc?: true
    bcc?: true
  }

  export type EmailThreadMaxAggregateInputType = {
    id?: true
    caseId?: true
    messageId?: true
    fromEmail?: true
    toEmail?: true
    subject?: true
    body?: true
    timestamp?: true
    direction?: true
    cc?: true
    bcc?: true
  }

  export type EmailThreadCountAggregateInputType = {
    id?: true
    caseId?: true
    messageId?: true
    fromEmail?: true
    toEmail?: true
    subject?: true
    body?: true
    timestamp?: true
    direction?: true
    cc?: true
    bcc?: true
    _all?: true
  }

  export type EmailThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailThread to aggregate.
     */
    where?: EmailThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailThreads to fetch.
     */
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailThreads
    **/
    _count?: true | EmailThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailThreadMaxAggregateInputType
  }

  export type GetEmailThreadAggregateType<T extends EmailThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailThread[P]>
      : GetScalarType<T[P], AggregateEmailThread[P]>
  }




  export type EmailThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailThreadWhereInput
    orderBy?: EmailThreadOrderByWithAggregationInput | EmailThreadOrderByWithAggregationInput[]
    by: EmailThreadScalarFieldEnum[] | EmailThreadScalarFieldEnum
    having?: EmailThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailThreadCountAggregateInputType | true
    _min?: EmailThreadMinAggregateInputType
    _max?: EmailThreadMaxAggregateInputType
  }

  export type EmailThreadGroupByOutputType = {
    id: string
    caseId: string
    messageId: string
    fromEmail: string
    toEmail: string
    subject: string
    body: string
    timestamp: Date
    direction: string
    cc: string | null
    bcc: string | null
    _count: EmailThreadCountAggregateOutputType | null
    _min: EmailThreadMinAggregateOutputType | null
    _max: EmailThreadMaxAggregateOutputType | null
  }

  type GetEmailThreadGroupByPayload<T extends EmailThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailThreadGroupByOutputType[P]>
            : GetScalarType<T[P], EmailThreadGroupByOutputType[P]>
        }
      >
    >


  export type EmailThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    messageId?: boolean
    fromEmail?: boolean
    toEmail?: boolean
    subject?: boolean
    body?: boolean
    timestamp?: boolean
    direction?: boolean
    cc?: boolean
    bcc?: boolean
    Attachment?: boolean | EmailThread$AttachmentArgs<ExtArgs>
    Case?: boolean | CaseDefaultArgs<ExtArgs>
    _count?: boolean | EmailThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailThread"]>

  export type EmailThreadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    messageId?: boolean
    fromEmail?: boolean
    toEmail?: boolean
    subject?: boolean
    body?: boolean
    timestamp?: boolean
    direction?: boolean
    cc?: boolean
    bcc?: boolean
    Case?: boolean | CaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailThread"]>

  export type EmailThreadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    messageId?: boolean
    fromEmail?: boolean
    toEmail?: boolean
    subject?: boolean
    body?: boolean
    timestamp?: boolean
    direction?: boolean
    cc?: boolean
    bcc?: boolean
    Case?: boolean | CaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailThread"]>

  export type EmailThreadSelectScalar = {
    id?: boolean
    caseId?: boolean
    messageId?: boolean
    fromEmail?: boolean
    toEmail?: boolean
    subject?: boolean
    body?: boolean
    timestamp?: boolean
    direction?: boolean
    cc?: boolean
    bcc?: boolean
  }

  export type EmailThreadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseId" | "messageId" | "fromEmail" | "toEmail" | "subject" | "body" | "timestamp" | "direction" | "cc" | "bcc", ExtArgs["result"]["emailThread"]>
  export type EmailThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Attachment?: boolean | EmailThread$AttachmentArgs<ExtArgs>
    Case?: boolean | CaseDefaultArgs<ExtArgs>
    _count?: boolean | EmailThreadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailThreadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Case?: boolean | CaseDefaultArgs<ExtArgs>
  }
  export type EmailThreadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Case?: boolean | CaseDefaultArgs<ExtArgs>
  }

  export type $EmailThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailThread"
    objects: {
      Attachment: Prisma.$AttachmentPayload<ExtArgs>[]
      Case: Prisma.$CasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseId: string
      messageId: string
      fromEmail: string
      toEmail: string
      subject: string
      body: string
      timestamp: Date
      direction: string
      cc: string | null
      bcc: string | null
    }, ExtArgs["result"]["emailThread"]>
    composites: {}
  }

  type EmailThreadGetPayload<S extends boolean | null | undefined | EmailThreadDefaultArgs> = $Result.GetResult<Prisma.$EmailThreadPayload, S>

  type EmailThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailThreadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailThreadCountAggregateInputType | true
    }

  export interface EmailThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailThread'], meta: { name: 'EmailThread' } }
    /**
     * Find zero or one EmailThread that matches the filter.
     * @param {EmailThreadFindUniqueArgs} args - Arguments to find a EmailThread
     * @example
     * // Get one EmailThread
     * const emailThread = await prisma.emailThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailThreadFindUniqueArgs>(args: SelectSubset<T, EmailThreadFindUniqueArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailThread that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailThreadFindUniqueOrThrowArgs} args - Arguments to find a EmailThread
     * @example
     * // Get one EmailThread
     * const emailThread = await prisma.emailThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailThreadFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailThreadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadFindFirstArgs} args - Arguments to find a EmailThread
     * @example
     * // Get one EmailThread
     * const emailThread = await prisma.emailThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailThreadFindFirstArgs>(args?: SelectSubset<T, EmailThreadFindFirstArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailThread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadFindFirstOrThrowArgs} args - Arguments to find a EmailThread
     * @example
     * // Get one EmailThread
     * const emailThread = await prisma.emailThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailThreadFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailThreadFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailThreads
     * const emailThreads = await prisma.emailThread.findMany()
     * 
     * // Get first 10 EmailThreads
     * const emailThreads = await prisma.emailThread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailThreadWithIdOnly = await prisma.emailThread.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailThreadFindManyArgs>(args?: SelectSubset<T, EmailThreadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailThread.
     * @param {EmailThreadCreateArgs} args - Arguments to create a EmailThread.
     * @example
     * // Create one EmailThread
     * const EmailThread = await prisma.emailThread.create({
     *   data: {
     *     // ... data to create a EmailThread
     *   }
     * })
     * 
     */
    create<T extends EmailThreadCreateArgs>(args: SelectSubset<T, EmailThreadCreateArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailThreads.
     * @param {EmailThreadCreateManyArgs} args - Arguments to create many EmailThreads.
     * @example
     * // Create many EmailThreads
     * const emailThread = await prisma.emailThread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailThreadCreateManyArgs>(args?: SelectSubset<T, EmailThreadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailThreads and returns the data saved in the database.
     * @param {EmailThreadCreateManyAndReturnArgs} args - Arguments to create many EmailThreads.
     * @example
     * // Create many EmailThreads
     * const emailThread = await prisma.emailThread.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailThreads and only return the `id`
     * const emailThreadWithIdOnly = await prisma.emailThread.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailThreadCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailThreadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailThread.
     * @param {EmailThreadDeleteArgs} args - Arguments to delete one EmailThread.
     * @example
     * // Delete one EmailThread
     * const EmailThread = await prisma.emailThread.delete({
     *   where: {
     *     // ... filter to delete one EmailThread
     *   }
     * })
     * 
     */
    delete<T extends EmailThreadDeleteArgs>(args: SelectSubset<T, EmailThreadDeleteArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailThread.
     * @param {EmailThreadUpdateArgs} args - Arguments to update one EmailThread.
     * @example
     * // Update one EmailThread
     * const emailThread = await prisma.emailThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailThreadUpdateArgs>(args: SelectSubset<T, EmailThreadUpdateArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailThreads.
     * @param {EmailThreadDeleteManyArgs} args - Arguments to filter EmailThreads to delete.
     * @example
     * // Delete a few EmailThreads
     * const { count } = await prisma.emailThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailThreadDeleteManyArgs>(args?: SelectSubset<T, EmailThreadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailThreads
     * const emailThread = await prisma.emailThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailThreadUpdateManyArgs>(args: SelectSubset<T, EmailThreadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailThreads and returns the data updated in the database.
     * @param {EmailThreadUpdateManyAndReturnArgs} args - Arguments to update many EmailThreads.
     * @example
     * // Update many EmailThreads
     * const emailThread = await prisma.emailThread.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailThreads and only return the `id`
     * const emailThreadWithIdOnly = await prisma.emailThread.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailThreadUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailThreadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailThread.
     * @param {EmailThreadUpsertArgs} args - Arguments to update or create a EmailThread.
     * @example
     * // Update or create a EmailThread
     * const emailThread = await prisma.emailThread.upsert({
     *   create: {
     *     // ... data to create a EmailThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailThread we want to update
     *   }
     * })
     */
    upsert<T extends EmailThreadUpsertArgs>(args: SelectSubset<T, EmailThreadUpsertArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadCountArgs} args - Arguments to filter EmailThreads to count.
     * @example
     * // Count the number of EmailThreads
     * const count = await prisma.emailThread.count({
     *   where: {
     *     // ... the filter for the EmailThreads we want to count
     *   }
     * })
    **/
    count<T extends EmailThreadCountArgs>(
      args?: Subset<T, EmailThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailThreadAggregateArgs>(args: Subset<T, EmailThreadAggregateArgs>): Prisma.PrismaPromise<GetEmailThreadAggregateType<T>>

    /**
     * Group by EmailThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailThreadGroupByArgs['orderBy'] }
        : { orderBy?: EmailThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailThread model
   */
  readonly fields: EmailThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Attachment<T extends EmailThread$AttachmentArgs<ExtArgs> = {}>(args?: Subset<T, EmailThread$AttachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Case<T extends CaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaseDefaultArgs<ExtArgs>>): Prisma__CaseClient<$Result.GetResult<Prisma.$CasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailThread model
   */
  interface EmailThreadFieldRefs {
    readonly id: FieldRef<"EmailThread", 'String'>
    readonly caseId: FieldRef<"EmailThread", 'String'>
    readonly messageId: FieldRef<"EmailThread", 'String'>
    readonly fromEmail: FieldRef<"EmailThread", 'String'>
    readonly toEmail: FieldRef<"EmailThread", 'String'>
    readonly subject: FieldRef<"EmailThread", 'String'>
    readonly body: FieldRef<"EmailThread", 'String'>
    readonly timestamp: FieldRef<"EmailThread", 'DateTime'>
    readonly direction: FieldRef<"EmailThread", 'String'>
    readonly cc: FieldRef<"EmailThread", 'String'>
    readonly bcc: FieldRef<"EmailThread", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailThread findUnique
   */
  export type EmailThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThread to fetch.
     */
    where: EmailThreadWhereUniqueInput
  }

  /**
   * EmailThread findUniqueOrThrow
   */
  export type EmailThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThread to fetch.
     */
    where: EmailThreadWhereUniqueInput
  }

  /**
   * EmailThread findFirst
   */
  export type EmailThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThread to fetch.
     */
    where?: EmailThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailThreads to fetch.
     */
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailThreads.
     */
    cursor?: EmailThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailThreads.
     */
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }

  /**
   * EmailThread findFirstOrThrow
   */
  export type EmailThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThread to fetch.
     */
    where?: EmailThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailThreads to fetch.
     */
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailThreads.
     */
    cursor?: EmailThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailThreads.
     */
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }

  /**
   * EmailThread findMany
   */
  export type EmailThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThreads to fetch.
     */
    where?: EmailThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailThreads to fetch.
     */
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailThreads.
     */
    cursor?: EmailThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailThreads.
     */
    skip?: number
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }

  /**
   * EmailThread create
   */
  export type EmailThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailThread.
     */
    data: XOR<EmailThreadCreateInput, EmailThreadUncheckedCreateInput>
  }

  /**
   * EmailThread createMany
   */
  export type EmailThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailThreads.
     */
    data: EmailThreadCreateManyInput | EmailThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailThread createManyAndReturn
   */
  export type EmailThreadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * The data used to create many EmailThreads.
     */
    data: EmailThreadCreateManyInput | EmailThreadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailThread update
   */
  export type EmailThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailThread.
     */
    data: XOR<EmailThreadUpdateInput, EmailThreadUncheckedUpdateInput>
    /**
     * Choose, which EmailThread to update.
     */
    where: EmailThreadWhereUniqueInput
  }

  /**
   * EmailThread updateMany
   */
  export type EmailThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailThreads.
     */
    data: XOR<EmailThreadUpdateManyMutationInput, EmailThreadUncheckedUpdateManyInput>
    /**
     * Filter which EmailThreads to update
     */
    where?: EmailThreadWhereInput
    /**
     * Limit how many EmailThreads to update.
     */
    limit?: number
  }

  /**
   * EmailThread updateManyAndReturn
   */
  export type EmailThreadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * The data used to update EmailThreads.
     */
    data: XOR<EmailThreadUpdateManyMutationInput, EmailThreadUncheckedUpdateManyInput>
    /**
     * Filter which EmailThreads to update
     */
    where?: EmailThreadWhereInput
    /**
     * Limit how many EmailThreads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailThread upsert
   */
  export type EmailThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailThread to update in case it exists.
     */
    where: EmailThreadWhereUniqueInput
    /**
     * In case the EmailThread found by the `where` argument doesn't exist, create a new EmailThread with this data.
     */
    create: XOR<EmailThreadCreateInput, EmailThreadUncheckedCreateInput>
    /**
     * In case the EmailThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailThreadUpdateInput, EmailThreadUncheckedUpdateInput>
  }

  /**
   * EmailThread delete
   */
  export type EmailThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter which EmailThread to delete.
     */
    where: EmailThreadWhereUniqueInput
  }

  /**
   * EmailThread deleteMany
   */
  export type EmailThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailThreads to delete
     */
    where?: EmailThreadWhereInput
    /**
     * Limit how many EmailThreads to delete.
     */
    limit?: number
  }

  /**
   * EmailThread.Attachment
   */
  export type EmailThread$AttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * EmailThread without action
   */
  export type EmailThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailThread
     */
    omit?: EmailThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailThreadInclude<ExtArgs> | null
  }


  /**
   * Model Passenger
   */

  export type AggregatePassenger = {
    _count: PassengerCountAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  export type PassengerMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    createdAt: Date | null
    name: string | null
    passportNumber: string | null
    updatedAt: Date | null
    dateOfBirth: Date | null
    fullName: string | null
    gender: string | null
    nationality: string | null
    passportId: string | null
    status: string | null
  }

  export type PassengerMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    createdAt: Date | null
    name: string | null
    passportNumber: string | null
    updatedAt: Date | null
    dateOfBirth: Date | null
    fullName: string | null
    gender: string | null
    nationality: string | null
    passportId: string | null
    status: string | null
  }

  export type PassengerCountAggregateOutputType = {
    id: number
    applicationId: number
    createdAt: number
    name: number
    passportNumber: number
    updatedAt: number
    dateOfBirth: number
    fullName: number
    gender: number
    nationality: number
    passportId: number
    status: number
    _all: number
  }


  export type PassengerMinAggregateInputType = {
    id?: true
    applicationId?: true
    createdAt?: true
    name?: true
    passportNumber?: true
    updatedAt?: true
    dateOfBirth?: true
    fullName?: true
    gender?: true
    nationality?: true
    passportId?: true
    status?: true
  }

  export type PassengerMaxAggregateInputType = {
    id?: true
    applicationId?: true
    createdAt?: true
    name?: true
    passportNumber?: true
    updatedAt?: true
    dateOfBirth?: true
    fullName?: true
    gender?: true
    nationality?: true
    passportId?: true
    status?: true
  }

  export type PassengerCountAggregateInputType = {
    id?: true
    applicationId?: true
    createdAt?: true
    name?: true
    passportNumber?: true
    updatedAt?: true
    dateOfBirth?: true
    fullName?: true
    gender?: true
    nationality?: true
    passportId?: true
    status?: true
    _all?: true
  }

  export type PassengerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passenger to aggregate.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Passengers
    **/
    _count?: true | PassengerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PassengerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PassengerMaxAggregateInputType
  }

  export type GetPassengerAggregateType<T extends PassengerAggregateArgs> = {
        [P in keyof T & keyof AggregatePassenger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassenger[P]>
      : GetScalarType<T[P], AggregatePassenger[P]>
  }




  export type PassengerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassengerWhereInput
    orderBy?: PassengerOrderByWithAggregationInput | PassengerOrderByWithAggregationInput[]
    by: PassengerScalarFieldEnum[] | PassengerScalarFieldEnum
    having?: PassengerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PassengerCountAggregateInputType | true
    _min?: PassengerMinAggregateInputType
    _max?: PassengerMaxAggregateInputType
  }

  export type PassengerGroupByOutputType = {
    id: string
    applicationId: string
    createdAt: Date
    name: string | null
    passportNumber: string | null
    updatedAt: Date | null
    dateOfBirth: Date | null
    fullName: string | null
    gender: string | null
    nationality: string | null
    passportId: string | null
    status: string | null
    _count: PassengerCountAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  type GetPassengerGroupByPayload<T extends PassengerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PassengerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PassengerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PassengerGroupByOutputType[P]>
            : GetScalarType<T[P], PassengerGroupByOutputType[P]>
        }
      >
    >


  export type PassengerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    createdAt?: boolean
    name?: boolean
    passportNumber?: boolean
    updatedAt?: boolean
    dateOfBirth?: boolean
    fullName?: boolean
    gender?: boolean
    nationality?: boolean
    passportId?: boolean
    status?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    createdAt?: boolean
    name?: boolean
    passportNumber?: boolean
    updatedAt?: boolean
    dateOfBirth?: boolean
    fullName?: boolean
    gender?: boolean
    nationality?: boolean
    passportId?: boolean
    status?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    createdAt?: boolean
    name?: boolean
    passportNumber?: boolean
    updatedAt?: boolean
    dateOfBirth?: boolean
    fullName?: boolean
    gender?: boolean
    nationality?: boolean
    passportId?: boolean
    status?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectScalar = {
    id?: boolean
    applicationId?: boolean
    createdAt?: boolean
    name?: boolean
    passportNumber?: boolean
    updatedAt?: boolean
    dateOfBirth?: boolean
    fullName?: boolean
    gender?: boolean
    nationality?: boolean
    passportId?: boolean
    status?: boolean
  }

  export type PassengerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationId" | "createdAt" | "name" | "passportNumber" | "updatedAt" | "dateOfBirth" | "fullName" | "gender" | "nationality" | "passportId" | "status", ExtArgs["result"]["passenger"]>
  export type PassengerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type PassengerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type PassengerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }

  export type $PassengerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Passenger"
    objects: {
      Application: Prisma.$ApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      createdAt: Date
      name: string | null
      passportNumber: string | null
      updatedAt: Date | null
      dateOfBirth: Date | null
      fullName: string | null
      gender: string | null
      nationality: string | null
      passportId: string | null
      status: string | null
    }, ExtArgs["result"]["passenger"]>
    composites: {}
  }

  type PassengerGetPayload<S extends boolean | null | undefined | PassengerDefaultArgs> = $Result.GetResult<Prisma.$PassengerPayload, S>

  type PassengerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PassengerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PassengerCountAggregateInputType | true
    }

  export interface PassengerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Passenger'], meta: { name: 'Passenger' } }
    /**
     * Find zero or one Passenger that matches the filter.
     * @param {PassengerFindUniqueArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PassengerFindUniqueArgs>(args: SelectSubset<T, PassengerFindUniqueArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Passenger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PassengerFindUniqueOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PassengerFindUniqueOrThrowArgs>(args: SelectSubset<T, PassengerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindFirstArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PassengerFindFirstArgs>(args?: SelectSubset<T, PassengerFindFirstArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindFirstOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PassengerFindFirstOrThrowArgs>(args?: SelectSubset<T, PassengerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passengers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passengers
     * const passengers = await prisma.passenger.findMany()
     * 
     * // Get first 10 Passengers
     * const passengers = await prisma.passenger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passengerWithIdOnly = await prisma.passenger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PassengerFindManyArgs>(args?: SelectSubset<T, PassengerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Passenger.
     * @param {PassengerCreateArgs} args - Arguments to create a Passenger.
     * @example
     * // Create one Passenger
     * const Passenger = await prisma.passenger.create({
     *   data: {
     *     // ... data to create a Passenger
     *   }
     * })
     * 
     */
    create<T extends PassengerCreateArgs>(args: SelectSubset<T, PassengerCreateArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passengers.
     * @param {PassengerCreateManyArgs} args - Arguments to create many Passengers.
     * @example
     * // Create many Passengers
     * const passenger = await prisma.passenger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PassengerCreateManyArgs>(args?: SelectSubset<T, PassengerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Passengers and returns the data saved in the database.
     * @param {PassengerCreateManyAndReturnArgs} args - Arguments to create many Passengers.
     * @example
     * // Create many Passengers
     * const passenger = await prisma.passenger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Passengers and only return the `id`
     * const passengerWithIdOnly = await prisma.passenger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PassengerCreateManyAndReturnArgs>(args?: SelectSubset<T, PassengerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Passenger.
     * @param {PassengerDeleteArgs} args - Arguments to delete one Passenger.
     * @example
     * // Delete one Passenger
     * const Passenger = await prisma.passenger.delete({
     *   where: {
     *     // ... filter to delete one Passenger
     *   }
     * })
     * 
     */
    delete<T extends PassengerDeleteArgs>(args: SelectSubset<T, PassengerDeleteArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Passenger.
     * @param {PassengerUpdateArgs} args - Arguments to update one Passenger.
     * @example
     * // Update one Passenger
     * const passenger = await prisma.passenger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PassengerUpdateArgs>(args: SelectSubset<T, PassengerUpdateArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passengers.
     * @param {PassengerDeleteManyArgs} args - Arguments to filter Passengers to delete.
     * @example
     * // Delete a few Passengers
     * const { count } = await prisma.passenger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PassengerDeleteManyArgs>(args?: SelectSubset<T, PassengerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passengers
     * const passenger = await prisma.passenger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PassengerUpdateManyArgs>(args: SelectSubset<T, PassengerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passengers and returns the data updated in the database.
     * @param {PassengerUpdateManyAndReturnArgs} args - Arguments to update many Passengers.
     * @example
     * // Update many Passengers
     * const passenger = await prisma.passenger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Passengers and only return the `id`
     * const passengerWithIdOnly = await prisma.passenger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PassengerUpdateManyAndReturnArgs>(args: SelectSubset<T, PassengerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Passenger.
     * @param {PassengerUpsertArgs} args - Arguments to update or create a Passenger.
     * @example
     * // Update or create a Passenger
     * const passenger = await prisma.passenger.upsert({
     *   create: {
     *     // ... data to create a Passenger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Passenger we want to update
     *   }
     * })
     */
    upsert<T extends PassengerUpsertArgs>(args: SelectSubset<T, PassengerUpsertArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerCountArgs} args - Arguments to filter Passengers to count.
     * @example
     * // Count the number of Passengers
     * const count = await prisma.passenger.count({
     *   where: {
     *     // ... the filter for the Passengers we want to count
     *   }
     * })
    **/
    count<T extends PassengerCountArgs>(
      args?: Subset<T, PassengerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PassengerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PassengerAggregateArgs>(args: Subset<T, PassengerAggregateArgs>): Prisma.PrismaPromise<GetPassengerAggregateType<T>>

    /**
     * Group by Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PassengerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PassengerGroupByArgs['orderBy'] }
        : { orderBy?: PassengerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PassengerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassengerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Passenger model
   */
  readonly fields: PassengerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Passenger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PassengerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Application<T extends ApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDefaultArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Passenger model
   */
  interface PassengerFieldRefs {
    readonly id: FieldRef<"Passenger", 'String'>
    readonly applicationId: FieldRef<"Passenger", 'String'>
    readonly createdAt: FieldRef<"Passenger", 'DateTime'>
    readonly name: FieldRef<"Passenger", 'String'>
    readonly passportNumber: FieldRef<"Passenger", 'String'>
    readonly updatedAt: FieldRef<"Passenger", 'DateTime'>
    readonly dateOfBirth: FieldRef<"Passenger", 'DateTime'>
    readonly fullName: FieldRef<"Passenger", 'String'>
    readonly gender: FieldRef<"Passenger", 'String'>
    readonly nationality: FieldRef<"Passenger", 'String'>
    readonly passportId: FieldRef<"Passenger", 'String'>
    readonly status: FieldRef<"Passenger", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Passenger findUnique
   */
  export type PassengerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger findUniqueOrThrow
   */
  export type PassengerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger findFirst
   */
  export type PassengerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passengers.
     */
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger findFirstOrThrow
   */
  export type PassengerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passengers.
     */
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger findMany
   */
  export type PassengerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passengers to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger create
   */
  export type PassengerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * The data needed to create a Passenger.
     */
    data: XOR<PassengerCreateInput, PassengerUncheckedCreateInput>
  }

  /**
   * Passenger createMany
   */
  export type PassengerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Passengers.
     */
    data: PassengerCreateManyInput | PassengerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Passenger createManyAndReturn
   */
  export type PassengerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data used to create many Passengers.
     */
    data: PassengerCreateManyInput | PassengerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Passenger update
   */
  export type PassengerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * The data needed to update a Passenger.
     */
    data: XOR<PassengerUpdateInput, PassengerUncheckedUpdateInput>
    /**
     * Choose, which Passenger to update.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger updateMany
   */
  export type PassengerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Passengers.
     */
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyInput>
    /**
     * Filter which Passengers to update
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to update.
     */
    limit?: number
  }

  /**
   * Passenger updateManyAndReturn
   */
  export type PassengerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data used to update Passengers.
     */
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyInput>
    /**
     * Filter which Passengers to update
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Passenger upsert
   */
  export type PassengerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * The filter to search for the Passenger to update in case it exists.
     */
    where: PassengerWhereUniqueInput
    /**
     * In case the Passenger found by the `where` argument doesn't exist, create a new Passenger with this data.
     */
    create: XOR<PassengerCreateInput, PassengerUncheckedCreateInput>
    /**
     * In case the Passenger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PassengerUpdateInput, PassengerUncheckedUpdateInput>
  }

  /**
   * Passenger delete
   */
  export type PassengerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter which Passenger to delete.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger deleteMany
   */
  export type PassengerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passengers to delete
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to delete.
     */
    limit?: number
  }

  /**
   * Passenger without action
   */
  export type PassengerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
  }


  /**
   * Model Risk
   */

  export type AggregateRisk = {
    _count: RiskCountAggregateOutputType | null
    _min: RiskMinAggregateOutputType | null
    _max: RiskMaxAggregateOutputType | null
  }

  export type RiskMinAggregateOutputType = {
    id: string | null
    status: string | null
    applicationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUpdated: Date | null
  }

  export type RiskMaxAggregateOutputType = {
    id: string | null
    status: string | null
    applicationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUpdated: Date | null
  }

  export type RiskCountAggregateOutputType = {
    id: number
    status: number
    applicationId: number
    createdAt: number
    updatedAt: number
    lastUpdated: number
    _all: number
  }


  export type RiskMinAggregateInputType = {
    id?: true
    status?: true
    applicationId?: true
    createdAt?: true
    updatedAt?: true
    lastUpdated?: true
  }

  export type RiskMaxAggregateInputType = {
    id?: true
    status?: true
    applicationId?: true
    createdAt?: true
    updatedAt?: true
    lastUpdated?: true
  }

  export type RiskCountAggregateInputType = {
    id?: true
    status?: true
    applicationId?: true
    createdAt?: true
    updatedAt?: true
    lastUpdated?: true
    _all?: true
  }

  export type RiskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Risk to aggregate.
     */
    where?: RiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Risks to fetch.
     */
    orderBy?: RiskOrderByWithRelationInput | RiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Risks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Risks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Risks
    **/
    _count?: true | RiskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskMaxAggregateInputType
  }

  export type GetRiskAggregateType<T extends RiskAggregateArgs> = {
        [P in keyof T & keyof AggregateRisk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRisk[P]>
      : GetScalarType<T[P], AggregateRisk[P]>
  }




  export type RiskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskWhereInput
    orderBy?: RiskOrderByWithAggregationInput | RiskOrderByWithAggregationInput[]
    by: RiskScalarFieldEnum[] | RiskScalarFieldEnum
    having?: RiskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskCountAggregateInputType | true
    _min?: RiskMinAggregateInputType
    _max?: RiskMaxAggregateInputType
  }

  export type RiskGroupByOutputType = {
    id: string
    status: string
    applicationId: string
    createdAt: Date
    updatedAt: Date | null
    lastUpdated: Date | null
    _count: RiskCountAggregateOutputType | null
    _min: RiskMinAggregateOutputType | null
    _max: RiskMaxAggregateOutputType | null
  }

  type GetRiskGroupByPayload<T extends RiskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskGroupByOutputType[P]>
            : GetScalarType<T[P], RiskGroupByOutputType[P]>
        }
      >
    >


  export type RiskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    applicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdated?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
    RiskActivity?: boolean | Risk$RiskActivityArgs<ExtArgs>
    RiskDocument?: boolean | Risk$RiskDocumentArgs<ExtArgs>
    _count?: boolean | RiskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["risk"]>

  export type RiskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    applicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdated?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["risk"]>

  export type RiskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    applicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdated?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["risk"]>

  export type RiskSelectScalar = {
    id?: boolean
    status?: boolean
    applicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdated?: boolean
  }

  export type RiskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "applicationId" | "createdAt" | "updatedAt" | "lastUpdated", ExtArgs["result"]["risk"]>
  export type RiskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
    RiskActivity?: boolean | Risk$RiskActivityArgs<ExtArgs>
    RiskDocument?: boolean | Risk$RiskDocumentArgs<ExtArgs>
    _count?: boolean | RiskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RiskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type RiskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }

  export type $RiskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Risk"
    objects: {
      Application: Prisma.$ApplicationPayload<ExtArgs>
      RiskActivity: Prisma.$RiskActivityPayload<ExtArgs>[]
      RiskDocument: Prisma.$RiskDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      applicationId: string
      createdAt: Date
      updatedAt: Date | null
      lastUpdated: Date | null
    }, ExtArgs["result"]["risk"]>
    composites: {}
  }

  type RiskGetPayload<S extends boolean | null | undefined | RiskDefaultArgs> = $Result.GetResult<Prisma.$RiskPayload, S>

  type RiskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RiskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RiskCountAggregateInputType | true
    }

  export interface RiskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Risk'], meta: { name: 'Risk' } }
    /**
     * Find zero or one Risk that matches the filter.
     * @param {RiskFindUniqueArgs} args - Arguments to find a Risk
     * @example
     * // Get one Risk
     * const risk = await prisma.risk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskFindUniqueArgs>(args: SelectSubset<T, RiskFindUniqueArgs<ExtArgs>>): Prisma__RiskClient<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Risk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RiskFindUniqueOrThrowArgs} args - Arguments to find a Risk
     * @example
     * // Get one Risk
     * const risk = await prisma.risk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskClient<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Risk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskFindFirstArgs} args - Arguments to find a Risk
     * @example
     * // Get one Risk
     * const risk = await prisma.risk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskFindFirstArgs>(args?: SelectSubset<T, RiskFindFirstArgs<ExtArgs>>): Prisma__RiskClient<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Risk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskFindFirstOrThrowArgs} args - Arguments to find a Risk
     * @example
     * // Get one Risk
     * const risk = await prisma.risk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskClient<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Risks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Risks
     * const risks = await prisma.risk.findMany()
     * 
     * // Get first 10 Risks
     * const risks = await prisma.risk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskWithIdOnly = await prisma.risk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskFindManyArgs>(args?: SelectSubset<T, RiskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Risk.
     * @param {RiskCreateArgs} args - Arguments to create a Risk.
     * @example
     * // Create one Risk
     * const Risk = await prisma.risk.create({
     *   data: {
     *     // ... data to create a Risk
     *   }
     * })
     * 
     */
    create<T extends RiskCreateArgs>(args: SelectSubset<T, RiskCreateArgs<ExtArgs>>): Prisma__RiskClient<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Risks.
     * @param {RiskCreateManyArgs} args - Arguments to create many Risks.
     * @example
     * // Create many Risks
     * const risk = await prisma.risk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskCreateManyArgs>(args?: SelectSubset<T, RiskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Risks and returns the data saved in the database.
     * @param {RiskCreateManyAndReturnArgs} args - Arguments to create many Risks.
     * @example
     * // Create many Risks
     * const risk = await prisma.risk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Risks and only return the `id`
     * const riskWithIdOnly = await prisma.risk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Risk.
     * @param {RiskDeleteArgs} args - Arguments to delete one Risk.
     * @example
     * // Delete one Risk
     * const Risk = await prisma.risk.delete({
     *   where: {
     *     // ... filter to delete one Risk
     *   }
     * })
     * 
     */
    delete<T extends RiskDeleteArgs>(args: SelectSubset<T, RiskDeleteArgs<ExtArgs>>): Prisma__RiskClient<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Risk.
     * @param {RiskUpdateArgs} args - Arguments to update one Risk.
     * @example
     * // Update one Risk
     * const risk = await prisma.risk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskUpdateArgs>(args: SelectSubset<T, RiskUpdateArgs<ExtArgs>>): Prisma__RiskClient<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Risks.
     * @param {RiskDeleteManyArgs} args - Arguments to filter Risks to delete.
     * @example
     * // Delete a few Risks
     * const { count } = await prisma.risk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskDeleteManyArgs>(args?: SelectSubset<T, RiskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Risks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Risks
     * const risk = await prisma.risk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskUpdateManyArgs>(args: SelectSubset<T, RiskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Risks and returns the data updated in the database.
     * @param {RiskUpdateManyAndReturnArgs} args - Arguments to update many Risks.
     * @example
     * // Update many Risks
     * const risk = await prisma.risk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Risks and only return the `id`
     * const riskWithIdOnly = await prisma.risk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RiskUpdateManyAndReturnArgs>(args: SelectSubset<T, RiskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Risk.
     * @param {RiskUpsertArgs} args - Arguments to update or create a Risk.
     * @example
     * // Update or create a Risk
     * const risk = await prisma.risk.upsert({
     *   create: {
     *     // ... data to create a Risk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Risk we want to update
     *   }
     * })
     */
    upsert<T extends RiskUpsertArgs>(args: SelectSubset<T, RiskUpsertArgs<ExtArgs>>): Prisma__RiskClient<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Risks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskCountArgs} args - Arguments to filter Risks to count.
     * @example
     * // Count the number of Risks
     * const count = await prisma.risk.count({
     *   where: {
     *     // ... the filter for the Risks we want to count
     *   }
     * })
    **/
    count<T extends RiskCountArgs>(
      args?: Subset<T, RiskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Risk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskAggregateArgs>(args: Subset<T, RiskAggregateArgs>): Prisma.PrismaPromise<GetRiskAggregateType<T>>

    /**
     * Group by Risk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskGroupByArgs['orderBy'] }
        : { orderBy?: RiskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Risk model
   */
  readonly fields: RiskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Risk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Application<T extends ApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDefaultArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RiskActivity<T extends Risk$RiskActivityArgs<ExtArgs> = {}>(args?: Subset<T, Risk$RiskActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RiskDocument<T extends Risk$RiskDocumentArgs<ExtArgs> = {}>(args?: Subset<T, Risk$RiskDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Risk model
   */
  interface RiskFieldRefs {
    readonly id: FieldRef<"Risk", 'String'>
    readonly status: FieldRef<"Risk", 'String'>
    readonly applicationId: FieldRef<"Risk", 'String'>
    readonly createdAt: FieldRef<"Risk", 'DateTime'>
    readonly updatedAt: FieldRef<"Risk", 'DateTime'>
    readonly lastUpdated: FieldRef<"Risk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Risk findUnique
   */
  export type RiskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskInclude<ExtArgs> | null
    /**
     * Filter, which Risk to fetch.
     */
    where: RiskWhereUniqueInput
  }

  /**
   * Risk findUniqueOrThrow
   */
  export type RiskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskInclude<ExtArgs> | null
    /**
     * Filter, which Risk to fetch.
     */
    where: RiskWhereUniqueInput
  }

  /**
   * Risk findFirst
   */
  export type RiskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskInclude<ExtArgs> | null
    /**
     * Filter, which Risk to fetch.
     */
    where?: RiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Risks to fetch.
     */
    orderBy?: RiskOrderByWithRelationInput | RiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Risks.
     */
    cursor?: RiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Risks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Risks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Risks.
     */
    distinct?: RiskScalarFieldEnum | RiskScalarFieldEnum[]
  }

  /**
   * Risk findFirstOrThrow
   */
  export type RiskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskInclude<ExtArgs> | null
    /**
     * Filter, which Risk to fetch.
     */
    where?: RiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Risks to fetch.
     */
    orderBy?: RiskOrderByWithRelationInput | RiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Risks.
     */
    cursor?: RiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Risks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Risks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Risks.
     */
    distinct?: RiskScalarFieldEnum | RiskScalarFieldEnum[]
  }

  /**
   * Risk findMany
   */
  export type RiskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskInclude<ExtArgs> | null
    /**
     * Filter, which Risks to fetch.
     */
    where?: RiskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Risks to fetch.
     */
    orderBy?: RiskOrderByWithRelationInput | RiskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Risks.
     */
    cursor?: RiskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Risks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Risks.
     */
    skip?: number
    distinct?: RiskScalarFieldEnum | RiskScalarFieldEnum[]
  }

  /**
   * Risk create
   */
  export type RiskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskInclude<ExtArgs> | null
    /**
     * The data needed to create a Risk.
     */
    data: XOR<RiskCreateInput, RiskUncheckedCreateInput>
  }

  /**
   * Risk createMany
   */
  export type RiskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Risks.
     */
    data: RiskCreateManyInput | RiskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Risk createManyAndReturn
   */
  export type RiskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * The data used to create many Risks.
     */
    data: RiskCreateManyInput | RiskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Risk update
   */
  export type RiskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskInclude<ExtArgs> | null
    /**
     * The data needed to update a Risk.
     */
    data: XOR<RiskUpdateInput, RiskUncheckedUpdateInput>
    /**
     * Choose, which Risk to update.
     */
    where: RiskWhereUniqueInput
  }

  /**
   * Risk updateMany
   */
  export type RiskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Risks.
     */
    data: XOR<RiskUpdateManyMutationInput, RiskUncheckedUpdateManyInput>
    /**
     * Filter which Risks to update
     */
    where?: RiskWhereInput
    /**
     * Limit how many Risks to update.
     */
    limit?: number
  }

  /**
   * Risk updateManyAndReturn
   */
  export type RiskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * The data used to update Risks.
     */
    data: XOR<RiskUpdateManyMutationInput, RiskUncheckedUpdateManyInput>
    /**
     * Filter which Risks to update
     */
    where?: RiskWhereInput
    /**
     * Limit how many Risks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Risk upsert
   */
  export type RiskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskInclude<ExtArgs> | null
    /**
     * The filter to search for the Risk to update in case it exists.
     */
    where: RiskWhereUniqueInput
    /**
     * In case the Risk found by the `where` argument doesn't exist, create a new Risk with this data.
     */
    create: XOR<RiskCreateInput, RiskUncheckedCreateInput>
    /**
     * In case the Risk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskUpdateInput, RiskUncheckedUpdateInput>
  }

  /**
   * Risk delete
   */
  export type RiskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskInclude<ExtArgs> | null
    /**
     * Filter which Risk to delete.
     */
    where: RiskWhereUniqueInput
  }

  /**
   * Risk deleteMany
   */
  export type RiskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Risks to delete
     */
    where?: RiskWhereInput
    /**
     * Limit how many Risks to delete.
     */
    limit?: number
  }

  /**
   * Risk.RiskActivity
   */
  export type Risk$RiskActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityInclude<ExtArgs> | null
    where?: RiskActivityWhereInput
    orderBy?: RiskActivityOrderByWithRelationInput | RiskActivityOrderByWithRelationInput[]
    cursor?: RiskActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RiskActivityScalarFieldEnum | RiskActivityScalarFieldEnum[]
  }

  /**
   * Risk.RiskDocument
   */
  export type Risk$RiskDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentInclude<ExtArgs> | null
    where?: RiskDocumentWhereInput
    orderBy?: RiskDocumentOrderByWithRelationInput | RiskDocumentOrderByWithRelationInput[]
    cursor?: RiskDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RiskDocumentScalarFieldEnum | RiskDocumentScalarFieldEnum[]
  }

  /**
   * Risk without action
   */
  export type RiskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Risk
     */
    select?: RiskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Risk
     */
    omit?: RiskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskInclude<ExtArgs> | null
  }


  /**
   * Model RiskActivity
   */

  export type AggregateRiskActivity = {
    _count: RiskActivityCountAggregateOutputType | null
    _min: RiskActivityMinAggregateOutputType | null
    _max: RiskActivityMaxAggregateOutputType | null
  }

  export type RiskActivityMinAggregateOutputType = {
    id: string | null
    riskId: string | null
    createdAt: Date | null
    description: string | null
    type: string | null
    details: string | null
    timestamp: Date | null
    title: string | null
  }

  export type RiskActivityMaxAggregateOutputType = {
    id: string | null
    riskId: string | null
    createdAt: Date | null
    description: string | null
    type: string | null
    details: string | null
    timestamp: Date | null
    title: string | null
  }

  export type RiskActivityCountAggregateOutputType = {
    id: number
    riskId: number
    createdAt: number
    description: number
    type: number
    details: number
    timestamp: number
    title: number
    _all: number
  }


  export type RiskActivityMinAggregateInputType = {
    id?: true
    riskId?: true
    createdAt?: true
    description?: true
    type?: true
    details?: true
    timestamp?: true
    title?: true
  }

  export type RiskActivityMaxAggregateInputType = {
    id?: true
    riskId?: true
    createdAt?: true
    description?: true
    type?: true
    details?: true
    timestamp?: true
    title?: true
  }

  export type RiskActivityCountAggregateInputType = {
    id?: true
    riskId?: true
    createdAt?: true
    description?: true
    type?: true
    details?: true
    timestamp?: true
    title?: true
    _all?: true
  }

  export type RiskActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskActivity to aggregate.
     */
    where?: RiskActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskActivities to fetch.
     */
    orderBy?: RiskActivityOrderByWithRelationInput | RiskActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskActivities
    **/
    _count?: true | RiskActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskActivityMaxAggregateInputType
  }

  export type GetRiskActivityAggregateType<T extends RiskActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskActivity[P]>
      : GetScalarType<T[P], AggregateRiskActivity[P]>
  }




  export type RiskActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskActivityWhereInput
    orderBy?: RiskActivityOrderByWithAggregationInput | RiskActivityOrderByWithAggregationInput[]
    by: RiskActivityScalarFieldEnum[] | RiskActivityScalarFieldEnum
    having?: RiskActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskActivityCountAggregateInputType | true
    _min?: RiskActivityMinAggregateInputType
    _max?: RiskActivityMaxAggregateInputType
  }

  export type RiskActivityGroupByOutputType = {
    id: string
    riskId: string
    createdAt: Date
    description: string | null
    type: string | null
    details: string | null
    timestamp: Date | null
    title: string | null
    _count: RiskActivityCountAggregateOutputType | null
    _min: RiskActivityMinAggregateOutputType | null
    _max: RiskActivityMaxAggregateOutputType | null
  }

  type GetRiskActivityGroupByPayload<T extends RiskActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskActivityGroupByOutputType[P]>
            : GetScalarType<T[P], RiskActivityGroupByOutputType[P]>
        }
      >
    >


  export type RiskActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    riskId?: boolean
    createdAt?: boolean
    description?: boolean
    type?: boolean
    details?: boolean
    timestamp?: boolean
    title?: boolean
    Risk?: boolean | RiskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskActivity"]>

  export type RiskActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    riskId?: boolean
    createdAt?: boolean
    description?: boolean
    type?: boolean
    details?: boolean
    timestamp?: boolean
    title?: boolean
    Risk?: boolean | RiskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskActivity"]>

  export type RiskActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    riskId?: boolean
    createdAt?: boolean
    description?: boolean
    type?: boolean
    details?: boolean
    timestamp?: boolean
    title?: boolean
    Risk?: boolean | RiskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskActivity"]>

  export type RiskActivitySelectScalar = {
    id?: boolean
    riskId?: boolean
    createdAt?: boolean
    description?: boolean
    type?: boolean
    details?: boolean
    timestamp?: boolean
    title?: boolean
  }

  export type RiskActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "riskId" | "createdAt" | "description" | "type" | "details" | "timestamp" | "title", ExtArgs["result"]["riskActivity"]>
  export type RiskActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Risk?: boolean | RiskDefaultArgs<ExtArgs>
  }
  export type RiskActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Risk?: boolean | RiskDefaultArgs<ExtArgs>
  }
  export type RiskActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Risk?: boolean | RiskDefaultArgs<ExtArgs>
  }

  export type $RiskActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskActivity"
    objects: {
      Risk: Prisma.$RiskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      riskId: string
      createdAt: Date
      description: string | null
      type: string | null
      details: string | null
      timestamp: Date | null
      title: string | null
    }, ExtArgs["result"]["riskActivity"]>
    composites: {}
  }

  type RiskActivityGetPayload<S extends boolean | null | undefined | RiskActivityDefaultArgs> = $Result.GetResult<Prisma.$RiskActivityPayload, S>

  type RiskActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RiskActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RiskActivityCountAggregateInputType | true
    }

  export interface RiskActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskActivity'], meta: { name: 'RiskActivity' } }
    /**
     * Find zero or one RiskActivity that matches the filter.
     * @param {RiskActivityFindUniqueArgs} args - Arguments to find a RiskActivity
     * @example
     * // Get one RiskActivity
     * const riskActivity = await prisma.riskActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskActivityFindUniqueArgs>(args: SelectSubset<T, RiskActivityFindUniqueArgs<ExtArgs>>): Prisma__RiskActivityClient<$Result.GetResult<Prisma.$RiskActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RiskActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RiskActivityFindUniqueOrThrowArgs} args - Arguments to find a RiskActivity
     * @example
     * // Get one RiskActivity
     * const riskActivity = await prisma.riskActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskActivityClient<$Result.GetResult<Prisma.$RiskActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskActivityFindFirstArgs} args - Arguments to find a RiskActivity
     * @example
     * // Get one RiskActivity
     * const riskActivity = await prisma.riskActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskActivityFindFirstArgs>(args?: SelectSubset<T, RiskActivityFindFirstArgs<ExtArgs>>): Prisma__RiskActivityClient<$Result.GetResult<Prisma.$RiskActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskActivityFindFirstOrThrowArgs} args - Arguments to find a RiskActivity
     * @example
     * // Get one RiskActivity
     * const riskActivity = await prisma.riskActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskActivityClient<$Result.GetResult<Prisma.$RiskActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RiskActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskActivities
     * const riskActivities = await prisma.riskActivity.findMany()
     * 
     * // Get first 10 RiskActivities
     * const riskActivities = await prisma.riskActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskActivityWithIdOnly = await prisma.riskActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskActivityFindManyArgs>(args?: SelectSubset<T, RiskActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RiskActivity.
     * @param {RiskActivityCreateArgs} args - Arguments to create a RiskActivity.
     * @example
     * // Create one RiskActivity
     * const RiskActivity = await prisma.riskActivity.create({
     *   data: {
     *     // ... data to create a RiskActivity
     *   }
     * })
     * 
     */
    create<T extends RiskActivityCreateArgs>(args: SelectSubset<T, RiskActivityCreateArgs<ExtArgs>>): Prisma__RiskActivityClient<$Result.GetResult<Prisma.$RiskActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RiskActivities.
     * @param {RiskActivityCreateManyArgs} args - Arguments to create many RiskActivities.
     * @example
     * // Create many RiskActivities
     * const riskActivity = await prisma.riskActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskActivityCreateManyArgs>(args?: SelectSubset<T, RiskActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskActivities and returns the data saved in the database.
     * @param {RiskActivityCreateManyAndReturnArgs} args - Arguments to create many RiskActivities.
     * @example
     * // Create many RiskActivities
     * const riskActivity = await prisma.riskActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskActivities and only return the `id`
     * const riskActivityWithIdOnly = await prisma.riskActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RiskActivity.
     * @param {RiskActivityDeleteArgs} args - Arguments to delete one RiskActivity.
     * @example
     * // Delete one RiskActivity
     * const RiskActivity = await prisma.riskActivity.delete({
     *   where: {
     *     // ... filter to delete one RiskActivity
     *   }
     * })
     * 
     */
    delete<T extends RiskActivityDeleteArgs>(args: SelectSubset<T, RiskActivityDeleteArgs<ExtArgs>>): Prisma__RiskActivityClient<$Result.GetResult<Prisma.$RiskActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RiskActivity.
     * @param {RiskActivityUpdateArgs} args - Arguments to update one RiskActivity.
     * @example
     * // Update one RiskActivity
     * const riskActivity = await prisma.riskActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskActivityUpdateArgs>(args: SelectSubset<T, RiskActivityUpdateArgs<ExtArgs>>): Prisma__RiskActivityClient<$Result.GetResult<Prisma.$RiskActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RiskActivities.
     * @param {RiskActivityDeleteManyArgs} args - Arguments to filter RiskActivities to delete.
     * @example
     * // Delete a few RiskActivities
     * const { count } = await prisma.riskActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskActivityDeleteManyArgs>(args?: SelectSubset<T, RiskActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskActivities
     * const riskActivity = await prisma.riskActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskActivityUpdateManyArgs>(args: SelectSubset<T, RiskActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskActivities and returns the data updated in the database.
     * @param {RiskActivityUpdateManyAndReturnArgs} args - Arguments to update many RiskActivities.
     * @example
     * // Update many RiskActivities
     * const riskActivity = await prisma.riskActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RiskActivities and only return the `id`
     * const riskActivityWithIdOnly = await prisma.riskActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RiskActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, RiskActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RiskActivity.
     * @param {RiskActivityUpsertArgs} args - Arguments to update or create a RiskActivity.
     * @example
     * // Update or create a RiskActivity
     * const riskActivity = await prisma.riskActivity.upsert({
     *   create: {
     *     // ... data to create a RiskActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskActivity we want to update
     *   }
     * })
     */
    upsert<T extends RiskActivityUpsertArgs>(args: SelectSubset<T, RiskActivityUpsertArgs<ExtArgs>>): Prisma__RiskActivityClient<$Result.GetResult<Prisma.$RiskActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RiskActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskActivityCountArgs} args - Arguments to filter RiskActivities to count.
     * @example
     * // Count the number of RiskActivities
     * const count = await prisma.riskActivity.count({
     *   where: {
     *     // ... the filter for the RiskActivities we want to count
     *   }
     * })
    **/
    count<T extends RiskActivityCountArgs>(
      args?: Subset<T, RiskActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskActivityAggregateArgs>(args: Subset<T, RiskActivityAggregateArgs>): Prisma.PrismaPromise<GetRiskActivityAggregateType<T>>

    /**
     * Group by RiskActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskActivityGroupByArgs['orderBy'] }
        : { orderBy?: RiskActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskActivity model
   */
  readonly fields: RiskActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Risk<T extends RiskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RiskDefaultArgs<ExtArgs>>): Prisma__RiskClient<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskActivity model
   */
  interface RiskActivityFieldRefs {
    readonly id: FieldRef<"RiskActivity", 'String'>
    readonly riskId: FieldRef<"RiskActivity", 'String'>
    readonly createdAt: FieldRef<"RiskActivity", 'DateTime'>
    readonly description: FieldRef<"RiskActivity", 'String'>
    readonly type: FieldRef<"RiskActivity", 'String'>
    readonly details: FieldRef<"RiskActivity", 'String'>
    readonly timestamp: FieldRef<"RiskActivity", 'DateTime'>
    readonly title: FieldRef<"RiskActivity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RiskActivity findUnique
   */
  export type RiskActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityInclude<ExtArgs> | null
    /**
     * Filter, which RiskActivity to fetch.
     */
    where: RiskActivityWhereUniqueInput
  }

  /**
   * RiskActivity findUniqueOrThrow
   */
  export type RiskActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityInclude<ExtArgs> | null
    /**
     * Filter, which RiskActivity to fetch.
     */
    where: RiskActivityWhereUniqueInput
  }

  /**
   * RiskActivity findFirst
   */
  export type RiskActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityInclude<ExtArgs> | null
    /**
     * Filter, which RiskActivity to fetch.
     */
    where?: RiskActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskActivities to fetch.
     */
    orderBy?: RiskActivityOrderByWithRelationInput | RiskActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskActivities.
     */
    cursor?: RiskActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskActivities.
     */
    distinct?: RiskActivityScalarFieldEnum | RiskActivityScalarFieldEnum[]
  }

  /**
   * RiskActivity findFirstOrThrow
   */
  export type RiskActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityInclude<ExtArgs> | null
    /**
     * Filter, which RiskActivity to fetch.
     */
    where?: RiskActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskActivities to fetch.
     */
    orderBy?: RiskActivityOrderByWithRelationInput | RiskActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskActivities.
     */
    cursor?: RiskActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskActivities.
     */
    distinct?: RiskActivityScalarFieldEnum | RiskActivityScalarFieldEnum[]
  }

  /**
   * RiskActivity findMany
   */
  export type RiskActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityInclude<ExtArgs> | null
    /**
     * Filter, which RiskActivities to fetch.
     */
    where?: RiskActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskActivities to fetch.
     */
    orderBy?: RiskActivityOrderByWithRelationInput | RiskActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskActivities.
     */
    cursor?: RiskActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskActivities.
     */
    skip?: number
    distinct?: RiskActivityScalarFieldEnum | RiskActivityScalarFieldEnum[]
  }

  /**
   * RiskActivity create
   */
  export type RiskActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskActivity.
     */
    data: XOR<RiskActivityCreateInput, RiskActivityUncheckedCreateInput>
  }

  /**
   * RiskActivity createMany
   */
  export type RiskActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskActivities.
     */
    data: RiskActivityCreateManyInput | RiskActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskActivity createManyAndReturn
   */
  export type RiskActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * The data used to create many RiskActivities.
     */
    data: RiskActivityCreateManyInput | RiskActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskActivity update
   */
  export type RiskActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskActivity.
     */
    data: XOR<RiskActivityUpdateInput, RiskActivityUncheckedUpdateInput>
    /**
     * Choose, which RiskActivity to update.
     */
    where: RiskActivityWhereUniqueInput
  }

  /**
   * RiskActivity updateMany
   */
  export type RiskActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskActivities.
     */
    data: XOR<RiskActivityUpdateManyMutationInput, RiskActivityUncheckedUpdateManyInput>
    /**
     * Filter which RiskActivities to update
     */
    where?: RiskActivityWhereInput
    /**
     * Limit how many RiskActivities to update.
     */
    limit?: number
  }

  /**
   * RiskActivity updateManyAndReturn
   */
  export type RiskActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * The data used to update RiskActivities.
     */
    data: XOR<RiskActivityUpdateManyMutationInput, RiskActivityUncheckedUpdateManyInput>
    /**
     * Filter which RiskActivities to update
     */
    where?: RiskActivityWhereInput
    /**
     * Limit how many RiskActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskActivity upsert
   */
  export type RiskActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskActivity to update in case it exists.
     */
    where: RiskActivityWhereUniqueInput
    /**
     * In case the RiskActivity found by the `where` argument doesn't exist, create a new RiskActivity with this data.
     */
    create: XOR<RiskActivityCreateInput, RiskActivityUncheckedCreateInput>
    /**
     * In case the RiskActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskActivityUpdateInput, RiskActivityUncheckedUpdateInput>
  }

  /**
   * RiskActivity delete
   */
  export type RiskActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityInclude<ExtArgs> | null
    /**
     * Filter which RiskActivity to delete.
     */
    where: RiskActivityWhereUniqueInput
  }

  /**
   * RiskActivity deleteMany
   */
  export type RiskActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskActivities to delete
     */
    where?: RiskActivityWhereInput
    /**
     * Limit how many RiskActivities to delete.
     */
    limit?: number
  }

  /**
   * RiskActivity without action
   */
  export type RiskActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskActivity
     */
    select?: RiskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskActivity
     */
    omit?: RiskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskActivityInclude<ExtArgs> | null
  }


  /**
   * Model RiskDocument
   */

  export type AggregateRiskDocument = {
    _count: RiskDocumentCountAggregateOutputType | null
    _min: RiskDocumentMinAggregateOutputType | null
    _max: RiskDocumentMaxAggregateOutputType | null
  }

  export type RiskDocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    riskId: string | null
    createdAt: Date | null
    status: string | null
    updatedAt: Date | null
    type: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
    content: Uint8Array | null
  }

  export type RiskDocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    riskId: string | null
    createdAt: Date | null
    status: string | null
    updatedAt: Date | null
    type: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
    content: Uint8Array | null
  }

  export type RiskDocumentCountAggregateOutputType = {
    id: number
    name: number
    riskId: number
    createdAt: number
    status: number
    updatedAt: number
    type: number
    uploadedAt: number
    uploadedBy: number
    content: number
    _all: number
  }


  export type RiskDocumentMinAggregateInputType = {
    id?: true
    name?: true
    riskId?: true
    createdAt?: true
    status?: true
    updatedAt?: true
    type?: true
    uploadedAt?: true
    uploadedBy?: true
    content?: true
  }

  export type RiskDocumentMaxAggregateInputType = {
    id?: true
    name?: true
    riskId?: true
    createdAt?: true
    status?: true
    updatedAt?: true
    type?: true
    uploadedAt?: true
    uploadedBy?: true
    content?: true
  }

  export type RiskDocumentCountAggregateInputType = {
    id?: true
    name?: true
    riskId?: true
    createdAt?: true
    status?: true
    updatedAt?: true
    type?: true
    uploadedAt?: true
    uploadedBy?: true
    content?: true
    _all?: true
  }

  export type RiskDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskDocument to aggregate.
     */
    where?: RiskDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskDocuments to fetch.
     */
    orderBy?: RiskDocumentOrderByWithRelationInput | RiskDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskDocuments
    **/
    _count?: true | RiskDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskDocumentMaxAggregateInputType
  }

  export type GetRiskDocumentAggregateType<T extends RiskDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskDocument[P]>
      : GetScalarType<T[P], AggregateRiskDocument[P]>
  }




  export type RiskDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskDocumentWhereInput
    orderBy?: RiskDocumentOrderByWithAggregationInput | RiskDocumentOrderByWithAggregationInput[]
    by: RiskDocumentScalarFieldEnum[] | RiskDocumentScalarFieldEnum
    having?: RiskDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskDocumentCountAggregateInputType | true
    _min?: RiskDocumentMinAggregateInputType
    _max?: RiskDocumentMaxAggregateInputType
  }

  export type RiskDocumentGroupByOutputType = {
    id: string
    name: string
    riskId: string
    createdAt: Date
    status: string
    updatedAt: Date
    type: string
    uploadedAt: Date
    uploadedBy: string | null
    content: Uint8Array
    _count: RiskDocumentCountAggregateOutputType | null
    _min: RiskDocumentMinAggregateOutputType | null
    _max: RiskDocumentMaxAggregateOutputType | null
  }

  type GetRiskDocumentGroupByPayload<T extends RiskDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], RiskDocumentGroupByOutputType[P]>
        }
      >
    >


  export type RiskDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    riskId?: boolean
    createdAt?: boolean
    status?: boolean
    updatedAt?: boolean
    type?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    content?: boolean
    Risk?: boolean | RiskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskDocument"]>

  export type RiskDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    riskId?: boolean
    createdAt?: boolean
    status?: boolean
    updatedAt?: boolean
    type?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    content?: boolean
    Risk?: boolean | RiskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskDocument"]>

  export type RiskDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    riskId?: boolean
    createdAt?: boolean
    status?: boolean
    updatedAt?: boolean
    type?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    content?: boolean
    Risk?: boolean | RiskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskDocument"]>

  export type RiskDocumentSelectScalar = {
    id?: boolean
    name?: boolean
    riskId?: boolean
    createdAt?: boolean
    status?: boolean
    updatedAt?: boolean
    type?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    content?: boolean
  }

  export type RiskDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "riskId" | "createdAt" | "status" | "updatedAt" | "type" | "uploadedAt" | "uploadedBy" | "content", ExtArgs["result"]["riskDocument"]>
  export type RiskDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Risk?: boolean | RiskDefaultArgs<ExtArgs>
  }
  export type RiskDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Risk?: boolean | RiskDefaultArgs<ExtArgs>
  }
  export type RiskDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Risk?: boolean | RiskDefaultArgs<ExtArgs>
  }

  export type $RiskDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskDocument"
    objects: {
      Risk: Prisma.$RiskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      riskId: string
      createdAt: Date
      status: string
      updatedAt: Date
      type: string
      uploadedAt: Date
      uploadedBy: string | null
      content: Uint8Array
    }, ExtArgs["result"]["riskDocument"]>
    composites: {}
  }

  type RiskDocumentGetPayload<S extends boolean | null | undefined | RiskDocumentDefaultArgs> = $Result.GetResult<Prisma.$RiskDocumentPayload, S>

  type RiskDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RiskDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RiskDocumentCountAggregateInputType | true
    }

  export interface RiskDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskDocument'], meta: { name: 'RiskDocument' } }
    /**
     * Find zero or one RiskDocument that matches the filter.
     * @param {RiskDocumentFindUniqueArgs} args - Arguments to find a RiskDocument
     * @example
     * // Get one RiskDocument
     * const riskDocument = await prisma.riskDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskDocumentFindUniqueArgs>(args: SelectSubset<T, RiskDocumentFindUniqueArgs<ExtArgs>>): Prisma__RiskDocumentClient<$Result.GetResult<Prisma.$RiskDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RiskDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RiskDocumentFindUniqueOrThrowArgs} args - Arguments to find a RiskDocument
     * @example
     * // Get one RiskDocument
     * const riskDocument = await prisma.riskDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskDocumentClient<$Result.GetResult<Prisma.$RiskDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDocumentFindFirstArgs} args - Arguments to find a RiskDocument
     * @example
     * // Get one RiskDocument
     * const riskDocument = await prisma.riskDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskDocumentFindFirstArgs>(args?: SelectSubset<T, RiskDocumentFindFirstArgs<ExtArgs>>): Prisma__RiskDocumentClient<$Result.GetResult<Prisma.$RiskDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDocumentFindFirstOrThrowArgs} args - Arguments to find a RiskDocument
     * @example
     * // Get one RiskDocument
     * const riskDocument = await prisma.riskDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskDocumentClient<$Result.GetResult<Prisma.$RiskDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RiskDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskDocuments
     * const riskDocuments = await prisma.riskDocument.findMany()
     * 
     * // Get first 10 RiskDocuments
     * const riskDocuments = await prisma.riskDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskDocumentWithIdOnly = await prisma.riskDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskDocumentFindManyArgs>(args?: SelectSubset<T, RiskDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RiskDocument.
     * @param {RiskDocumentCreateArgs} args - Arguments to create a RiskDocument.
     * @example
     * // Create one RiskDocument
     * const RiskDocument = await prisma.riskDocument.create({
     *   data: {
     *     // ... data to create a RiskDocument
     *   }
     * })
     * 
     */
    create<T extends RiskDocumentCreateArgs>(args: SelectSubset<T, RiskDocumentCreateArgs<ExtArgs>>): Prisma__RiskDocumentClient<$Result.GetResult<Prisma.$RiskDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RiskDocuments.
     * @param {RiskDocumentCreateManyArgs} args - Arguments to create many RiskDocuments.
     * @example
     * // Create many RiskDocuments
     * const riskDocument = await prisma.riskDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskDocumentCreateManyArgs>(args?: SelectSubset<T, RiskDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskDocuments and returns the data saved in the database.
     * @param {RiskDocumentCreateManyAndReturnArgs} args - Arguments to create many RiskDocuments.
     * @example
     * // Create many RiskDocuments
     * const riskDocument = await prisma.riskDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskDocuments and only return the `id`
     * const riskDocumentWithIdOnly = await prisma.riskDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RiskDocument.
     * @param {RiskDocumentDeleteArgs} args - Arguments to delete one RiskDocument.
     * @example
     * // Delete one RiskDocument
     * const RiskDocument = await prisma.riskDocument.delete({
     *   where: {
     *     // ... filter to delete one RiskDocument
     *   }
     * })
     * 
     */
    delete<T extends RiskDocumentDeleteArgs>(args: SelectSubset<T, RiskDocumentDeleteArgs<ExtArgs>>): Prisma__RiskDocumentClient<$Result.GetResult<Prisma.$RiskDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RiskDocument.
     * @param {RiskDocumentUpdateArgs} args - Arguments to update one RiskDocument.
     * @example
     * // Update one RiskDocument
     * const riskDocument = await prisma.riskDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskDocumentUpdateArgs>(args: SelectSubset<T, RiskDocumentUpdateArgs<ExtArgs>>): Prisma__RiskDocumentClient<$Result.GetResult<Prisma.$RiskDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RiskDocuments.
     * @param {RiskDocumentDeleteManyArgs} args - Arguments to filter RiskDocuments to delete.
     * @example
     * // Delete a few RiskDocuments
     * const { count } = await prisma.riskDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskDocumentDeleteManyArgs>(args?: SelectSubset<T, RiskDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskDocuments
     * const riskDocument = await prisma.riskDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskDocumentUpdateManyArgs>(args: SelectSubset<T, RiskDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskDocuments and returns the data updated in the database.
     * @param {RiskDocumentUpdateManyAndReturnArgs} args - Arguments to update many RiskDocuments.
     * @example
     * // Update many RiskDocuments
     * const riskDocument = await prisma.riskDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RiskDocuments and only return the `id`
     * const riskDocumentWithIdOnly = await prisma.riskDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RiskDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, RiskDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RiskDocument.
     * @param {RiskDocumentUpsertArgs} args - Arguments to update or create a RiskDocument.
     * @example
     * // Update or create a RiskDocument
     * const riskDocument = await prisma.riskDocument.upsert({
     *   create: {
     *     // ... data to create a RiskDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskDocument we want to update
     *   }
     * })
     */
    upsert<T extends RiskDocumentUpsertArgs>(args: SelectSubset<T, RiskDocumentUpsertArgs<ExtArgs>>): Prisma__RiskDocumentClient<$Result.GetResult<Prisma.$RiskDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RiskDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDocumentCountArgs} args - Arguments to filter RiskDocuments to count.
     * @example
     * // Count the number of RiskDocuments
     * const count = await prisma.riskDocument.count({
     *   where: {
     *     // ... the filter for the RiskDocuments we want to count
     *   }
     * })
    **/
    count<T extends RiskDocumentCountArgs>(
      args?: Subset<T, RiskDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskDocumentAggregateArgs>(args: Subset<T, RiskDocumentAggregateArgs>): Prisma.PrismaPromise<GetRiskDocumentAggregateType<T>>

    /**
     * Group by RiskDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskDocumentGroupByArgs['orderBy'] }
        : { orderBy?: RiskDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskDocument model
   */
  readonly fields: RiskDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Risk<T extends RiskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RiskDefaultArgs<ExtArgs>>): Prisma__RiskClient<$Result.GetResult<Prisma.$RiskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskDocument model
   */
  interface RiskDocumentFieldRefs {
    readonly id: FieldRef<"RiskDocument", 'String'>
    readonly name: FieldRef<"RiskDocument", 'String'>
    readonly riskId: FieldRef<"RiskDocument", 'String'>
    readonly createdAt: FieldRef<"RiskDocument", 'DateTime'>
    readonly status: FieldRef<"RiskDocument", 'String'>
    readonly updatedAt: FieldRef<"RiskDocument", 'DateTime'>
    readonly type: FieldRef<"RiskDocument", 'String'>
    readonly uploadedAt: FieldRef<"RiskDocument", 'DateTime'>
    readonly uploadedBy: FieldRef<"RiskDocument", 'String'>
    readonly content: FieldRef<"RiskDocument", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * RiskDocument findUnique
   */
  export type RiskDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentInclude<ExtArgs> | null
    /**
     * Filter, which RiskDocument to fetch.
     */
    where: RiskDocumentWhereUniqueInput
  }

  /**
   * RiskDocument findUniqueOrThrow
   */
  export type RiskDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentInclude<ExtArgs> | null
    /**
     * Filter, which RiskDocument to fetch.
     */
    where: RiskDocumentWhereUniqueInput
  }

  /**
   * RiskDocument findFirst
   */
  export type RiskDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentInclude<ExtArgs> | null
    /**
     * Filter, which RiskDocument to fetch.
     */
    where?: RiskDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskDocuments to fetch.
     */
    orderBy?: RiskDocumentOrderByWithRelationInput | RiskDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskDocuments.
     */
    cursor?: RiskDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskDocuments.
     */
    distinct?: RiskDocumentScalarFieldEnum | RiskDocumentScalarFieldEnum[]
  }

  /**
   * RiskDocument findFirstOrThrow
   */
  export type RiskDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentInclude<ExtArgs> | null
    /**
     * Filter, which RiskDocument to fetch.
     */
    where?: RiskDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskDocuments to fetch.
     */
    orderBy?: RiskDocumentOrderByWithRelationInput | RiskDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskDocuments.
     */
    cursor?: RiskDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskDocuments.
     */
    distinct?: RiskDocumentScalarFieldEnum | RiskDocumentScalarFieldEnum[]
  }

  /**
   * RiskDocument findMany
   */
  export type RiskDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentInclude<ExtArgs> | null
    /**
     * Filter, which RiskDocuments to fetch.
     */
    where?: RiskDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskDocuments to fetch.
     */
    orderBy?: RiskDocumentOrderByWithRelationInput | RiskDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskDocuments.
     */
    cursor?: RiskDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskDocuments.
     */
    skip?: number
    distinct?: RiskDocumentScalarFieldEnum | RiskDocumentScalarFieldEnum[]
  }

  /**
   * RiskDocument create
   */
  export type RiskDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskDocument.
     */
    data: XOR<RiskDocumentCreateInput, RiskDocumentUncheckedCreateInput>
  }

  /**
   * RiskDocument createMany
   */
  export type RiskDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskDocuments.
     */
    data: RiskDocumentCreateManyInput | RiskDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskDocument createManyAndReturn
   */
  export type RiskDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many RiskDocuments.
     */
    data: RiskDocumentCreateManyInput | RiskDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskDocument update
   */
  export type RiskDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskDocument.
     */
    data: XOR<RiskDocumentUpdateInput, RiskDocumentUncheckedUpdateInput>
    /**
     * Choose, which RiskDocument to update.
     */
    where: RiskDocumentWhereUniqueInput
  }

  /**
   * RiskDocument updateMany
   */
  export type RiskDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskDocuments.
     */
    data: XOR<RiskDocumentUpdateManyMutationInput, RiskDocumentUncheckedUpdateManyInput>
    /**
     * Filter which RiskDocuments to update
     */
    where?: RiskDocumentWhereInput
    /**
     * Limit how many RiskDocuments to update.
     */
    limit?: number
  }

  /**
   * RiskDocument updateManyAndReturn
   */
  export type RiskDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * The data used to update RiskDocuments.
     */
    data: XOR<RiskDocumentUpdateManyMutationInput, RiskDocumentUncheckedUpdateManyInput>
    /**
     * Filter which RiskDocuments to update
     */
    where?: RiskDocumentWhereInput
    /**
     * Limit how many RiskDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskDocument upsert
   */
  export type RiskDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskDocument to update in case it exists.
     */
    where: RiskDocumentWhereUniqueInput
    /**
     * In case the RiskDocument found by the `where` argument doesn't exist, create a new RiskDocument with this data.
     */
    create: XOR<RiskDocumentCreateInput, RiskDocumentUncheckedCreateInput>
    /**
     * In case the RiskDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskDocumentUpdateInput, RiskDocumentUncheckedUpdateInput>
  }

  /**
   * RiskDocument delete
   */
  export type RiskDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentInclude<ExtArgs> | null
    /**
     * Filter which RiskDocument to delete.
     */
    where: RiskDocumentWhereUniqueInput
  }

  /**
   * RiskDocument deleteMany
   */
  export type RiskDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskDocuments to delete
     */
    where?: RiskDocumentWhereInput
    /**
     * Limit how many RiskDocuments to delete.
     */
    limit?: number
  }

  /**
   * RiskDocument without action
   */
  export type RiskDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDocument
     */
    select?: RiskDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDocument
     */
    omit?: RiskDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskDocumentInclude<ExtArgs> | null
  }


  /**
   * Model StripeActivity
   */

  export type AggregateStripeActivity = {
    _count: StripeActivityCountAggregateOutputType | null
    _avg: StripeActivityAvgAggregateOutputType | null
    _sum: StripeActivitySumAggregateOutputType | null
    _min: StripeActivityMinAggregateOutputType | null
    _max: StripeActivityMaxAggregateOutputType | null
  }

  export type StripeActivityAvgAggregateOutputType = {
    amount: number | null
    govFeeRefund: Decimal | null
    serviceFeeRefund: Decimal | null
  }

  export type StripeActivitySumAggregateOutputType = {
    amount: number | null
    govFeeRefund: Decimal | null
    serviceFeeRefund: Decimal | null
  }

  export type StripeActivityMinAggregateOutputType = {
    id: string | null
    title: string | null
    amount: number | null
    createdAt: Date | null
    status: string | null
    type: string | null
    applicationId: string | null
    description: string | null
    timestamp: Date | null
    transactionId: string | null
    govFeeRefund: Decimal | null
    serviceFeeRefund: Decimal | null
    originalTransactionId: string | null
  }

  export type StripeActivityMaxAggregateOutputType = {
    id: string | null
    title: string | null
    amount: number | null
    createdAt: Date | null
    status: string | null
    type: string | null
    applicationId: string | null
    description: string | null
    timestamp: Date | null
    transactionId: string | null
    govFeeRefund: Decimal | null
    serviceFeeRefund: Decimal | null
    originalTransactionId: string | null
  }

  export type StripeActivityCountAggregateOutputType = {
    id: number
    title: number
    amount: number
    createdAt: number
    status: number
    type: number
    applicationId: number
    description: number
    timestamp: number
    transactionId: number
    govFeeRefund: number
    serviceFeeRefund: number
    originalTransactionId: number
    _all: number
  }


  export type StripeActivityAvgAggregateInputType = {
    amount?: true
    govFeeRefund?: true
    serviceFeeRefund?: true
  }

  export type StripeActivitySumAggregateInputType = {
    amount?: true
    govFeeRefund?: true
    serviceFeeRefund?: true
  }

  export type StripeActivityMinAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    createdAt?: true
    status?: true
    type?: true
    applicationId?: true
    description?: true
    timestamp?: true
    transactionId?: true
    govFeeRefund?: true
    serviceFeeRefund?: true
    originalTransactionId?: true
  }

  export type StripeActivityMaxAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    createdAt?: true
    status?: true
    type?: true
    applicationId?: true
    description?: true
    timestamp?: true
    transactionId?: true
    govFeeRefund?: true
    serviceFeeRefund?: true
    originalTransactionId?: true
  }

  export type StripeActivityCountAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    createdAt?: true
    status?: true
    type?: true
    applicationId?: true
    description?: true
    timestamp?: true
    transactionId?: true
    govFeeRefund?: true
    serviceFeeRefund?: true
    originalTransactionId?: true
    _all?: true
  }

  export type StripeActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeActivity to aggregate.
     */
    where?: StripeActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeActivities to fetch.
     */
    orderBy?: StripeActivityOrderByWithRelationInput | StripeActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StripeActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StripeActivities
    **/
    _count?: true | StripeActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StripeActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StripeActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StripeActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StripeActivityMaxAggregateInputType
  }

  export type GetStripeActivityAggregateType<T extends StripeActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateStripeActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStripeActivity[P]>
      : GetScalarType<T[P], AggregateStripeActivity[P]>
  }




  export type StripeActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeActivityWhereInput
    orderBy?: StripeActivityOrderByWithAggregationInput | StripeActivityOrderByWithAggregationInput[]
    by: StripeActivityScalarFieldEnum[] | StripeActivityScalarFieldEnum
    having?: StripeActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StripeActivityCountAggregateInputType | true
    _avg?: StripeActivityAvgAggregateInputType
    _sum?: StripeActivitySumAggregateInputType
    _min?: StripeActivityMinAggregateInputType
    _max?: StripeActivityMaxAggregateInputType
  }

  export type StripeActivityGroupByOutputType = {
    id: string
    title: string | null
    amount: number | null
    createdAt: Date
    status: string | null
    type: string | null
    applicationId: string | null
    description: string | null
    timestamp: Date | null
    transactionId: string | null
    govFeeRefund: Decimal | null
    serviceFeeRefund: Decimal | null
    originalTransactionId: string | null
    _count: StripeActivityCountAggregateOutputType | null
    _avg: StripeActivityAvgAggregateOutputType | null
    _sum: StripeActivitySumAggregateOutputType | null
    _min: StripeActivityMinAggregateOutputType | null
    _max: StripeActivityMaxAggregateOutputType | null
  }

  type GetStripeActivityGroupByPayload<T extends StripeActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StripeActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StripeActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StripeActivityGroupByOutputType[P]>
            : GetScalarType<T[P], StripeActivityGroupByOutputType[P]>
        }
      >
    >


  export type StripeActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    amount?: boolean
    createdAt?: boolean
    status?: boolean
    type?: boolean
    applicationId?: boolean
    description?: boolean
    timestamp?: boolean
    transactionId?: boolean
    govFeeRefund?: boolean
    serviceFeeRefund?: boolean
    originalTransactionId?: boolean
    Application?: boolean | StripeActivity$ApplicationArgs<ExtArgs>
  }, ExtArgs["result"]["stripeActivity"]>

  export type StripeActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    amount?: boolean
    createdAt?: boolean
    status?: boolean
    type?: boolean
    applicationId?: boolean
    description?: boolean
    timestamp?: boolean
    transactionId?: boolean
    govFeeRefund?: boolean
    serviceFeeRefund?: boolean
    originalTransactionId?: boolean
    Application?: boolean | StripeActivity$ApplicationArgs<ExtArgs>
  }, ExtArgs["result"]["stripeActivity"]>

  export type StripeActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    amount?: boolean
    createdAt?: boolean
    status?: boolean
    type?: boolean
    applicationId?: boolean
    description?: boolean
    timestamp?: boolean
    transactionId?: boolean
    govFeeRefund?: boolean
    serviceFeeRefund?: boolean
    originalTransactionId?: boolean
    Application?: boolean | StripeActivity$ApplicationArgs<ExtArgs>
  }, ExtArgs["result"]["stripeActivity"]>

  export type StripeActivitySelectScalar = {
    id?: boolean
    title?: boolean
    amount?: boolean
    createdAt?: boolean
    status?: boolean
    type?: boolean
    applicationId?: boolean
    description?: boolean
    timestamp?: boolean
    transactionId?: boolean
    govFeeRefund?: boolean
    serviceFeeRefund?: boolean
    originalTransactionId?: boolean
  }

  export type StripeActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "amount" | "createdAt" | "status" | "type" | "applicationId" | "description" | "timestamp" | "transactionId" | "govFeeRefund" | "serviceFeeRefund" | "originalTransactionId", ExtArgs["result"]["stripeActivity"]>
  export type StripeActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | StripeActivity$ApplicationArgs<ExtArgs>
  }
  export type StripeActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | StripeActivity$ApplicationArgs<ExtArgs>
  }
  export type StripeActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | StripeActivity$ApplicationArgs<ExtArgs>
  }

  export type $StripeActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StripeActivity"
    objects: {
      Application: Prisma.$ApplicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      amount: number | null
      createdAt: Date
      status: string | null
      type: string | null
      applicationId: string | null
      description: string | null
      timestamp: Date | null
      transactionId: string | null
      govFeeRefund: Prisma.Decimal | null
      serviceFeeRefund: Prisma.Decimal | null
      originalTransactionId: string | null
    }, ExtArgs["result"]["stripeActivity"]>
    composites: {}
  }

  type StripeActivityGetPayload<S extends boolean | null | undefined | StripeActivityDefaultArgs> = $Result.GetResult<Prisma.$StripeActivityPayload, S>

  type StripeActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StripeActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StripeActivityCountAggregateInputType | true
    }

  export interface StripeActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StripeActivity'], meta: { name: 'StripeActivity' } }
    /**
     * Find zero or one StripeActivity that matches the filter.
     * @param {StripeActivityFindUniqueArgs} args - Arguments to find a StripeActivity
     * @example
     * // Get one StripeActivity
     * const stripeActivity = await prisma.stripeActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StripeActivityFindUniqueArgs>(args: SelectSubset<T, StripeActivityFindUniqueArgs<ExtArgs>>): Prisma__StripeActivityClient<$Result.GetResult<Prisma.$StripeActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StripeActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StripeActivityFindUniqueOrThrowArgs} args - Arguments to find a StripeActivity
     * @example
     * // Get one StripeActivity
     * const stripeActivity = await prisma.stripeActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StripeActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, StripeActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StripeActivityClient<$Result.GetResult<Prisma.$StripeActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StripeActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeActivityFindFirstArgs} args - Arguments to find a StripeActivity
     * @example
     * // Get one StripeActivity
     * const stripeActivity = await prisma.stripeActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StripeActivityFindFirstArgs>(args?: SelectSubset<T, StripeActivityFindFirstArgs<ExtArgs>>): Prisma__StripeActivityClient<$Result.GetResult<Prisma.$StripeActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StripeActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeActivityFindFirstOrThrowArgs} args - Arguments to find a StripeActivity
     * @example
     * // Get one StripeActivity
     * const stripeActivity = await prisma.stripeActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StripeActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, StripeActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__StripeActivityClient<$Result.GetResult<Prisma.$StripeActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StripeActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StripeActivities
     * const stripeActivities = await prisma.stripeActivity.findMany()
     * 
     * // Get first 10 StripeActivities
     * const stripeActivities = await prisma.stripeActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stripeActivityWithIdOnly = await prisma.stripeActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StripeActivityFindManyArgs>(args?: SelectSubset<T, StripeActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StripeActivity.
     * @param {StripeActivityCreateArgs} args - Arguments to create a StripeActivity.
     * @example
     * // Create one StripeActivity
     * const StripeActivity = await prisma.stripeActivity.create({
     *   data: {
     *     // ... data to create a StripeActivity
     *   }
     * })
     * 
     */
    create<T extends StripeActivityCreateArgs>(args: SelectSubset<T, StripeActivityCreateArgs<ExtArgs>>): Prisma__StripeActivityClient<$Result.GetResult<Prisma.$StripeActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StripeActivities.
     * @param {StripeActivityCreateManyArgs} args - Arguments to create many StripeActivities.
     * @example
     * // Create many StripeActivities
     * const stripeActivity = await prisma.stripeActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StripeActivityCreateManyArgs>(args?: SelectSubset<T, StripeActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StripeActivities and returns the data saved in the database.
     * @param {StripeActivityCreateManyAndReturnArgs} args - Arguments to create many StripeActivities.
     * @example
     * // Create many StripeActivities
     * const stripeActivity = await prisma.stripeActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StripeActivities and only return the `id`
     * const stripeActivityWithIdOnly = await prisma.stripeActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StripeActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, StripeActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StripeActivity.
     * @param {StripeActivityDeleteArgs} args - Arguments to delete one StripeActivity.
     * @example
     * // Delete one StripeActivity
     * const StripeActivity = await prisma.stripeActivity.delete({
     *   where: {
     *     // ... filter to delete one StripeActivity
     *   }
     * })
     * 
     */
    delete<T extends StripeActivityDeleteArgs>(args: SelectSubset<T, StripeActivityDeleteArgs<ExtArgs>>): Prisma__StripeActivityClient<$Result.GetResult<Prisma.$StripeActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StripeActivity.
     * @param {StripeActivityUpdateArgs} args - Arguments to update one StripeActivity.
     * @example
     * // Update one StripeActivity
     * const stripeActivity = await prisma.stripeActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StripeActivityUpdateArgs>(args: SelectSubset<T, StripeActivityUpdateArgs<ExtArgs>>): Prisma__StripeActivityClient<$Result.GetResult<Prisma.$StripeActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StripeActivities.
     * @param {StripeActivityDeleteManyArgs} args - Arguments to filter StripeActivities to delete.
     * @example
     * // Delete a few StripeActivities
     * const { count } = await prisma.stripeActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StripeActivityDeleteManyArgs>(args?: SelectSubset<T, StripeActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StripeActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StripeActivities
     * const stripeActivity = await prisma.stripeActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StripeActivityUpdateManyArgs>(args: SelectSubset<T, StripeActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StripeActivities and returns the data updated in the database.
     * @param {StripeActivityUpdateManyAndReturnArgs} args - Arguments to update many StripeActivities.
     * @example
     * // Update many StripeActivities
     * const stripeActivity = await prisma.stripeActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StripeActivities and only return the `id`
     * const stripeActivityWithIdOnly = await prisma.stripeActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StripeActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, StripeActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StripeActivity.
     * @param {StripeActivityUpsertArgs} args - Arguments to update or create a StripeActivity.
     * @example
     * // Update or create a StripeActivity
     * const stripeActivity = await prisma.stripeActivity.upsert({
     *   create: {
     *     // ... data to create a StripeActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StripeActivity we want to update
     *   }
     * })
     */
    upsert<T extends StripeActivityUpsertArgs>(args: SelectSubset<T, StripeActivityUpsertArgs<ExtArgs>>): Prisma__StripeActivityClient<$Result.GetResult<Prisma.$StripeActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StripeActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeActivityCountArgs} args - Arguments to filter StripeActivities to count.
     * @example
     * // Count the number of StripeActivities
     * const count = await prisma.stripeActivity.count({
     *   where: {
     *     // ... the filter for the StripeActivities we want to count
     *   }
     * })
    **/
    count<T extends StripeActivityCountArgs>(
      args?: Subset<T, StripeActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StripeActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StripeActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StripeActivityAggregateArgs>(args: Subset<T, StripeActivityAggregateArgs>): Prisma.PrismaPromise<GetStripeActivityAggregateType<T>>

    /**
     * Group by StripeActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StripeActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StripeActivityGroupByArgs['orderBy'] }
        : { orderBy?: StripeActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StripeActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStripeActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StripeActivity model
   */
  readonly fields: StripeActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StripeActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StripeActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Application<T extends StripeActivity$ApplicationArgs<ExtArgs> = {}>(args?: Subset<T, StripeActivity$ApplicationArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StripeActivity model
   */
  interface StripeActivityFieldRefs {
    readonly id: FieldRef<"StripeActivity", 'String'>
    readonly title: FieldRef<"StripeActivity", 'String'>
    readonly amount: FieldRef<"StripeActivity", 'Float'>
    readonly createdAt: FieldRef<"StripeActivity", 'DateTime'>
    readonly status: FieldRef<"StripeActivity", 'String'>
    readonly type: FieldRef<"StripeActivity", 'String'>
    readonly applicationId: FieldRef<"StripeActivity", 'String'>
    readonly description: FieldRef<"StripeActivity", 'String'>
    readonly timestamp: FieldRef<"StripeActivity", 'DateTime'>
    readonly transactionId: FieldRef<"StripeActivity", 'String'>
    readonly govFeeRefund: FieldRef<"StripeActivity", 'Decimal'>
    readonly serviceFeeRefund: FieldRef<"StripeActivity", 'Decimal'>
    readonly originalTransactionId: FieldRef<"StripeActivity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StripeActivity findUnique
   */
  export type StripeActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityInclude<ExtArgs> | null
    /**
     * Filter, which StripeActivity to fetch.
     */
    where: StripeActivityWhereUniqueInput
  }

  /**
   * StripeActivity findUniqueOrThrow
   */
  export type StripeActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityInclude<ExtArgs> | null
    /**
     * Filter, which StripeActivity to fetch.
     */
    where: StripeActivityWhereUniqueInput
  }

  /**
   * StripeActivity findFirst
   */
  export type StripeActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityInclude<ExtArgs> | null
    /**
     * Filter, which StripeActivity to fetch.
     */
    where?: StripeActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeActivities to fetch.
     */
    orderBy?: StripeActivityOrderByWithRelationInput | StripeActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeActivities.
     */
    cursor?: StripeActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeActivities.
     */
    distinct?: StripeActivityScalarFieldEnum | StripeActivityScalarFieldEnum[]
  }

  /**
   * StripeActivity findFirstOrThrow
   */
  export type StripeActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityInclude<ExtArgs> | null
    /**
     * Filter, which StripeActivity to fetch.
     */
    where?: StripeActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeActivities to fetch.
     */
    orderBy?: StripeActivityOrderByWithRelationInput | StripeActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeActivities.
     */
    cursor?: StripeActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeActivities.
     */
    distinct?: StripeActivityScalarFieldEnum | StripeActivityScalarFieldEnum[]
  }

  /**
   * StripeActivity findMany
   */
  export type StripeActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityInclude<ExtArgs> | null
    /**
     * Filter, which StripeActivities to fetch.
     */
    where?: StripeActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeActivities to fetch.
     */
    orderBy?: StripeActivityOrderByWithRelationInput | StripeActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StripeActivities.
     */
    cursor?: StripeActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeActivities.
     */
    skip?: number
    distinct?: StripeActivityScalarFieldEnum | StripeActivityScalarFieldEnum[]
  }

  /**
   * StripeActivity create
   */
  export type StripeActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a StripeActivity.
     */
    data: XOR<StripeActivityCreateInput, StripeActivityUncheckedCreateInput>
  }

  /**
   * StripeActivity createMany
   */
  export type StripeActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StripeActivities.
     */
    data: StripeActivityCreateManyInput | StripeActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StripeActivity createManyAndReturn
   */
  export type StripeActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * The data used to create many StripeActivities.
     */
    data: StripeActivityCreateManyInput | StripeActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StripeActivity update
   */
  export type StripeActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a StripeActivity.
     */
    data: XOR<StripeActivityUpdateInput, StripeActivityUncheckedUpdateInput>
    /**
     * Choose, which StripeActivity to update.
     */
    where: StripeActivityWhereUniqueInput
  }

  /**
   * StripeActivity updateMany
   */
  export type StripeActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StripeActivities.
     */
    data: XOR<StripeActivityUpdateManyMutationInput, StripeActivityUncheckedUpdateManyInput>
    /**
     * Filter which StripeActivities to update
     */
    where?: StripeActivityWhereInput
    /**
     * Limit how many StripeActivities to update.
     */
    limit?: number
  }

  /**
   * StripeActivity updateManyAndReturn
   */
  export type StripeActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * The data used to update StripeActivities.
     */
    data: XOR<StripeActivityUpdateManyMutationInput, StripeActivityUncheckedUpdateManyInput>
    /**
     * Filter which StripeActivities to update
     */
    where?: StripeActivityWhereInput
    /**
     * Limit how many StripeActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StripeActivity upsert
   */
  export type StripeActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the StripeActivity to update in case it exists.
     */
    where: StripeActivityWhereUniqueInput
    /**
     * In case the StripeActivity found by the `where` argument doesn't exist, create a new StripeActivity with this data.
     */
    create: XOR<StripeActivityCreateInput, StripeActivityUncheckedCreateInput>
    /**
     * In case the StripeActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StripeActivityUpdateInput, StripeActivityUncheckedUpdateInput>
  }

  /**
   * StripeActivity delete
   */
  export type StripeActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityInclude<ExtArgs> | null
    /**
     * Filter which StripeActivity to delete.
     */
    where: StripeActivityWhereUniqueInput
  }

  /**
   * StripeActivity deleteMany
   */
  export type StripeActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeActivities to delete
     */
    where?: StripeActivityWhereInput
    /**
     * Limit how many StripeActivities to delete.
     */
    limit?: number
  }

  /**
   * StripeActivity.Application
   */
  export type StripeActivity$ApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
  }

  /**
   * StripeActivity without action
   */
  export type StripeActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeActivity
     */
    select?: StripeActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeActivity
     */
    omit?: StripeActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeActivityInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    assignedTo: string | null
    assignedToEmail: string | null
    dueDate: Date | null
    taskType: string | null
    status: string | null
    applicationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    taskId: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    assignedTo: string | null
    assignedToEmail: string | null
    dueDate: Date | null
    taskType: string | null
    status: string | null
    applicationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    taskId: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    assignedTo: number
    assignedToEmail: number
    dueDate: number
    taskType: number
    status: number
    applicationId: number
    createdAt: number
    updatedAt: number
    taskId: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    assignedTo?: true
    assignedToEmail?: true
    dueDate?: true
    taskType?: true
    status?: true
    applicationId?: true
    createdAt?: true
    updatedAt?: true
    taskId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    assignedTo?: true
    assignedToEmail?: true
    dueDate?: true
    taskType?: true
    status?: true
    applicationId?: true
    createdAt?: true
    updatedAt?: true
    taskId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    assignedTo?: true
    assignedToEmail?: true
    dueDate?: true
    taskType?: true
    status?: true
    applicationId?: true
    createdAt?: true
    updatedAt?: true
    taskId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    assignedTo: string | null
    assignedToEmail: string | null
    dueDate: Date | null
    taskType: string | null
    status: string
    applicationId: string
    createdAt: Date
    updatedAt: Date
    taskId: string
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    assignedTo?: boolean
    assignedToEmail?: boolean
    dueDate?: boolean
    taskType?: boolean
    status?: boolean
    applicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taskId?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
    TaskActivity?: boolean | Task$TaskActivityArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    assignedTo?: boolean
    assignedToEmail?: boolean
    dueDate?: boolean
    taskType?: boolean
    status?: boolean
    applicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taskId?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    assignedTo?: boolean
    assignedToEmail?: boolean
    dueDate?: boolean
    taskType?: boolean
    status?: boolean
    applicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taskId?: boolean
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    assignedTo?: boolean
    assignedToEmail?: boolean
    dueDate?: boolean
    taskType?: boolean
    status?: boolean
    applicationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taskId?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "assignedTo" | "assignedToEmail" | "dueDate" | "taskType" | "status" | "applicationId" | "createdAt" | "updatedAt" | "taskId", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
    TaskActivity?: boolean | Task$TaskActivityArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      Application: Prisma.$ApplicationPayload<ExtArgs>
      TaskActivity: Prisma.$TaskActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      assignedTo: string | null
      assignedToEmail: string | null
      dueDate: Date | null
      taskType: string | null
      status: string
      applicationId: string
      createdAt: Date
      updatedAt: Date
      taskId: string
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Application<T extends ApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDefaultArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    TaskActivity<T extends Task$TaskActivityArgs<ExtArgs> = {}>(args?: Subset<T, Task$TaskActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly assignedTo: FieldRef<"Task", 'String'>
    readonly assignedToEmail: FieldRef<"Task", 'String'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly taskType: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'String'>
    readonly applicationId: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly taskId: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.TaskActivity
   */
  export type Task$TaskActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityInclude<ExtArgs> | null
    where?: TaskActivityWhereInput
    orderBy?: TaskActivityOrderByWithRelationInput | TaskActivityOrderByWithRelationInput[]
    cursor?: TaskActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskActivityScalarFieldEnum | TaskActivityScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskActivity
   */

  export type AggregateTaskActivity = {
    _count: TaskActivityCountAggregateOutputType | null
    _min: TaskActivityMinAggregateOutputType | null
    _max: TaskActivityMaxAggregateOutputType | null
  }

  export type TaskActivityMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    status: string | null
    description: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type TaskActivityMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    status: string | null
    description: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type TaskActivityCountAggregateOutputType = {
    id: number
    taskId: number
    status: number
    description: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type TaskActivityMinAggregateInputType = {
    id?: true
    taskId?: true
    status?: true
    description?: true
    timestamp?: true
    createdAt?: true
  }

  export type TaskActivityMaxAggregateInputType = {
    id?: true
    taskId?: true
    status?: true
    description?: true
    timestamp?: true
    createdAt?: true
  }

  export type TaskActivityCountAggregateInputType = {
    id?: true
    taskId?: true
    status?: true
    description?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type TaskActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskActivity to aggregate.
     */
    where?: TaskActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskActivities to fetch.
     */
    orderBy?: TaskActivityOrderByWithRelationInput | TaskActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskActivities
    **/
    _count?: true | TaskActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskActivityMaxAggregateInputType
  }

  export type GetTaskActivityAggregateType<T extends TaskActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskActivity[P]>
      : GetScalarType<T[P], AggregateTaskActivity[P]>
  }




  export type TaskActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskActivityWhereInput
    orderBy?: TaskActivityOrderByWithAggregationInput | TaskActivityOrderByWithAggregationInput[]
    by: TaskActivityScalarFieldEnum[] | TaskActivityScalarFieldEnum
    having?: TaskActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskActivityCountAggregateInputType | true
    _min?: TaskActivityMinAggregateInputType
    _max?: TaskActivityMaxAggregateInputType
  }

  export type TaskActivityGroupByOutputType = {
    id: string
    taskId: string
    status: string
    description: string
    timestamp: Date
    createdAt: Date
    _count: TaskActivityCountAggregateOutputType | null
    _min: TaskActivityMinAggregateOutputType | null
    _max: TaskActivityMaxAggregateOutputType | null
  }

  type GetTaskActivityGroupByPayload<T extends TaskActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskActivityGroupByOutputType[P]>
            : GetScalarType<T[P], TaskActivityGroupByOutputType[P]>
        }
      >
    >


  export type TaskActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    status?: boolean
    description?: boolean
    timestamp?: boolean
    createdAt?: boolean
    Task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskActivity"]>

  export type TaskActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    status?: boolean
    description?: boolean
    timestamp?: boolean
    createdAt?: boolean
    Task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskActivity"]>

  export type TaskActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    status?: boolean
    description?: boolean
    timestamp?: boolean
    createdAt?: boolean
    Task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskActivity"]>

  export type TaskActivitySelectScalar = {
    id?: boolean
    taskId?: boolean
    status?: boolean
    description?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type TaskActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "status" | "description" | "timestamp" | "createdAt", ExtArgs["result"]["taskActivity"]>
  export type TaskActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskActivity"
    objects: {
      Task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      status: string
      description: string
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["taskActivity"]>
    composites: {}
  }

  type TaskActivityGetPayload<S extends boolean | null | undefined | TaskActivityDefaultArgs> = $Result.GetResult<Prisma.$TaskActivityPayload, S>

  type TaskActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskActivityCountAggregateInputType | true
    }

  export interface TaskActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskActivity'], meta: { name: 'TaskActivity' } }
    /**
     * Find zero or one TaskActivity that matches the filter.
     * @param {TaskActivityFindUniqueArgs} args - Arguments to find a TaskActivity
     * @example
     * // Get one TaskActivity
     * const taskActivity = await prisma.taskActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskActivityFindUniqueArgs>(args: SelectSubset<T, TaskActivityFindUniqueArgs<ExtArgs>>): Prisma__TaskActivityClient<$Result.GetResult<Prisma.$TaskActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskActivityFindUniqueOrThrowArgs} args - Arguments to find a TaskActivity
     * @example
     * // Get one TaskActivity
     * const taskActivity = await prisma.taskActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskActivityClient<$Result.GetResult<Prisma.$TaskActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskActivityFindFirstArgs} args - Arguments to find a TaskActivity
     * @example
     * // Get one TaskActivity
     * const taskActivity = await prisma.taskActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskActivityFindFirstArgs>(args?: SelectSubset<T, TaskActivityFindFirstArgs<ExtArgs>>): Prisma__TaskActivityClient<$Result.GetResult<Prisma.$TaskActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskActivityFindFirstOrThrowArgs} args - Arguments to find a TaskActivity
     * @example
     * // Get one TaskActivity
     * const taskActivity = await prisma.taskActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskActivityClient<$Result.GetResult<Prisma.$TaskActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskActivities
     * const taskActivities = await prisma.taskActivity.findMany()
     * 
     * // Get first 10 TaskActivities
     * const taskActivities = await prisma.taskActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskActivityWithIdOnly = await prisma.taskActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskActivityFindManyArgs>(args?: SelectSubset<T, TaskActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskActivity.
     * @param {TaskActivityCreateArgs} args - Arguments to create a TaskActivity.
     * @example
     * // Create one TaskActivity
     * const TaskActivity = await prisma.taskActivity.create({
     *   data: {
     *     // ... data to create a TaskActivity
     *   }
     * })
     * 
     */
    create<T extends TaskActivityCreateArgs>(args: SelectSubset<T, TaskActivityCreateArgs<ExtArgs>>): Prisma__TaskActivityClient<$Result.GetResult<Prisma.$TaskActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskActivities.
     * @param {TaskActivityCreateManyArgs} args - Arguments to create many TaskActivities.
     * @example
     * // Create many TaskActivities
     * const taskActivity = await prisma.taskActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskActivityCreateManyArgs>(args?: SelectSubset<T, TaskActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskActivities and returns the data saved in the database.
     * @param {TaskActivityCreateManyAndReturnArgs} args - Arguments to create many TaskActivities.
     * @example
     * // Create many TaskActivities
     * const taskActivity = await prisma.taskActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskActivities and only return the `id`
     * const taskActivityWithIdOnly = await prisma.taskActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskActivity.
     * @param {TaskActivityDeleteArgs} args - Arguments to delete one TaskActivity.
     * @example
     * // Delete one TaskActivity
     * const TaskActivity = await prisma.taskActivity.delete({
     *   where: {
     *     // ... filter to delete one TaskActivity
     *   }
     * })
     * 
     */
    delete<T extends TaskActivityDeleteArgs>(args: SelectSubset<T, TaskActivityDeleteArgs<ExtArgs>>): Prisma__TaskActivityClient<$Result.GetResult<Prisma.$TaskActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskActivity.
     * @param {TaskActivityUpdateArgs} args - Arguments to update one TaskActivity.
     * @example
     * // Update one TaskActivity
     * const taskActivity = await prisma.taskActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskActivityUpdateArgs>(args: SelectSubset<T, TaskActivityUpdateArgs<ExtArgs>>): Prisma__TaskActivityClient<$Result.GetResult<Prisma.$TaskActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskActivities.
     * @param {TaskActivityDeleteManyArgs} args - Arguments to filter TaskActivities to delete.
     * @example
     * // Delete a few TaskActivities
     * const { count } = await prisma.taskActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskActivityDeleteManyArgs>(args?: SelectSubset<T, TaskActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskActivities
     * const taskActivity = await prisma.taskActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskActivityUpdateManyArgs>(args: SelectSubset<T, TaskActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskActivities and returns the data updated in the database.
     * @param {TaskActivityUpdateManyAndReturnArgs} args - Arguments to update many TaskActivities.
     * @example
     * // Update many TaskActivities
     * const taskActivity = await prisma.taskActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskActivities and only return the `id`
     * const taskActivityWithIdOnly = await prisma.taskActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskActivity.
     * @param {TaskActivityUpsertArgs} args - Arguments to update or create a TaskActivity.
     * @example
     * // Update or create a TaskActivity
     * const taskActivity = await prisma.taskActivity.upsert({
     *   create: {
     *     // ... data to create a TaskActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskActivity we want to update
     *   }
     * })
     */
    upsert<T extends TaskActivityUpsertArgs>(args: SelectSubset<T, TaskActivityUpsertArgs<ExtArgs>>): Prisma__TaskActivityClient<$Result.GetResult<Prisma.$TaskActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskActivityCountArgs} args - Arguments to filter TaskActivities to count.
     * @example
     * // Count the number of TaskActivities
     * const count = await prisma.taskActivity.count({
     *   where: {
     *     // ... the filter for the TaskActivities we want to count
     *   }
     * })
    **/
    count<T extends TaskActivityCountArgs>(
      args?: Subset<T, TaskActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskActivityAggregateArgs>(args: Subset<T, TaskActivityAggregateArgs>): Prisma.PrismaPromise<GetTaskActivityAggregateType<T>>

    /**
     * Group by TaskActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskActivityGroupByArgs['orderBy'] }
        : { orderBy?: TaskActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskActivity model
   */
  readonly fields: TaskActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskActivity model
   */
  interface TaskActivityFieldRefs {
    readonly id: FieldRef<"TaskActivity", 'String'>
    readonly taskId: FieldRef<"TaskActivity", 'String'>
    readonly status: FieldRef<"TaskActivity", 'String'>
    readonly description: FieldRef<"TaskActivity", 'String'>
    readonly timestamp: FieldRef<"TaskActivity", 'DateTime'>
    readonly createdAt: FieldRef<"TaskActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskActivity findUnique
   */
  export type TaskActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityInclude<ExtArgs> | null
    /**
     * Filter, which TaskActivity to fetch.
     */
    where: TaskActivityWhereUniqueInput
  }

  /**
   * TaskActivity findUniqueOrThrow
   */
  export type TaskActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityInclude<ExtArgs> | null
    /**
     * Filter, which TaskActivity to fetch.
     */
    where: TaskActivityWhereUniqueInput
  }

  /**
   * TaskActivity findFirst
   */
  export type TaskActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityInclude<ExtArgs> | null
    /**
     * Filter, which TaskActivity to fetch.
     */
    where?: TaskActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskActivities to fetch.
     */
    orderBy?: TaskActivityOrderByWithRelationInput | TaskActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskActivities.
     */
    cursor?: TaskActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskActivities.
     */
    distinct?: TaskActivityScalarFieldEnum | TaskActivityScalarFieldEnum[]
  }

  /**
   * TaskActivity findFirstOrThrow
   */
  export type TaskActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityInclude<ExtArgs> | null
    /**
     * Filter, which TaskActivity to fetch.
     */
    where?: TaskActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskActivities to fetch.
     */
    orderBy?: TaskActivityOrderByWithRelationInput | TaskActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskActivities.
     */
    cursor?: TaskActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskActivities.
     */
    distinct?: TaskActivityScalarFieldEnum | TaskActivityScalarFieldEnum[]
  }

  /**
   * TaskActivity findMany
   */
  export type TaskActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityInclude<ExtArgs> | null
    /**
     * Filter, which TaskActivities to fetch.
     */
    where?: TaskActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskActivities to fetch.
     */
    orderBy?: TaskActivityOrderByWithRelationInput | TaskActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskActivities.
     */
    cursor?: TaskActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskActivities.
     */
    skip?: number
    distinct?: TaskActivityScalarFieldEnum | TaskActivityScalarFieldEnum[]
  }

  /**
   * TaskActivity create
   */
  export type TaskActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskActivity.
     */
    data: XOR<TaskActivityCreateInput, TaskActivityUncheckedCreateInput>
  }

  /**
   * TaskActivity createMany
   */
  export type TaskActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskActivities.
     */
    data: TaskActivityCreateManyInput | TaskActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskActivity createManyAndReturn
   */
  export type TaskActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * The data used to create many TaskActivities.
     */
    data: TaskActivityCreateManyInput | TaskActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskActivity update
   */
  export type TaskActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskActivity.
     */
    data: XOR<TaskActivityUpdateInput, TaskActivityUncheckedUpdateInput>
    /**
     * Choose, which TaskActivity to update.
     */
    where: TaskActivityWhereUniqueInput
  }

  /**
   * TaskActivity updateMany
   */
  export type TaskActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskActivities.
     */
    data: XOR<TaskActivityUpdateManyMutationInput, TaskActivityUncheckedUpdateManyInput>
    /**
     * Filter which TaskActivities to update
     */
    where?: TaskActivityWhereInput
    /**
     * Limit how many TaskActivities to update.
     */
    limit?: number
  }

  /**
   * TaskActivity updateManyAndReturn
   */
  export type TaskActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * The data used to update TaskActivities.
     */
    data: XOR<TaskActivityUpdateManyMutationInput, TaskActivityUncheckedUpdateManyInput>
    /**
     * Filter which TaskActivities to update
     */
    where?: TaskActivityWhereInput
    /**
     * Limit how many TaskActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskActivity upsert
   */
  export type TaskActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskActivity to update in case it exists.
     */
    where: TaskActivityWhereUniqueInput
    /**
     * In case the TaskActivity found by the `where` argument doesn't exist, create a new TaskActivity with this data.
     */
    create: XOR<TaskActivityCreateInput, TaskActivityUncheckedCreateInput>
    /**
     * In case the TaskActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskActivityUpdateInput, TaskActivityUncheckedUpdateInput>
  }

  /**
   * TaskActivity delete
   */
  export type TaskActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityInclude<ExtArgs> | null
    /**
     * Filter which TaskActivity to delete.
     */
    where: TaskActivityWhereUniqueInput
  }

  /**
   * TaskActivity deleteMany
   */
  export type TaskActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskActivities to delete
     */
    where?: TaskActivityWhereInput
    /**
     * Limit how many TaskActivities to delete.
     */
    limit?: number
  }

  /**
   * TaskActivity without action
   */
  export type TaskActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskActivity
     */
    select?: TaskActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskActivity
     */
    omit?: TaskActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskActivityInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    role: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    role: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    role: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "role", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      role: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model VisaType
   */

  export type AggregateVisaType = {
    _count: VisaTypeCountAggregateOutputType | null
    _avg: VisaTypeAvgAggregateOutputType | null
    _sum: VisaTypeSumAggregateOutputType | null
    _min: VisaTypeMinAggregateOutputType | null
    _max: VisaTypeMaxAggregateOutputType | null
  }

  export type VisaTypeAvgAggregateOutputType = {
    fees: number | null
  }

  export type VisaTypeSumAggregateOutputType = {
    fees: number | null
  }

  export type VisaTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    waitTime: string | null
    fees: number | null
    requiredDocuments: string | null
    destinationId: string | null
  }

  export type VisaTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    waitTime: string | null
    fees: number | null
    requiredDocuments: string | null
    destinationId: string | null
  }

  export type VisaTypeCountAggregateOutputType = {
    id: number
    name: number
    waitTime: number
    fees: number
    requiredDocuments: number
    allowedNationalities: number
    destinationId: number
    _all: number
  }


  export type VisaTypeAvgAggregateInputType = {
    fees?: true
  }

  export type VisaTypeSumAggregateInputType = {
    fees?: true
  }

  export type VisaTypeMinAggregateInputType = {
    id?: true
    name?: true
    waitTime?: true
    fees?: true
    requiredDocuments?: true
    destinationId?: true
  }

  export type VisaTypeMaxAggregateInputType = {
    id?: true
    name?: true
    waitTime?: true
    fees?: true
    requiredDocuments?: true
    destinationId?: true
  }

  export type VisaTypeCountAggregateInputType = {
    id?: true
    name?: true
    waitTime?: true
    fees?: true
    requiredDocuments?: true
    allowedNationalities?: true
    destinationId?: true
    _all?: true
  }

  export type VisaTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisaType to aggregate.
     */
    where?: VisaTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisaTypes to fetch.
     */
    orderBy?: VisaTypeOrderByWithRelationInput | VisaTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisaTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisaTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisaTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisaTypes
    **/
    _count?: true | VisaTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisaTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisaTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisaTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisaTypeMaxAggregateInputType
  }

  export type GetVisaTypeAggregateType<T extends VisaTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateVisaType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisaType[P]>
      : GetScalarType<T[P], AggregateVisaType[P]>
  }




  export type VisaTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisaTypeWhereInput
    orderBy?: VisaTypeOrderByWithAggregationInput | VisaTypeOrderByWithAggregationInput[]
    by: VisaTypeScalarFieldEnum[] | VisaTypeScalarFieldEnum
    having?: VisaTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisaTypeCountAggregateInputType | true
    _avg?: VisaTypeAvgAggregateInputType
    _sum?: VisaTypeSumAggregateInputType
    _min?: VisaTypeMinAggregateInputType
    _max?: VisaTypeMaxAggregateInputType
  }

  export type VisaTypeGroupByOutputType = {
    id: string
    name: string
    waitTime: string | null
    fees: number | null
    requiredDocuments: string | null
    allowedNationalities: JsonValue | null
    destinationId: string
    _count: VisaTypeCountAggregateOutputType | null
    _avg: VisaTypeAvgAggregateOutputType | null
    _sum: VisaTypeSumAggregateOutputType | null
    _min: VisaTypeMinAggregateOutputType | null
    _max: VisaTypeMaxAggregateOutputType | null
  }

  type GetVisaTypeGroupByPayload<T extends VisaTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisaTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisaTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisaTypeGroupByOutputType[P]>
            : GetScalarType<T[P], VisaTypeGroupByOutputType[P]>
        }
      >
    >


  export type VisaTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    waitTime?: boolean
    fees?: boolean
    requiredDocuments?: boolean
    allowedNationalities?: boolean
    destinationId?: boolean
    Application?: boolean | VisaType$ApplicationArgs<ExtArgs>
    Destination?: boolean | DestinationDefaultArgs<ExtArgs>
    _count?: boolean | VisaTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visaType"]>

  export type VisaTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    waitTime?: boolean
    fees?: boolean
    requiredDocuments?: boolean
    allowedNationalities?: boolean
    destinationId?: boolean
    Destination?: boolean | DestinationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visaType"]>

  export type VisaTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    waitTime?: boolean
    fees?: boolean
    requiredDocuments?: boolean
    allowedNationalities?: boolean
    destinationId?: boolean
    Destination?: boolean | DestinationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visaType"]>

  export type VisaTypeSelectScalar = {
    id?: boolean
    name?: boolean
    waitTime?: boolean
    fees?: boolean
    requiredDocuments?: boolean
    allowedNationalities?: boolean
    destinationId?: boolean
  }

  export type VisaTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "waitTime" | "fees" | "requiredDocuments" | "allowedNationalities" | "destinationId", ExtArgs["result"]["visaType"]>
  export type VisaTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Application?: boolean | VisaType$ApplicationArgs<ExtArgs>
    Destination?: boolean | DestinationDefaultArgs<ExtArgs>
    _count?: boolean | VisaTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VisaTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Destination?: boolean | DestinationDefaultArgs<ExtArgs>
  }
  export type VisaTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Destination?: boolean | DestinationDefaultArgs<ExtArgs>
  }

  export type $VisaTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisaType"
    objects: {
      Application: Prisma.$ApplicationPayload<ExtArgs>[]
      Destination: Prisma.$DestinationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      waitTime: string | null
      fees: number | null
      requiredDocuments: string | null
      allowedNationalities: Prisma.JsonValue | null
      destinationId: string
    }, ExtArgs["result"]["visaType"]>
    composites: {}
  }

  type VisaTypeGetPayload<S extends boolean | null | undefined | VisaTypeDefaultArgs> = $Result.GetResult<Prisma.$VisaTypePayload, S>

  type VisaTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisaTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisaTypeCountAggregateInputType | true
    }

  export interface VisaTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisaType'], meta: { name: 'VisaType' } }
    /**
     * Find zero or one VisaType that matches the filter.
     * @param {VisaTypeFindUniqueArgs} args - Arguments to find a VisaType
     * @example
     * // Get one VisaType
     * const visaType = await prisma.visaType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisaTypeFindUniqueArgs>(args: SelectSubset<T, VisaTypeFindUniqueArgs<ExtArgs>>): Prisma__VisaTypeClient<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VisaType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisaTypeFindUniqueOrThrowArgs} args - Arguments to find a VisaType
     * @example
     * // Get one VisaType
     * const visaType = await prisma.visaType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisaTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, VisaTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisaTypeClient<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisaType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaTypeFindFirstArgs} args - Arguments to find a VisaType
     * @example
     * // Get one VisaType
     * const visaType = await prisma.visaType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisaTypeFindFirstArgs>(args?: SelectSubset<T, VisaTypeFindFirstArgs<ExtArgs>>): Prisma__VisaTypeClient<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisaType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaTypeFindFirstOrThrowArgs} args - Arguments to find a VisaType
     * @example
     * // Get one VisaType
     * const visaType = await prisma.visaType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisaTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, VisaTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisaTypeClient<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VisaTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisaTypes
     * const visaTypes = await prisma.visaType.findMany()
     * 
     * // Get first 10 VisaTypes
     * const visaTypes = await prisma.visaType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visaTypeWithIdOnly = await prisma.visaType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisaTypeFindManyArgs>(args?: SelectSubset<T, VisaTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VisaType.
     * @param {VisaTypeCreateArgs} args - Arguments to create a VisaType.
     * @example
     * // Create one VisaType
     * const VisaType = await prisma.visaType.create({
     *   data: {
     *     // ... data to create a VisaType
     *   }
     * })
     * 
     */
    create<T extends VisaTypeCreateArgs>(args: SelectSubset<T, VisaTypeCreateArgs<ExtArgs>>): Prisma__VisaTypeClient<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VisaTypes.
     * @param {VisaTypeCreateManyArgs} args - Arguments to create many VisaTypes.
     * @example
     * // Create many VisaTypes
     * const visaType = await prisma.visaType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisaTypeCreateManyArgs>(args?: SelectSubset<T, VisaTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisaTypes and returns the data saved in the database.
     * @param {VisaTypeCreateManyAndReturnArgs} args - Arguments to create many VisaTypes.
     * @example
     * // Create many VisaTypes
     * const visaType = await prisma.visaType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisaTypes and only return the `id`
     * const visaTypeWithIdOnly = await prisma.visaType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisaTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, VisaTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VisaType.
     * @param {VisaTypeDeleteArgs} args - Arguments to delete one VisaType.
     * @example
     * // Delete one VisaType
     * const VisaType = await prisma.visaType.delete({
     *   where: {
     *     // ... filter to delete one VisaType
     *   }
     * })
     * 
     */
    delete<T extends VisaTypeDeleteArgs>(args: SelectSubset<T, VisaTypeDeleteArgs<ExtArgs>>): Prisma__VisaTypeClient<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VisaType.
     * @param {VisaTypeUpdateArgs} args - Arguments to update one VisaType.
     * @example
     * // Update one VisaType
     * const visaType = await prisma.visaType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisaTypeUpdateArgs>(args: SelectSubset<T, VisaTypeUpdateArgs<ExtArgs>>): Prisma__VisaTypeClient<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VisaTypes.
     * @param {VisaTypeDeleteManyArgs} args - Arguments to filter VisaTypes to delete.
     * @example
     * // Delete a few VisaTypes
     * const { count } = await prisma.visaType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisaTypeDeleteManyArgs>(args?: SelectSubset<T, VisaTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisaTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisaTypes
     * const visaType = await prisma.visaType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisaTypeUpdateManyArgs>(args: SelectSubset<T, VisaTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisaTypes and returns the data updated in the database.
     * @param {VisaTypeUpdateManyAndReturnArgs} args - Arguments to update many VisaTypes.
     * @example
     * // Update many VisaTypes
     * const visaType = await prisma.visaType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VisaTypes and only return the `id`
     * const visaTypeWithIdOnly = await prisma.visaType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VisaTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, VisaTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VisaType.
     * @param {VisaTypeUpsertArgs} args - Arguments to update or create a VisaType.
     * @example
     * // Update or create a VisaType
     * const visaType = await prisma.visaType.upsert({
     *   create: {
     *     // ... data to create a VisaType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisaType we want to update
     *   }
     * })
     */
    upsert<T extends VisaTypeUpsertArgs>(args: SelectSubset<T, VisaTypeUpsertArgs<ExtArgs>>): Prisma__VisaTypeClient<$Result.GetResult<Prisma.$VisaTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VisaTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaTypeCountArgs} args - Arguments to filter VisaTypes to count.
     * @example
     * // Count the number of VisaTypes
     * const count = await prisma.visaType.count({
     *   where: {
     *     // ... the filter for the VisaTypes we want to count
     *   }
     * })
    **/
    count<T extends VisaTypeCountArgs>(
      args?: Subset<T, VisaTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisaTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisaType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisaTypeAggregateArgs>(args: Subset<T, VisaTypeAggregateArgs>): Prisma.PrismaPromise<GetVisaTypeAggregateType<T>>

    /**
     * Group by VisaType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisaTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisaTypeGroupByArgs['orderBy'] }
        : { orderBy?: VisaTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisaTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisaTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisaType model
   */
  readonly fields: VisaTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisaType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisaTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Application<T extends VisaType$ApplicationArgs<ExtArgs> = {}>(args?: Subset<T, VisaType$ApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Destination<T extends DestinationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DestinationDefaultArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisaType model
   */
  interface VisaTypeFieldRefs {
    readonly id: FieldRef<"VisaType", 'String'>
    readonly name: FieldRef<"VisaType", 'String'>
    readonly waitTime: FieldRef<"VisaType", 'String'>
    readonly fees: FieldRef<"VisaType", 'Float'>
    readonly requiredDocuments: FieldRef<"VisaType", 'String'>
    readonly allowedNationalities: FieldRef<"VisaType", 'Json'>
    readonly destinationId: FieldRef<"VisaType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VisaType findUnique
   */
  export type VisaTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisaType to fetch.
     */
    where: VisaTypeWhereUniqueInput
  }

  /**
   * VisaType findUniqueOrThrow
   */
  export type VisaTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisaType to fetch.
     */
    where: VisaTypeWhereUniqueInput
  }

  /**
   * VisaType findFirst
   */
  export type VisaTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisaType to fetch.
     */
    where?: VisaTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisaTypes to fetch.
     */
    orderBy?: VisaTypeOrderByWithRelationInput | VisaTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisaTypes.
     */
    cursor?: VisaTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisaTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisaTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisaTypes.
     */
    distinct?: VisaTypeScalarFieldEnum | VisaTypeScalarFieldEnum[]
  }

  /**
   * VisaType findFirstOrThrow
   */
  export type VisaTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisaType to fetch.
     */
    where?: VisaTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisaTypes to fetch.
     */
    orderBy?: VisaTypeOrderByWithRelationInput | VisaTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisaTypes.
     */
    cursor?: VisaTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisaTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisaTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisaTypes.
     */
    distinct?: VisaTypeScalarFieldEnum | VisaTypeScalarFieldEnum[]
  }

  /**
   * VisaType findMany
   */
  export type VisaTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeInclude<ExtArgs> | null
    /**
     * Filter, which VisaTypes to fetch.
     */
    where?: VisaTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisaTypes to fetch.
     */
    orderBy?: VisaTypeOrderByWithRelationInput | VisaTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisaTypes.
     */
    cursor?: VisaTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisaTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisaTypes.
     */
    skip?: number
    distinct?: VisaTypeScalarFieldEnum | VisaTypeScalarFieldEnum[]
  }

  /**
   * VisaType create
   */
  export type VisaTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a VisaType.
     */
    data: XOR<VisaTypeCreateInput, VisaTypeUncheckedCreateInput>
  }

  /**
   * VisaType createMany
   */
  export type VisaTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisaTypes.
     */
    data: VisaTypeCreateManyInput | VisaTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisaType createManyAndReturn
   */
  export type VisaTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * The data used to create many VisaTypes.
     */
    data: VisaTypeCreateManyInput | VisaTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisaType update
   */
  export type VisaTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a VisaType.
     */
    data: XOR<VisaTypeUpdateInput, VisaTypeUncheckedUpdateInput>
    /**
     * Choose, which VisaType to update.
     */
    where: VisaTypeWhereUniqueInput
  }

  /**
   * VisaType updateMany
   */
  export type VisaTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisaTypes.
     */
    data: XOR<VisaTypeUpdateManyMutationInput, VisaTypeUncheckedUpdateManyInput>
    /**
     * Filter which VisaTypes to update
     */
    where?: VisaTypeWhereInput
    /**
     * Limit how many VisaTypes to update.
     */
    limit?: number
  }

  /**
   * VisaType updateManyAndReturn
   */
  export type VisaTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * The data used to update VisaTypes.
     */
    data: XOR<VisaTypeUpdateManyMutationInput, VisaTypeUncheckedUpdateManyInput>
    /**
     * Filter which VisaTypes to update
     */
    where?: VisaTypeWhereInput
    /**
     * Limit how many VisaTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisaType upsert
   */
  export type VisaTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the VisaType to update in case it exists.
     */
    where: VisaTypeWhereUniqueInput
    /**
     * In case the VisaType found by the `where` argument doesn't exist, create a new VisaType with this data.
     */
    create: XOR<VisaTypeCreateInput, VisaTypeUncheckedCreateInput>
    /**
     * In case the VisaType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisaTypeUpdateInput, VisaTypeUncheckedUpdateInput>
  }

  /**
   * VisaType delete
   */
  export type VisaTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeInclude<ExtArgs> | null
    /**
     * Filter which VisaType to delete.
     */
    where: VisaTypeWhereUniqueInput
  }

  /**
   * VisaType deleteMany
   */
  export type VisaTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisaTypes to delete
     */
    where?: VisaTypeWhereInput
    /**
     * Limit how many VisaTypes to delete.
     */
    limit?: number
  }

  /**
   * VisaType.Application
   */
  export type VisaType$ApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * VisaType without action
   */
  export type VisaTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaType
     */
    select?: VisaTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaType
     */
    omit?: VisaTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaTypeInclude<ExtArgs> | null
  }


  /**
   * Model password_reset_tokens
   */

  export type AggregatePassword_reset_tokens = {
    _count: Password_reset_tokensCountAggregateOutputType | null
    _min: Password_reset_tokensMinAggregateOutputType | null
    _max: Password_reset_tokensMaxAggregateOutputType | null
  }

  export type Password_reset_tokensMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    token: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type Password_reset_tokensMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    token: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type Password_reset_tokensCountAggregateOutputType = {
    id: number
    accountId: number
    token: number
    expiresAt: number
    used: number
    createdAt: number
    _all: number
  }


  export type Password_reset_tokensMinAggregateInputType = {
    id?: true
    accountId?: true
    token?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type Password_reset_tokensMaxAggregateInputType = {
    id?: true
    accountId?: true
    token?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type Password_reset_tokensCountAggregateInputType = {
    id?: true
    accountId?: true
    token?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    _all?: true
  }

  export type Password_reset_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_reset_tokens to aggregate.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned password_reset_tokens
    **/
    _count?: true | Password_reset_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Password_reset_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Password_reset_tokensMaxAggregateInputType
  }

  export type GetPassword_reset_tokensAggregateType<T extends Password_reset_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword_reset_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword_reset_tokens[P]>
      : GetScalarType<T[P], AggregatePassword_reset_tokens[P]>
  }




  export type password_reset_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: password_reset_tokensWhereInput
    orderBy?: password_reset_tokensOrderByWithAggregationInput | password_reset_tokensOrderByWithAggregationInput[]
    by: Password_reset_tokensScalarFieldEnum[] | Password_reset_tokensScalarFieldEnum
    having?: password_reset_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Password_reset_tokensCountAggregateInputType | true
    _min?: Password_reset_tokensMinAggregateInputType
    _max?: Password_reset_tokensMaxAggregateInputType
  }

  export type Password_reset_tokensGroupByOutputType = {
    id: string
    accountId: string
    token: string
    expiresAt: Date
    used: boolean
    createdAt: Date
    _count: Password_reset_tokensCountAggregateOutputType | null
    _min: Password_reset_tokensMinAggregateOutputType | null
    _max: Password_reset_tokensMaxAggregateOutputType | null
  }

  type GetPassword_reset_tokensGroupByPayload<T extends password_reset_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Password_reset_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Password_reset_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Password_reset_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Password_reset_tokensGroupByOutputType[P]>
        }
      >
    >


  export type password_reset_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    token?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password_reset_tokens"]>

  export type password_reset_tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    token?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password_reset_tokens"]>

  export type password_reset_tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    token?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password_reset_tokens"]>

  export type password_reset_tokensSelectScalar = {
    id?: boolean
    accountId?: boolean
    token?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }

  export type password_reset_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "token" | "expiresAt" | "used" | "createdAt", ExtArgs["result"]["password_reset_tokens"]>
  export type password_reset_tokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type password_reset_tokensIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type password_reset_tokensIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $password_reset_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "password_reset_tokens"
    objects: {
      Account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      token: string
      expiresAt: Date
      used: boolean
      createdAt: Date
    }, ExtArgs["result"]["password_reset_tokens"]>
    composites: {}
  }

  type password_reset_tokensGetPayload<S extends boolean | null | undefined | password_reset_tokensDefaultArgs> = $Result.GetResult<Prisma.$password_reset_tokensPayload, S>

  type password_reset_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<password_reset_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Password_reset_tokensCountAggregateInputType | true
    }

  export interface password_reset_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['password_reset_tokens'], meta: { name: 'password_reset_tokens' } }
    /**
     * Find zero or one Password_reset_tokens that matches the filter.
     * @param {password_reset_tokensFindUniqueArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends password_reset_tokensFindUniqueArgs>(args: SelectSubset<T, password_reset_tokensFindUniqueArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Password_reset_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {password_reset_tokensFindUniqueOrThrowArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends password_reset_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, password_reset_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_reset_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindFirstArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends password_reset_tokensFindFirstArgs>(args?: SelectSubset<T, password_reset_tokensFindFirstArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_reset_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindFirstOrThrowArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends password_reset_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, password_reset_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Password_reset_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findMany()
     * 
     * // Get first 10 Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const password_reset_tokensWithIdOnly = await prisma.password_reset_tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends password_reset_tokensFindManyArgs>(args?: SelectSubset<T, password_reset_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Password_reset_tokens.
     * @param {password_reset_tokensCreateArgs} args - Arguments to create a Password_reset_tokens.
     * @example
     * // Create one Password_reset_tokens
     * const Password_reset_tokens = await prisma.password_reset_tokens.create({
     *   data: {
     *     // ... data to create a Password_reset_tokens
     *   }
     * })
     * 
     */
    create<T extends password_reset_tokensCreateArgs>(args: SelectSubset<T, password_reset_tokensCreateArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Password_reset_tokens.
     * @param {password_reset_tokensCreateManyArgs} args - Arguments to create many Password_reset_tokens.
     * @example
     * // Create many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends password_reset_tokensCreateManyArgs>(args?: SelectSubset<T, password_reset_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Password_reset_tokens and returns the data saved in the database.
     * @param {password_reset_tokensCreateManyAndReturnArgs} args - Arguments to create many Password_reset_tokens.
     * @example
     * // Create many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Password_reset_tokens and only return the `id`
     * const password_reset_tokensWithIdOnly = await prisma.password_reset_tokens.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends password_reset_tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, password_reset_tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Password_reset_tokens.
     * @param {password_reset_tokensDeleteArgs} args - Arguments to delete one Password_reset_tokens.
     * @example
     * // Delete one Password_reset_tokens
     * const Password_reset_tokens = await prisma.password_reset_tokens.delete({
     *   where: {
     *     // ... filter to delete one Password_reset_tokens
     *   }
     * })
     * 
     */
    delete<T extends password_reset_tokensDeleteArgs>(args: SelectSubset<T, password_reset_tokensDeleteArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Password_reset_tokens.
     * @param {password_reset_tokensUpdateArgs} args - Arguments to update one Password_reset_tokens.
     * @example
     * // Update one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends password_reset_tokensUpdateArgs>(args: SelectSubset<T, password_reset_tokensUpdateArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Password_reset_tokens.
     * @param {password_reset_tokensDeleteManyArgs} args - Arguments to filter Password_reset_tokens to delete.
     * @example
     * // Delete a few Password_reset_tokens
     * const { count } = await prisma.password_reset_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends password_reset_tokensDeleteManyArgs>(args?: SelectSubset<T, password_reset_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends password_reset_tokensUpdateManyArgs>(args: SelectSubset<T, password_reset_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_reset_tokens and returns the data updated in the database.
     * @param {password_reset_tokensUpdateManyAndReturnArgs} args - Arguments to update many Password_reset_tokens.
     * @example
     * // Update many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Password_reset_tokens and only return the `id`
     * const password_reset_tokensWithIdOnly = await prisma.password_reset_tokens.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends password_reset_tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, password_reset_tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Password_reset_tokens.
     * @param {password_reset_tokensUpsertArgs} args - Arguments to update or create a Password_reset_tokens.
     * @example
     * // Update or create a Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.upsert({
     *   create: {
     *     // ... data to create a Password_reset_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password_reset_tokens we want to update
     *   }
     * })
     */
    upsert<T extends password_reset_tokensUpsertArgs>(args: SelectSubset<T, password_reset_tokensUpsertArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensCountArgs} args - Arguments to filter Password_reset_tokens to count.
     * @example
     * // Count the number of Password_reset_tokens
     * const count = await prisma.password_reset_tokens.count({
     *   where: {
     *     // ... the filter for the Password_reset_tokens we want to count
     *   }
     * })
    **/
    count<T extends password_reset_tokensCountArgs>(
      args?: Subset<T, password_reset_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Password_reset_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_reset_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Password_reset_tokensAggregateArgs>(args: Subset<T, Password_reset_tokensAggregateArgs>): Prisma.PrismaPromise<GetPassword_reset_tokensAggregateType<T>>

    /**
     * Group by Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends password_reset_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: password_reset_tokensGroupByArgs['orderBy'] }
        : { orderBy?: password_reset_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, password_reset_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassword_reset_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the password_reset_tokens model
   */
  readonly fields: password_reset_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for password_reset_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__password_reset_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the password_reset_tokens model
   */
  interface password_reset_tokensFieldRefs {
    readonly id: FieldRef<"password_reset_tokens", 'String'>
    readonly accountId: FieldRef<"password_reset_tokens", 'String'>
    readonly token: FieldRef<"password_reset_tokens", 'String'>
    readonly expiresAt: FieldRef<"password_reset_tokens", 'DateTime'>
    readonly used: FieldRef<"password_reset_tokens", 'Boolean'>
    readonly createdAt: FieldRef<"password_reset_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * password_reset_tokens findUnique
   */
  export type password_reset_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens findUniqueOrThrow
   */
  export type password_reset_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens findFirst
   */
  export type password_reset_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_reset_tokens.
     */
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens findFirstOrThrow
   */
  export type password_reset_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_reset_tokens.
     */
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens findMany
   */
  export type password_reset_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens create
   */
  export type password_reset_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * The data needed to create a password_reset_tokens.
     */
    data: XOR<password_reset_tokensCreateInput, password_reset_tokensUncheckedCreateInput>
  }

  /**
   * password_reset_tokens createMany
   */
  export type password_reset_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many password_reset_tokens.
     */
    data: password_reset_tokensCreateManyInput | password_reset_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * password_reset_tokens createManyAndReturn
   */
  export type password_reset_tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The data used to create many password_reset_tokens.
     */
    data: password_reset_tokensCreateManyInput | password_reset_tokensCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * password_reset_tokens update
   */
  export type password_reset_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * The data needed to update a password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateInput, password_reset_tokensUncheckedUpdateInput>
    /**
     * Choose, which password_reset_tokens to update.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens updateMany
   */
  export type password_reset_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateManyMutationInput, password_reset_tokensUncheckedUpdateManyInput>
    /**
     * Filter which password_reset_tokens to update
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to update.
     */
    limit?: number
  }

  /**
   * password_reset_tokens updateManyAndReturn
   */
  export type password_reset_tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The data used to update password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateManyMutationInput, password_reset_tokensUncheckedUpdateManyInput>
    /**
     * Filter which password_reset_tokens to update
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * password_reset_tokens upsert
   */
  export type password_reset_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * The filter to search for the password_reset_tokens to update in case it exists.
     */
    where: password_reset_tokensWhereUniqueInput
    /**
     * In case the password_reset_tokens found by the `where` argument doesn't exist, create a new password_reset_tokens with this data.
     */
    create: XOR<password_reset_tokensCreateInput, password_reset_tokensUncheckedCreateInput>
    /**
     * In case the password_reset_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<password_reset_tokensUpdateInput, password_reset_tokensUncheckedUpdateInput>
  }

  /**
   * password_reset_tokens delete
   */
  export type password_reset_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
    /**
     * Filter which password_reset_tokens to delete.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens deleteMany
   */
  export type password_reset_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_reset_tokens to delete
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to delete.
     */
    limit?: number
  }

  /**
   * password_reset_tokens without action
   */
  export type password_reset_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_reset_tokensInclude<ExtArgs> | null
  }


  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    accountId: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionsMinAggregateInputType = {
    id?: true
    accountId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    accountId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    accountId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    id: string
    accountId: string
    token: string
    expiresAt: Date
    createdAt: Date
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectScalar = {
    id?: boolean
    accountId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "token" | "expiresAt" | "createdAt", ExtArgs["result"]["sessions"]>
  export type sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type sessionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {
      Account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      token: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }

  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionsFindUniqueArgs>(args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionsFindFirstArgs>(args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionsFindManyArgs>(args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
     */
    create<T extends sessionsCreateArgs>(args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionsCreateManyArgs>(args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {sessionsCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionsWithIdOnly = await prisma.sessions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
     */
    delete<T extends sessionsDeleteArgs>(args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionsUpdateArgs>(args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionsDeleteManyArgs>(args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionsUpdateManyArgs>(args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {sessionsUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionsWithIdOnly = await prisma.sessions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sessionsUpdateManyAndReturnArgs>(args: SelectSubset<T, sessionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
     */
    upsert<T extends sessionsUpsertArgs>(args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions model
   */
  interface sessionsFieldRefs {
    readonly id: FieldRef<"sessions", 'String'>
    readonly accountId: FieldRef<"sessions", 'String'>
    readonly token: FieldRef<"sessions", 'String'>
    readonly expiresAt: FieldRef<"sessions", 'DateTime'>
    readonly createdAt: FieldRef<"sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }

  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions createManyAndReturn
   */
  export type sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * sessions updateManyAndReturn
   */
  export type sessionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }

  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    fullName: 'fullName',
    areaCode: 'areaCode',
    phoneNumber: 'phoneNumber',
    gender: 'gender',
    password: 'password',
    emailVerified: 'emailVerified',
    websiteCreatedAt: 'websiteCreatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const ApplicationScalarFieldEnum: {
    id: 'id',
    destinationId: 'destinationId',
    visaTypeId: 'visaTypeId',
    status: 'status',
    accountId: 'accountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    applicationId: 'applicationId',
    passengerCount: 'passengerCount',
    stayingEnd: 'stayingEnd',
    stayingStart: 'stayingStart',
    total: 'total',
    cancellationDetails: 'cancellationDetails',
    cancellationReason: 'cancellationReason',
    cancelledAt: 'cancelledAt',
    cancelledBy: 'cancelledBy',
    applyDate: 'applyDate',
    paymentStatus: 'paymentStatus'
  };

  export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


  export const ApplicationDocumentScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    name: 'name',
    type: 'type',
    content: 'content',
    status: 'status',
    uploadedAt: 'uploadedAt',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApplicationDocumentScalarFieldEnum = (typeof ApplicationDocumentScalarFieldEnum)[keyof typeof ApplicationDocumentScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    emailThreadId: 'emailThreadId',
    filename: 'filename',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const CardHolderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cardType: 'cardType',
    cardNumber: 'cardNumber',
    address: 'address',
    zipcode: 'zipcode',
    applicationId: 'applicationId'
  };

  export type CardHolderScalarFieldEnum = (typeof CardHolderScalarFieldEnum)[keyof typeof CardHolderScalarFieldEnum]


  export const CaseScalarFieldEnum: {
    id: 'id',
    gmailThreadId: 'gmailThreadId',
    email: 'email',
    subject: 'subject',
    status: 'status',
    lastUpdate: 'lastUpdate',
    websiteCreatedAt: 'websiteCreatedAt',
    accountId: 'accountId',
    applicationId: 'applicationId',
    assignedTo: 'assignedTo',
    topic: 'topic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CaseScalarFieldEnum = (typeof CaseScalarFieldEnum)[keyof typeof CaseScalarFieldEnum]


  export const CaseSequenceScalarFieldEnum: {
    year: 'year',
    currentSequence: 'currentSequence',
    updatedAt: 'updatedAt'
  };

  export type CaseSequenceScalarFieldEnum = (typeof CaseSequenceScalarFieldEnum)[keyof typeof CaseSequenceScalarFieldEnum]


  export const CustomRequirementScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    passengerId: 'passengerId',
    title: 'title',
    createdAt: 'createdAt'
  };

  export type CustomRequirementScalarFieldEnum = (typeof CustomRequirementScalarFieldEnum)[keyof typeof CustomRequirementScalarFieldEnum]


  export const DestinationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code'
  };

  export type DestinationScalarFieldEnum = (typeof DestinationScalarFieldEnum)[keyof typeof DestinationScalarFieldEnum]


  export const DocumentMappingScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    mappedTo: 'mappedTo',
    isInvalid: 'isInvalid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentMappingScalarFieldEnum = (typeof DocumentMappingScalarFieldEnum)[keyof typeof DocumentMappingScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    body: 'body',
    websiteCreatedAt: 'websiteCreatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const EmailThreadScalarFieldEnum: {
    id: 'id',
    caseId: 'caseId',
    messageId: 'messageId',
    fromEmail: 'fromEmail',
    toEmail: 'toEmail',
    subject: 'subject',
    body: 'body',
    timestamp: 'timestamp',
    direction: 'direction',
    cc: 'cc',
    bcc: 'bcc'
  };

  export type EmailThreadScalarFieldEnum = (typeof EmailThreadScalarFieldEnum)[keyof typeof EmailThreadScalarFieldEnum]


  export const PassengerScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    createdAt: 'createdAt',
    name: 'name',
    passportNumber: 'passportNumber',
    updatedAt: 'updatedAt',
    dateOfBirth: 'dateOfBirth',
    fullName: 'fullName',
    gender: 'gender',
    nationality: 'nationality',
    passportId: 'passportId',
    status: 'status'
  };

  export type PassengerScalarFieldEnum = (typeof PassengerScalarFieldEnum)[keyof typeof PassengerScalarFieldEnum]


  export const RiskScalarFieldEnum: {
    id: 'id',
    status: 'status',
    applicationId: 'applicationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUpdated: 'lastUpdated'
  };

  export type RiskScalarFieldEnum = (typeof RiskScalarFieldEnum)[keyof typeof RiskScalarFieldEnum]


  export const RiskActivityScalarFieldEnum: {
    id: 'id',
    riskId: 'riskId',
    createdAt: 'createdAt',
    description: 'description',
    type: 'type',
    details: 'details',
    timestamp: 'timestamp',
    title: 'title'
  };

  export type RiskActivityScalarFieldEnum = (typeof RiskActivityScalarFieldEnum)[keyof typeof RiskActivityScalarFieldEnum]


  export const RiskDocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    riskId: 'riskId',
    createdAt: 'createdAt',
    status: 'status',
    updatedAt: 'updatedAt',
    type: 'type',
    uploadedAt: 'uploadedAt',
    uploadedBy: 'uploadedBy',
    content: 'content'
  };

  export type RiskDocumentScalarFieldEnum = (typeof RiskDocumentScalarFieldEnum)[keyof typeof RiskDocumentScalarFieldEnum]


  export const StripeActivityScalarFieldEnum: {
    id: 'id',
    title: 'title',
    amount: 'amount',
    createdAt: 'createdAt',
    status: 'status',
    type: 'type',
    applicationId: 'applicationId',
    description: 'description',
    timestamp: 'timestamp',
    transactionId: 'transactionId',
    govFeeRefund: 'govFeeRefund',
    serviceFeeRefund: 'serviceFeeRefund',
    originalTransactionId: 'originalTransactionId'
  };

  export type StripeActivityScalarFieldEnum = (typeof StripeActivityScalarFieldEnum)[keyof typeof StripeActivityScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    assignedTo: 'assignedTo',
    assignedToEmail: 'assignedToEmail',
    dueDate: 'dueDate',
    taskType: 'taskType',
    status: 'status',
    applicationId: 'applicationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    taskId: 'taskId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskActivityScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    status: 'status',
    description: 'description',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type TaskActivityScalarFieldEnum = (typeof TaskActivityScalarFieldEnum)[keyof typeof TaskActivityScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VisaTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    waitTime: 'waitTime',
    fees: 'fees',
    requiredDocuments: 'requiredDocuments',
    allowedNationalities: 'allowedNationalities',
    destinationId: 'destinationId'
  };

  export type VisaTypeScalarFieldEnum = (typeof VisaTypeScalarFieldEnum)[keyof typeof VisaTypeScalarFieldEnum]


  export const Password_reset_tokensScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    token: 'token',
    expiresAt: 'expiresAt',
    used: 'used',
    createdAt: 'createdAt'
  };

  export type Password_reset_tokensScalarFieldEnum = (typeof Password_reset_tokensScalarFieldEnum)[keyof typeof Password_reset_tokensScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    email?: StringFilter<"Account"> | string
    fullName?: StringFilter<"Account"> | string
    areaCode?: StringFilter<"Account"> | string
    phoneNumber?: StringFilter<"Account"> | string
    gender?: StringFilter<"Account"> | string
    password?: StringNullableFilter<"Account"> | string | null
    emailVerified?: BoolFilter<"Account"> | boolean
    websiteCreatedAt?: StringFilter<"Account"> | string
    Application?: ApplicationListRelationFilter
    Case?: CaseListRelationFilter
    password_reset_tokens?: Password_reset_tokensListRelationFilter
    sessions?: SessionsListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    email?: SortOrder
    fullName?: SortOrder
    areaCode?: SortOrder
    phoneNumber?: SortOrder
    gender?: SortOrder
    password?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    websiteCreatedAt?: SortOrder
    Application?: ApplicationOrderByRelationAggregateInput
    Case?: CaseOrderByRelationAggregateInput
    password_reset_tokens?: password_reset_tokensOrderByRelationAggregateInput
    sessions?: sessionsOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email_websiteCreatedAt?: AccountEmailWebsiteCreatedAtCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    email?: StringFilter<"Account"> | string
    fullName?: StringFilter<"Account"> | string
    areaCode?: StringFilter<"Account"> | string
    phoneNumber?: StringFilter<"Account"> | string
    gender?: StringFilter<"Account"> | string
    password?: StringNullableFilter<"Account"> | string | null
    emailVerified?: BoolFilter<"Account"> | boolean
    websiteCreatedAt?: StringFilter<"Account"> | string
    Application?: ApplicationListRelationFilter
    Case?: CaseListRelationFilter
    password_reset_tokens?: Password_reset_tokensListRelationFilter
    sessions?: SessionsListRelationFilter
  }, "id" | "email_websiteCreatedAt">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    email?: SortOrder
    fullName?: SortOrder
    areaCode?: SortOrder
    phoneNumber?: SortOrder
    gender?: SortOrder
    password?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    websiteCreatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    email?: StringWithAggregatesFilter<"Account"> | string
    fullName?: StringWithAggregatesFilter<"Account"> | string
    areaCode?: StringWithAggregatesFilter<"Account"> | string
    phoneNumber?: StringWithAggregatesFilter<"Account"> | string
    gender?: StringWithAggregatesFilter<"Account"> | string
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"Account"> | boolean
    websiteCreatedAt?: StringWithAggregatesFilter<"Account"> | string
  }

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    id?: StringFilter<"Application"> | string
    destinationId?: StringFilter<"Application"> | string
    visaTypeId?: StringFilter<"Application"> | string
    status?: StringFilter<"Application"> | string
    accountId?: StringFilter<"Application"> | string
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    applicationId?: StringFilter<"Application"> | string
    passengerCount?: IntNullableFilter<"Application"> | number | null
    stayingEnd?: DateTimeNullableFilter<"Application"> | Date | string | null
    stayingStart?: DateTimeNullableFilter<"Application"> | Date | string | null
    total?: FloatNullableFilter<"Application"> | number | null
    cancellationDetails?: StringNullableFilter<"Application"> | string | null
    cancellationReason?: StringNullableFilter<"Application"> | string | null
    cancelledAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    cancelledBy?: StringNullableFilter<"Application"> | string | null
    applyDate?: DateTimeNullableFilter<"Application"> | Date | string | null
    paymentStatus?: StringNullableFilter<"Application"> | string | null
    Account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    Destination?: XOR<DestinationScalarRelationFilter, DestinationWhereInput>
    VisaType?: XOR<VisaTypeScalarRelationFilter, VisaTypeWhereInput>
    ApplicationDocument?: ApplicationDocumentListRelationFilter
    CardHolder?: XOR<CardHolderNullableScalarRelationFilter, CardHolderWhereInput> | null
    Case?: CaseListRelationFilter
    Passenger?: PassengerListRelationFilter
    Risk?: RiskListRelationFilter
    StripeActivity?: StripeActivityListRelationFilter
    Task?: TaskListRelationFilter
  }

  export type ApplicationOrderByWithRelationInput = {
    id?: SortOrder
    destinationId?: SortOrder
    visaTypeId?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    applicationId?: SortOrder
    passengerCount?: SortOrderInput | SortOrder
    stayingEnd?: SortOrderInput | SortOrder
    stayingStart?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    cancellationDetails?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    applyDate?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    Account?: AccountOrderByWithRelationInput
    Destination?: DestinationOrderByWithRelationInput
    VisaType?: VisaTypeOrderByWithRelationInput
    ApplicationDocument?: ApplicationDocumentOrderByRelationAggregateInput
    CardHolder?: CardHolderOrderByWithRelationInput
    Case?: CaseOrderByRelationAggregateInput
    Passenger?: PassengerOrderByRelationAggregateInput
    Risk?: RiskOrderByRelationAggregateInput
    StripeActivity?: StripeActivityOrderByRelationAggregateInput
    Task?: TaskOrderByRelationAggregateInput
  }

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    applicationId?: string
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    destinationId?: StringFilter<"Application"> | string
    visaTypeId?: StringFilter<"Application"> | string
    status?: StringFilter<"Application"> | string
    accountId?: StringFilter<"Application"> | string
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    passengerCount?: IntNullableFilter<"Application"> | number | null
    stayingEnd?: DateTimeNullableFilter<"Application"> | Date | string | null
    stayingStart?: DateTimeNullableFilter<"Application"> | Date | string | null
    total?: FloatNullableFilter<"Application"> | number | null
    cancellationDetails?: StringNullableFilter<"Application"> | string | null
    cancellationReason?: StringNullableFilter<"Application"> | string | null
    cancelledAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    cancelledBy?: StringNullableFilter<"Application"> | string | null
    applyDate?: DateTimeNullableFilter<"Application"> | Date | string | null
    paymentStatus?: StringNullableFilter<"Application"> | string | null
    Account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    Destination?: XOR<DestinationScalarRelationFilter, DestinationWhereInput>
    VisaType?: XOR<VisaTypeScalarRelationFilter, VisaTypeWhereInput>
    ApplicationDocument?: ApplicationDocumentListRelationFilter
    CardHolder?: XOR<CardHolderNullableScalarRelationFilter, CardHolderWhereInput> | null
    Case?: CaseListRelationFilter
    Passenger?: PassengerListRelationFilter
    Risk?: RiskListRelationFilter
    StripeActivity?: StripeActivityListRelationFilter
    Task?: TaskListRelationFilter
  }, "id" | "applicationId">

  export type ApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    destinationId?: SortOrder
    visaTypeId?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    applicationId?: SortOrder
    passengerCount?: SortOrderInput | SortOrder
    stayingEnd?: SortOrderInput | SortOrder
    stayingStart?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    cancellationDetails?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    applyDate?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    _count?: ApplicationCountOrderByAggregateInput
    _avg?: ApplicationAvgOrderByAggregateInput
    _max?: ApplicationMaxOrderByAggregateInput
    _min?: ApplicationMinOrderByAggregateInput
    _sum?: ApplicationSumOrderByAggregateInput
  }

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    OR?: ApplicationScalarWhereWithAggregatesInput[]
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Application"> | string
    destinationId?: StringWithAggregatesFilter<"Application"> | string
    visaTypeId?: StringWithAggregatesFilter<"Application"> | string
    status?: StringWithAggregatesFilter<"Application"> | string
    accountId?: StringWithAggregatesFilter<"Application"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    applicationId?: StringWithAggregatesFilter<"Application"> | string
    passengerCount?: IntNullableWithAggregatesFilter<"Application"> | number | null
    stayingEnd?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    stayingStart?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    total?: FloatNullableWithAggregatesFilter<"Application"> | number | null
    cancellationDetails?: StringNullableWithAggregatesFilter<"Application"> | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"Application"> | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    cancelledBy?: StringNullableWithAggregatesFilter<"Application"> | string | null
    applyDate?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    paymentStatus?: StringNullableWithAggregatesFilter<"Application"> | string | null
  }

  export type ApplicationDocumentWhereInput = {
    AND?: ApplicationDocumentWhereInput | ApplicationDocumentWhereInput[]
    OR?: ApplicationDocumentWhereInput[]
    NOT?: ApplicationDocumentWhereInput | ApplicationDocumentWhereInput[]
    id?: StringFilter<"ApplicationDocument"> | string
    applicationId?: StringFilter<"ApplicationDocument"> | string
    name?: StringFilter<"ApplicationDocument"> | string
    type?: StringFilter<"ApplicationDocument"> | string
    content?: BytesFilter<"ApplicationDocument"> | Uint8Array
    status?: StringNullableFilter<"ApplicationDocument"> | string | null
    uploadedAt?: DateTimeFilter<"ApplicationDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"ApplicationDocument"> | string | null
    createdAt?: DateTimeFilter<"ApplicationDocument"> | Date | string
    updatedAt?: DateTimeFilter<"ApplicationDocument"> | Date | string
    Application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
    DocumentMapping?: XOR<DocumentMappingNullableScalarRelationFilter, DocumentMappingWhereInput> | null
  }

  export type ApplicationDocumentOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    content?: SortOrder
    status?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Application?: ApplicationOrderByWithRelationInput
    DocumentMapping?: DocumentMappingOrderByWithRelationInput
  }

  export type ApplicationDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApplicationDocumentWhereInput | ApplicationDocumentWhereInput[]
    OR?: ApplicationDocumentWhereInput[]
    NOT?: ApplicationDocumentWhereInput | ApplicationDocumentWhereInput[]
    applicationId?: StringFilter<"ApplicationDocument"> | string
    name?: StringFilter<"ApplicationDocument"> | string
    type?: StringFilter<"ApplicationDocument"> | string
    content?: BytesFilter<"ApplicationDocument"> | Uint8Array
    status?: StringNullableFilter<"ApplicationDocument"> | string | null
    uploadedAt?: DateTimeFilter<"ApplicationDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"ApplicationDocument"> | string | null
    createdAt?: DateTimeFilter<"ApplicationDocument"> | Date | string
    updatedAt?: DateTimeFilter<"ApplicationDocument"> | Date | string
    Application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
    DocumentMapping?: XOR<DocumentMappingNullableScalarRelationFilter, DocumentMappingWhereInput> | null
  }, "id">

  export type ApplicationDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    content?: SortOrder
    status?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApplicationDocumentCountOrderByAggregateInput
    _max?: ApplicationDocumentMaxOrderByAggregateInput
    _min?: ApplicationDocumentMinOrderByAggregateInput
  }

  export type ApplicationDocumentScalarWhereWithAggregatesInput = {
    AND?: ApplicationDocumentScalarWhereWithAggregatesInput | ApplicationDocumentScalarWhereWithAggregatesInput[]
    OR?: ApplicationDocumentScalarWhereWithAggregatesInput[]
    NOT?: ApplicationDocumentScalarWhereWithAggregatesInput | ApplicationDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApplicationDocument"> | string
    applicationId?: StringWithAggregatesFilter<"ApplicationDocument"> | string
    name?: StringWithAggregatesFilter<"ApplicationDocument"> | string
    type?: StringWithAggregatesFilter<"ApplicationDocument"> | string
    content?: BytesWithAggregatesFilter<"ApplicationDocument"> | Uint8Array
    status?: StringNullableWithAggregatesFilter<"ApplicationDocument"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"ApplicationDocument"> | Date | string
    uploadedBy?: StringNullableWithAggregatesFilter<"ApplicationDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApplicationDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApplicationDocument"> | Date | string
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: StringFilter<"Attachment"> | string
    emailThreadId?: StringFilter<"Attachment"> | string
    filename?: StringFilter<"Attachment"> | string
    content?: BytesFilter<"Attachment"> | Uint8Array
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    EmailThread?: XOR<EmailThreadScalarRelationFilter, EmailThreadWhereInput>
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    emailThreadId?: SortOrder
    filename?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    EmailThread?: EmailThreadOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    emailThreadId?: StringFilter<"Attachment"> | string
    filename?: StringFilter<"Attachment"> | string
    content?: BytesFilter<"Attachment"> | Uint8Array
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    EmailThread?: XOR<EmailThreadScalarRelationFilter, EmailThreadWhereInput>
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    emailThreadId?: SortOrder
    filename?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attachment"> | string
    emailThreadId?: StringWithAggregatesFilter<"Attachment"> | string
    filename?: StringWithAggregatesFilter<"Attachment"> | string
    content?: BytesWithAggregatesFilter<"Attachment"> | Uint8Array
    createdAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
  }

  export type CardHolderWhereInput = {
    AND?: CardHolderWhereInput | CardHolderWhereInput[]
    OR?: CardHolderWhereInput[]
    NOT?: CardHolderWhereInput | CardHolderWhereInput[]
    id?: StringFilter<"CardHolder"> | string
    name?: StringFilter<"CardHolder"> | string
    cardType?: StringFilter<"CardHolder"> | string
    cardNumber?: StringFilter<"CardHolder"> | string
    address?: StringFilter<"CardHolder"> | string
    zipcode?: StringFilter<"CardHolder"> | string
    applicationId?: StringFilter<"CardHolder"> | string
    Application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
  }

  export type CardHolderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cardType?: SortOrder
    cardNumber?: SortOrder
    address?: SortOrder
    zipcode?: SortOrder
    applicationId?: SortOrder
    Application?: ApplicationOrderByWithRelationInput
  }

  export type CardHolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    applicationId?: string
    AND?: CardHolderWhereInput | CardHolderWhereInput[]
    OR?: CardHolderWhereInput[]
    NOT?: CardHolderWhereInput | CardHolderWhereInput[]
    name?: StringFilter<"CardHolder"> | string
    cardType?: StringFilter<"CardHolder"> | string
    cardNumber?: StringFilter<"CardHolder"> | string
    address?: StringFilter<"CardHolder"> | string
    zipcode?: StringFilter<"CardHolder"> | string
    Application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
  }, "id" | "applicationId">

  export type CardHolderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cardType?: SortOrder
    cardNumber?: SortOrder
    address?: SortOrder
    zipcode?: SortOrder
    applicationId?: SortOrder
    _count?: CardHolderCountOrderByAggregateInput
    _max?: CardHolderMaxOrderByAggregateInput
    _min?: CardHolderMinOrderByAggregateInput
  }

  export type CardHolderScalarWhereWithAggregatesInput = {
    AND?: CardHolderScalarWhereWithAggregatesInput | CardHolderScalarWhereWithAggregatesInput[]
    OR?: CardHolderScalarWhereWithAggregatesInput[]
    NOT?: CardHolderScalarWhereWithAggregatesInput | CardHolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CardHolder"> | string
    name?: StringWithAggregatesFilter<"CardHolder"> | string
    cardType?: StringWithAggregatesFilter<"CardHolder"> | string
    cardNumber?: StringWithAggregatesFilter<"CardHolder"> | string
    address?: StringWithAggregatesFilter<"CardHolder"> | string
    zipcode?: StringWithAggregatesFilter<"CardHolder"> | string
    applicationId?: StringWithAggregatesFilter<"CardHolder"> | string
  }

  export type CaseWhereInput = {
    AND?: CaseWhereInput | CaseWhereInput[]
    OR?: CaseWhereInput[]
    NOT?: CaseWhereInput | CaseWhereInput[]
    id?: StringFilter<"Case"> | string
    gmailThreadId?: StringNullableFilter<"Case"> | string | null
    email?: StringFilter<"Case"> | string
    subject?: StringFilter<"Case"> | string
    status?: StringFilter<"Case"> | string
    lastUpdate?: DateTimeFilter<"Case"> | Date | string
    websiteCreatedAt?: StringFilter<"Case"> | string
    accountId?: StringNullableFilter<"Case"> | string | null
    applicationId?: StringNullableFilter<"Case"> | string | null
    assignedTo?: StringNullableFilter<"Case"> | string | null
    topic?: StringNullableFilter<"Case"> | string | null
    createdAt?: DateTimeFilter<"Case"> | Date | string
    updatedAt?: DateTimeFilter<"Case"> | Date | string
    Account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    Application?: XOR<ApplicationNullableScalarRelationFilter, ApplicationWhereInput> | null
    EmailThread?: EmailThreadListRelationFilter
  }

  export type CaseOrderByWithRelationInput = {
    id?: SortOrder
    gmailThreadId?: SortOrderInput | SortOrder
    email?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    lastUpdate?: SortOrder
    websiteCreatedAt?: SortOrder
    accountId?: SortOrderInput | SortOrder
    applicationId?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Account?: AccountOrderByWithRelationInput
    Application?: ApplicationOrderByWithRelationInput
    EmailThread?: EmailThreadOrderByRelationAggregateInput
  }

  export type CaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gmailThreadId?: string
    AND?: CaseWhereInput | CaseWhereInput[]
    OR?: CaseWhereInput[]
    NOT?: CaseWhereInput | CaseWhereInput[]
    email?: StringFilter<"Case"> | string
    subject?: StringFilter<"Case"> | string
    status?: StringFilter<"Case"> | string
    lastUpdate?: DateTimeFilter<"Case"> | Date | string
    websiteCreatedAt?: StringFilter<"Case"> | string
    accountId?: StringNullableFilter<"Case"> | string | null
    applicationId?: StringNullableFilter<"Case"> | string | null
    assignedTo?: StringNullableFilter<"Case"> | string | null
    topic?: StringNullableFilter<"Case"> | string | null
    createdAt?: DateTimeFilter<"Case"> | Date | string
    updatedAt?: DateTimeFilter<"Case"> | Date | string
    Account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    Application?: XOR<ApplicationNullableScalarRelationFilter, ApplicationWhereInput> | null
    EmailThread?: EmailThreadListRelationFilter
  }, "id" | "gmailThreadId">

  export type CaseOrderByWithAggregationInput = {
    id?: SortOrder
    gmailThreadId?: SortOrderInput | SortOrder
    email?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    lastUpdate?: SortOrder
    websiteCreatedAt?: SortOrder
    accountId?: SortOrderInput | SortOrder
    applicationId?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CaseCountOrderByAggregateInput
    _max?: CaseMaxOrderByAggregateInput
    _min?: CaseMinOrderByAggregateInput
  }

  export type CaseScalarWhereWithAggregatesInput = {
    AND?: CaseScalarWhereWithAggregatesInput | CaseScalarWhereWithAggregatesInput[]
    OR?: CaseScalarWhereWithAggregatesInput[]
    NOT?: CaseScalarWhereWithAggregatesInput | CaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Case"> | string
    gmailThreadId?: StringNullableWithAggregatesFilter<"Case"> | string | null
    email?: StringWithAggregatesFilter<"Case"> | string
    subject?: StringWithAggregatesFilter<"Case"> | string
    status?: StringWithAggregatesFilter<"Case"> | string
    lastUpdate?: DateTimeWithAggregatesFilter<"Case"> | Date | string
    websiteCreatedAt?: StringWithAggregatesFilter<"Case"> | string
    accountId?: StringNullableWithAggregatesFilter<"Case"> | string | null
    applicationId?: StringNullableWithAggregatesFilter<"Case"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Case"> | string | null
    topic?: StringNullableWithAggregatesFilter<"Case"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Case"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Case"> | Date | string
  }

  export type CaseSequenceWhereInput = {
    AND?: CaseSequenceWhereInput | CaseSequenceWhereInput[]
    OR?: CaseSequenceWhereInput[]
    NOT?: CaseSequenceWhereInput | CaseSequenceWhereInput[]
    year?: IntFilter<"CaseSequence"> | number
    currentSequence?: IntNullableFilter<"CaseSequence"> | number | null
    updatedAt?: DateTimeFilter<"CaseSequence"> | Date | string
  }

  export type CaseSequenceOrderByWithRelationInput = {
    year?: SortOrder
    currentSequence?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type CaseSequenceWhereUniqueInput = Prisma.AtLeast<{
    year?: number
    AND?: CaseSequenceWhereInput | CaseSequenceWhereInput[]
    OR?: CaseSequenceWhereInput[]
    NOT?: CaseSequenceWhereInput | CaseSequenceWhereInput[]
    currentSequence?: IntNullableFilter<"CaseSequence"> | number | null
    updatedAt?: DateTimeFilter<"CaseSequence"> | Date | string
  }, "year">

  export type CaseSequenceOrderByWithAggregationInput = {
    year?: SortOrder
    currentSequence?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: CaseSequenceCountOrderByAggregateInput
    _avg?: CaseSequenceAvgOrderByAggregateInput
    _max?: CaseSequenceMaxOrderByAggregateInput
    _min?: CaseSequenceMinOrderByAggregateInput
    _sum?: CaseSequenceSumOrderByAggregateInput
  }

  export type CaseSequenceScalarWhereWithAggregatesInput = {
    AND?: CaseSequenceScalarWhereWithAggregatesInput | CaseSequenceScalarWhereWithAggregatesInput[]
    OR?: CaseSequenceScalarWhereWithAggregatesInput[]
    NOT?: CaseSequenceScalarWhereWithAggregatesInput | CaseSequenceScalarWhereWithAggregatesInput[]
    year?: IntWithAggregatesFilter<"CaseSequence"> | number
    currentSequence?: IntNullableWithAggregatesFilter<"CaseSequence"> | number | null
    updatedAt?: DateTimeWithAggregatesFilter<"CaseSequence"> | Date | string
  }

  export type CustomRequirementWhereInput = {
    AND?: CustomRequirementWhereInput | CustomRequirementWhereInput[]
    OR?: CustomRequirementWhereInput[]
    NOT?: CustomRequirementWhereInput | CustomRequirementWhereInput[]
    id?: StringFilter<"CustomRequirement"> | string
    applicationId?: StringFilter<"CustomRequirement"> | string
    passengerId?: StringFilter<"CustomRequirement"> | string
    title?: StringFilter<"CustomRequirement"> | string
    createdAt?: DateTimeFilter<"CustomRequirement"> | Date | string
  }

  export type CustomRequirementOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    passengerId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomRequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomRequirementWhereInput | CustomRequirementWhereInput[]
    OR?: CustomRequirementWhereInput[]
    NOT?: CustomRequirementWhereInput | CustomRequirementWhereInput[]
    applicationId?: StringFilter<"CustomRequirement"> | string
    passengerId?: StringFilter<"CustomRequirement"> | string
    title?: StringFilter<"CustomRequirement"> | string
    createdAt?: DateTimeFilter<"CustomRequirement"> | Date | string
  }, "id">

  export type CustomRequirementOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    passengerId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    _count?: CustomRequirementCountOrderByAggregateInput
    _max?: CustomRequirementMaxOrderByAggregateInput
    _min?: CustomRequirementMinOrderByAggregateInput
  }

  export type CustomRequirementScalarWhereWithAggregatesInput = {
    AND?: CustomRequirementScalarWhereWithAggregatesInput | CustomRequirementScalarWhereWithAggregatesInput[]
    OR?: CustomRequirementScalarWhereWithAggregatesInput[]
    NOT?: CustomRequirementScalarWhereWithAggregatesInput | CustomRequirementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomRequirement"> | string
    applicationId?: StringWithAggregatesFilter<"CustomRequirement"> | string
    passengerId?: StringWithAggregatesFilter<"CustomRequirement"> | string
    title?: StringWithAggregatesFilter<"CustomRequirement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomRequirement"> | Date | string
  }

  export type DestinationWhereInput = {
    AND?: DestinationWhereInput | DestinationWhereInput[]
    OR?: DestinationWhereInput[]
    NOT?: DestinationWhereInput | DestinationWhereInput[]
    id?: StringFilter<"Destination"> | string
    name?: StringFilter<"Destination"> | string
    code?: StringNullableFilter<"Destination"> | string | null
    Application?: ApplicationListRelationFilter
    VisaType?: VisaTypeListRelationFilter
  }

  export type DestinationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    Application?: ApplicationOrderByRelationAggregateInput
    VisaType?: VisaTypeOrderByRelationAggregateInput
  }

  export type DestinationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DestinationWhereInput | DestinationWhereInput[]
    OR?: DestinationWhereInput[]
    NOT?: DestinationWhereInput | DestinationWhereInput[]
    code?: StringNullableFilter<"Destination"> | string | null
    Application?: ApplicationListRelationFilter
    VisaType?: VisaTypeListRelationFilter
  }, "id" | "name">

  export type DestinationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    _count?: DestinationCountOrderByAggregateInput
    _max?: DestinationMaxOrderByAggregateInput
    _min?: DestinationMinOrderByAggregateInput
  }

  export type DestinationScalarWhereWithAggregatesInput = {
    AND?: DestinationScalarWhereWithAggregatesInput | DestinationScalarWhereWithAggregatesInput[]
    OR?: DestinationScalarWhereWithAggregatesInput[]
    NOT?: DestinationScalarWhereWithAggregatesInput | DestinationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Destination"> | string
    name?: StringWithAggregatesFilter<"Destination"> | string
    code?: StringNullableWithAggregatesFilter<"Destination"> | string | null
  }

  export type DocumentMappingWhereInput = {
    AND?: DocumentMappingWhereInput | DocumentMappingWhereInput[]
    OR?: DocumentMappingWhereInput[]
    NOT?: DocumentMappingWhereInput | DocumentMappingWhereInput[]
    id?: StringFilter<"DocumentMapping"> | string
    documentId?: StringFilter<"DocumentMapping"> | string
    mappedTo?: StringNullableFilter<"DocumentMapping"> | string | null
    isInvalid?: BoolFilter<"DocumentMapping"> | boolean
    createdAt?: DateTimeFilter<"DocumentMapping"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentMapping"> | Date | string
    ApplicationDocument?: XOR<ApplicationDocumentScalarRelationFilter, ApplicationDocumentWhereInput>
  }

  export type DocumentMappingOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    mappedTo?: SortOrderInput | SortOrder
    isInvalid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ApplicationDocument?: ApplicationDocumentOrderByWithRelationInput
  }

  export type DocumentMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId?: string
    AND?: DocumentMappingWhereInput | DocumentMappingWhereInput[]
    OR?: DocumentMappingWhereInput[]
    NOT?: DocumentMappingWhereInput | DocumentMappingWhereInput[]
    mappedTo?: StringNullableFilter<"DocumentMapping"> | string | null
    isInvalid?: BoolFilter<"DocumentMapping"> | boolean
    createdAt?: DateTimeFilter<"DocumentMapping"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentMapping"> | Date | string
    ApplicationDocument?: XOR<ApplicationDocumentScalarRelationFilter, ApplicationDocumentWhereInput>
  }, "id" | "documentId">

  export type DocumentMappingOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    mappedTo?: SortOrderInput | SortOrder
    isInvalid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentMappingCountOrderByAggregateInput
    _max?: DocumentMappingMaxOrderByAggregateInput
    _min?: DocumentMappingMinOrderByAggregateInput
  }

  export type DocumentMappingScalarWhereWithAggregatesInput = {
    AND?: DocumentMappingScalarWhereWithAggregatesInput | DocumentMappingScalarWhereWithAggregatesInput[]
    OR?: DocumentMappingScalarWhereWithAggregatesInput[]
    NOT?: DocumentMappingScalarWhereWithAggregatesInput | DocumentMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentMapping"> | string
    documentId?: StringWithAggregatesFilter<"DocumentMapping"> | string
    mappedTo?: StringNullableWithAggregatesFilter<"DocumentMapping"> | string | null
    isInvalid?: BoolWithAggregatesFilter<"DocumentMapping"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DocumentMapping"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentMapping"> | Date | string
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    websiteCreatedAt?: StringNullableFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    websiteCreatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    websiteCreatedAt?: StringNullableFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }, "id">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    websiteCreatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    subject?: StringWithAggregatesFilter<"EmailTemplate"> | string
    body?: StringWithAggregatesFilter<"EmailTemplate"> | string
    websiteCreatedAt?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
  }

  export type EmailThreadWhereInput = {
    AND?: EmailThreadWhereInput | EmailThreadWhereInput[]
    OR?: EmailThreadWhereInput[]
    NOT?: EmailThreadWhereInput | EmailThreadWhereInput[]
    id?: StringFilter<"EmailThread"> | string
    caseId?: StringFilter<"EmailThread"> | string
    messageId?: StringFilter<"EmailThread"> | string
    fromEmail?: StringFilter<"EmailThread"> | string
    toEmail?: StringFilter<"EmailThread"> | string
    subject?: StringFilter<"EmailThread"> | string
    body?: StringFilter<"EmailThread"> | string
    timestamp?: DateTimeFilter<"EmailThread"> | Date | string
    direction?: StringFilter<"EmailThread"> | string
    cc?: StringNullableFilter<"EmailThread"> | string | null
    bcc?: StringNullableFilter<"EmailThread"> | string | null
    Attachment?: AttachmentListRelationFilter
    Case?: XOR<CaseScalarRelationFilter, CaseWhereInput>
  }

  export type EmailThreadOrderByWithRelationInput = {
    id?: SortOrder
    caseId?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrder
    toEmail?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    timestamp?: SortOrder
    direction?: SortOrder
    cc?: SortOrderInput | SortOrder
    bcc?: SortOrderInput | SortOrder
    Attachment?: AttachmentOrderByRelationAggregateInput
    Case?: CaseOrderByWithRelationInput
  }

  export type EmailThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailThreadWhereInput | EmailThreadWhereInput[]
    OR?: EmailThreadWhereInput[]
    NOT?: EmailThreadWhereInput | EmailThreadWhereInput[]
    caseId?: StringFilter<"EmailThread"> | string
    messageId?: StringFilter<"EmailThread"> | string
    fromEmail?: StringFilter<"EmailThread"> | string
    toEmail?: StringFilter<"EmailThread"> | string
    subject?: StringFilter<"EmailThread"> | string
    body?: StringFilter<"EmailThread"> | string
    timestamp?: DateTimeFilter<"EmailThread"> | Date | string
    direction?: StringFilter<"EmailThread"> | string
    cc?: StringNullableFilter<"EmailThread"> | string | null
    bcc?: StringNullableFilter<"EmailThread"> | string | null
    Attachment?: AttachmentListRelationFilter
    Case?: XOR<CaseScalarRelationFilter, CaseWhereInput>
  }, "id">

  export type EmailThreadOrderByWithAggregationInput = {
    id?: SortOrder
    caseId?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrder
    toEmail?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    timestamp?: SortOrder
    direction?: SortOrder
    cc?: SortOrderInput | SortOrder
    bcc?: SortOrderInput | SortOrder
    _count?: EmailThreadCountOrderByAggregateInput
    _max?: EmailThreadMaxOrderByAggregateInput
    _min?: EmailThreadMinOrderByAggregateInput
  }

  export type EmailThreadScalarWhereWithAggregatesInput = {
    AND?: EmailThreadScalarWhereWithAggregatesInput | EmailThreadScalarWhereWithAggregatesInput[]
    OR?: EmailThreadScalarWhereWithAggregatesInput[]
    NOT?: EmailThreadScalarWhereWithAggregatesInput | EmailThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailThread"> | string
    caseId?: StringWithAggregatesFilter<"EmailThread"> | string
    messageId?: StringWithAggregatesFilter<"EmailThread"> | string
    fromEmail?: StringWithAggregatesFilter<"EmailThread"> | string
    toEmail?: StringWithAggregatesFilter<"EmailThread"> | string
    subject?: StringWithAggregatesFilter<"EmailThread"> | string
    body?: StringWithAggregatesFilter<"EmailThread"> | string
    timestamp?: DateTimeWithAggregatesFilter<"EmailThread"> | Date | string
    direction?: StringWithAggregatesFilter<"EmailThread"> | string
    cc?: StringNullableWithAggregatesFilter<"EmailThread"> | string | null
    bcc?: StringNullableWithAggregatesFilter<"EmailThread"> | string | null
  }

  export type PassengerWhereInput = {
    AND?: PassengerWhereInput | PassengerWhereInput[]
    OR?: PassengerWhereInput[]
    NOT?: PassengerWhereInput | PassengerWhereInput[]
    id?: StringFilter<"Passenger"> | string
    applicationId?: StringFilter<"Passenger"> | string
    createdAt?: DateTimeFilter<"Passenger"> | Date | string
    name?: StringNullableFilter<"Passenger"> | string | null
    passportNumber?: StringNullableFilter<"Passenger"> | string | null
    updatedAt?: DateTimeNullableFilter<"Passenger"> | Date | string | null
    dateOfBirth?: DateTimeNullableFilter<"Passenger"> | Date | string | null
    fullName?: StringNullableFilter<"Passenger"> | string | null
    gender?: StringNullableFilter<"Passenger"> | string | null
    nationality?: StringNullableFilter<"Passenger"> | string | null
    passportId?: StringNullableFilter<"Passenger"> | string | null
    status?: StringNullableFilter<"Passenger"> | string | null
    Application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
  }

  export type PassengerOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrderInput | SortOrder
    passportNumber?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    passportId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    Application?: ApplicationOrderByWithRelationInput
  }

  export type PassengerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PassengerWhereInput | PassengerWhereInput[]
    OR?: PassengerWhereInput[]
    NOT?: PassengerWhereInput | PassengerWhereInput[]
    applicationId?: StringFilter<"Passenger"> | string
    createdAt?: DateTimeFilter<"Passenger"> | Date | string
    name?: StringNullableFilter<"Passenger"> | string | null
    passportNumber?: StringNullableFilter<"Passenger"> | string | null
    updatedAt?: DateTimeNullableFilter<"Passenger"> | Date | string | null
    dateOfBirth?: DateTimeNullableFilter<"Passenger"> | Date | string | null
    fullName?: StringNullableFilter<"Passenger"> | string | null
    gender?: StringNullableFilter<"Passenger"> | string | null
    nationality?: StringNullableFilter<"Passenger"> | string | null
    passportId?: StringNullableFilter<"Passenger"> | string | null
    status?: StringNullableFilter<"Passenger"> | string | null
    Application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
  }, "id">

  export type PassengerOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrderInput | SortOrder
    passportNumber?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    passportId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: PassengerCountOrderByAggregateInput
    _max?: PassengerMaxOrderByAggregateInput
    _min?: PassengerMinOrderByAggregateInput
  }

  export type PassengerScalarWhereWithAggregatesInput = {
    AND?: PassengerScalarWhereWithAggregatesInput | PassengerScalarWhereWithAggregatesInput[]
    OR?: PassengerScalarWhereWithAggregatesInput[]
    NOT?: PassengerScalarWhereWithAggregatesInput | PassengerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Passenger"> | string
    applicationId?: StringWithAggregatesFilter<"Passenger"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Passenger"> | Date | string
    name?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    passportNumber?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Passenger"> | Date | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Passenger"> | Date | string | null
    fullName?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    gender?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    passportId?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    status?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
  }

  export type RiskWhereInput = {
    AND?: RiskWhereInput | RiskWhereInput[]
    OR?: RiskWhereInput[]
    NOT?: RiskWhereInput | RiskWhereInput[]
    id?: StringFilter<"Risk"> | string
    status?: StringFilter<"Risk"> | string
    applicationId?: StringFilter<"Risk"> | string
    createdAt?: DateTimeFilter<"Risk"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Risk"> | Date | string | null
    lastUpdated?: DateTimeNullableFilter<"Risk"> | Date | string | null
    Application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
    RiskActivity?: RiskActivityListRelationFilter
    RiskDocument?: RiskDocumentListRelationFilter
  }

  export type RiskOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    lastUpdated?: SortOrderInput | SortOrder
    Application?: ApplicationOrderByWithRelationInput
    RiskActivity?: RiskActivityOrderByRelationAggregateInput
    RiskDocument?: RiskDocumentOrderByRelationAggregateInput
  }

  export type RiskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiskWhereInput | RiskWhereInput[]
    OR?: RiskWhereInput[]
    NOT?: RiskWhereInput | RiskWhereInput[]
    status?: StringFilter<"Risk"> | string
    applicationId?: StringFilter<"Risk"> | string
    createdAt?: DateTimeFilter<"Risk"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Risk"> | Date | string | null
    lastUpdated?: DateTimeNullableFilter<"Risk"> | Date | string | null
    Application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
    RiskActivity?: RiskActivityListRelationFilter
    RiskDocument?: RiskDocumentListRelationFilter
  }, "id">

  export type RiskOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    lastUpdated?: SortOrderInput | SortOrder
    _count?: RiskCountOrderByAggregateInput
    _max?: RiskMaxOrderByAggregateInput
    _min?: RiskMinOrderByAggregateInput
  }

  export type RiskScalarWhereWithAggregatesInput = {
    AND?: RiskScalarWhereWithAggregatesInput | RiskScalarWhereWithAggregatesInput[]
    OR?: RiskScalarWhereWithAggregatesInput[]
    NOT?: RiskScalarWhereWithAggregatesInput | RiskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Risk"> | string
    status?: StringWithAggregatesFilter<"Risk"> | string
    applicationId?: StringWithAggregatesFilter<"Risk"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Risk"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Risk"> | Date | string | null
    lastUpdated?: DateTimeNullableWithAggregatesFilter<"Risk"> | Date | string | null
  }

  export type RiskActivityWhereInput = {
    AND?: RiskActivityWhereInput | RiskActivityWhereInput[]
    OR?: RiskActivityWhereInput[]
    NOT?: RiskActivityWhereInput | RiskActivityWhereInput[]
    id?: StringFilter<"RiskActivity"> | string
    riskId?: StringFilter<"RiskActivity"> | string
    createdAt?: DateTimeFilter<"RiskActivity"> | Date | string
    description?: StringNullableFilter<"RiskActivity"> | string | null
    type?: StringNullableFilter<"RiskActivity"> | string | null
    details?: StringNullableFilter<"RiskActivity"> | string | null
    timestamp?: DateTimeNullableFilter<"RiskActivity"> | Date | string | null
    title?: StringNullableFilter<"RiskActivity"> | string | null
    Risk?: XOR<RiskScalarRelationFilter, RiskWhereInput>
  }

  export type RiskActivityOrderByWithRelationInput = {
    id?: SortOrder
    riskId?: SortOrder
    createdAt?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    Risk?: RiskOrderByWithRelationInput
  }

  export type RiskActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiskActivityWhereInput | RiskActivityWhereInput[]
    OR?: RiskActivityWhereInput[]
    NOT?: RiskActivityWhereInput | RiskActivityWhereInput[]
    riskId?: StringFilter<"RiskActivity"> | string
    createdAt?: DateTimeFilter<"RiskActivity"> | Date | string
    description?: StringNullableFilter<"RiskActivity"> | string | null
    type?: StringNullableFilter<"RiskActivity"> | string | null
    details?: StringNullableFilter<"RiskActivity"> | string | null
    timestamp?: DateTimeNullableFilter<"RiskActivity"> | Date | string | null
    title?: StringNullableFilter<"RiskActivity"> | string | null
    Risk?: XOR<RiskScalarRelationFilter, RiskWhereInput>
  }, "id">

  export type RiskActivityOrderByWithAggregationInput = {
    id?: SortOrder
    riskId?: SortOrder
    createdAt?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    _count?: RiskActivityCountOrderByAggregateInput
    _max?: RiskActivityMaxOrderByAggregateInput
    _min?: RiskActivityMinOrderByAggregateInput
  }

  export type RiskActivityScalarWhereWithAggregatesInput = {
    AND?: RiskActivityScalarWhereWithAggregatesInput | RiskActivityScalarWhereWithAggregatesInput[]
    OR?: RiskActivityScalarWhereWithAggregatesInput[]
    NOT?: RiskActivityScalarWhereWithAggregatesInput | RiskActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskActivity"> | string
    riskId?: StringWithAggregatesFilter<"RiskActivity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RiskActivity"> | Date | string
    description?: StringNullableWithAggregatesFilter<"RiskActivity"> | string | null
    type?: StringNullableWithAggregatesFilter<"RiskActivity"> | string | null
    details?: StringNullableWithAggregatesFilter<"RiskActivity"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"RiskActivity"> | Date | string | null
    title?: StringNullableWithAggregatesFilter<"RiskActivity"> | string | null
  }

  export type RiskDocumentWhereInput = {
    AND?: RiskDocumentWhereInput | RiskDocumentWhereInput[]
    OR?: RiskDocumentWhereInput[]
    NOT?: RiskDocumentWhereInput | RiskDocumentWhereInput[]
    id?: StringFilter<"RiskDocument"> | string
    name?: StringFilter<"RiskDocument"> | string
    riskId?: StringFilter<"RiskDocument"> | string
    createdAt?: DateTimeFilter<"RiskDocument"> | Date | string
    status?: StringFilter<"RiskDocument"> | string
    updatedAt?: DateTimeFilter<"RiskDocument"> | Date | string
    type?: StringFilter<"RiskDocument"> | string
    uploadedAt?: DateTimeFilter<"RiskDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"RiskDocument"> | string | null
    content?: BytesFilter<"RiskDocument"> | Uint8Array
    Risk?: XOR<RiskScalarRelationFilter, RiskWhereInput>
  }

  export type RiskDocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    riskId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    content?: SortOrder
    Risk?: RiskOrderByWithRelationInput
  }

  export type RiskDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiskDocumentWhereInput | RiskDocumentWhereInput[]
    OR?: RiskDocumentWhereInput[]
    NOT?: RiskDocumentWhereInput | RiskDocumentWhereInput[]
    name?: StringFilter<"RiskDocument"> | string
    riskId?: StringFilter<"RiskDocument"> | string
    createdAt?: DateTimeFilter<"RiskDocument"> | Date | string
    status?: StringFilter<"RiskDocument"> | string
    updatedAt?: DateTimeFilter<"RiskDocument"> | Date | string
    type?: StringFilter<"RiskDocument"> | string
    uploadedAt?: DateTimeFilter<"RiskDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"RiskDocument"> | string | null
    content?: BytesFilter<"RiskDocument"> | Uint8Array
    Risk?: XOR<RiskScalarRelationFilter, RiskWhereInput>
  }, "id">

  export type RiskDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    riskId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    content?: SortOrder
    _count?: RiskDocumentCountOrderByAggregateInput
    _max?: RiskDocumentMaxOrderByAggregateInput
    _min?: RiskDocumentMinOrderByAggregateInput
  }

  export type RiskDocumentScalarWhereWithAggregatesInput = {
    AND?: RiskDocumentScalarWhereWithAggregatesInput | RiskDocumentScalarWhereWithAggregatesInput[]
    OR?: RiskDocumentScalarWhereWithAggregatesInput[]
    NOT?: RiskDocumentScalarWhereWithAggregatesInput | RiskDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskDocument"> | string
    name?: StringWithAggregatesFilter<"RiskDocument"> | string
    riskId?: StringWithAggregatesFilter<"RiskDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RiskDocument"> | Date | string
    status?: StringWithAggregatesFilter<"RiskDocument"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskDocument"> | Date | string
    type?: StringWithAggregatesFilter<"RiskDocument"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"RiskDocument"> | Date | string
    uploadedBy?: StringNullableWithAggregatesFilter<"RiskDocument"> | string | null
    content?: BytesWithAggregatesFilter<"RiskDocument"> | Uint8Array
  }

  export type StripeActivityWhereInput = {
    AND?: StripeActivityWhereInput | StripeActivityWhereInput[]
    OR?: StripeActivityWhereInput[]
    NOT?: StripeActivityWhereInput | StripeActivityWhereInput[]
    id?: StringFilter<"StripeActivity"> | string
    title?: StringNullableFilter<"StripeActivity"> | string | null
    amount?: FloatNullableFilter<"StripeActivity"> | number | null
    createdAt?: DateTimeFilter<"StripeActivity"> | Date | string
    status?: StringNullableFilter<"StripeActivity"> | string | null
    type?: StringNullableFilter<"StripeActivity"> | string | null
    applicationId?: StringNullableFilter<"StripeActivity"> | string | null
    description?: StringNullableFilter<"StripeActivity"> | string | null
    timestamp?: DateTimeNullableFilter<"StripeActivity"> | Date | string | null
    transactionId?: StringNullableFilter<"StripeActivity"> | string | null
    govFeeRefund?: DecimalNullableFilter<"StripeActivity"> | Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: DecimalNullableFilter<"StripeActivity"> | Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: StringNullableFilter<"StripeActivity"> | string | null
    Application?: XOR<ApplicationNullableScalarRelationFilter, ApplicationWhereInput> | null
  }

  export type StripeActivityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    status?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    applicationId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    govFeeRefund?: SortOrderInput | SortOrder
    serviceFeeRefund?: SortOrderInput | SortOrder
    originalTransactionId?: SortOrderInput | SortOrder
    Application?: ApplicationOrderByWithRelationInput
  }

  export type StripeActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StripeActivityWhereInput | StripeActivityWhereInput[]
    OR?: StripeActivityWhereInput[]
    NOT?: StripeActivityWhereInput | StripeActivityWhereInput[]
    title?: StringNullableFilter<"StripeActivity"> | string | null
    amount?: FloatNullableFilter<"StripeActivity"> | number | null
    createdAt?: DateTimeFilter<"StripeActivity"> | Date | string
    status?: StringNullableFilter<"StripeActivity"> | string | null
    type?: StringNullableFilter<"StripeActivity"> | string | null
    applicationId?: StringNullableFilter<"StripeActivity"> | string | null
    description?: StringNullableFilter<"StripeActivity"> | string | null
    timestamp?: DateTimeNullableFilter<"StripeActivity"> | Date | string | null
    transactionId?: StringNullableFilter<"StripeActivity"> | string | null
    govFeeRefund?: DecimalNullableFilter<"StripeActivity"> | Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: DecimalNullableFilter<"StripeActivity"> | Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: StringNullableFilter<"StripeActivity"> | string | null
    Application?: XOR<ApplicationNullableScalarRelationFilter, ApplicationWhereInput> | null
  }, "id">

  export type StripeActivityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    status?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    applicationId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    govFeeRefund?: SortOrderInput | SortOrder
    serviceFeeRefund?: SortOrderInput | SortOrder
    originalTransactionId?: SortOrderInput | SortOrder
    _count?: StripeActivityCountOrderByAggregateInput
    _avg?: StripeActivityAvgOrderByAggregateInput
    _max?: StripeActivityMaxOrderByAggregateInput
    _min?: StripeActivityMinOrderByAggregateInput
    _sum?: StripeActivitySumOrderByAggregateInput
  }

  export type StripeActivityScalarWhereWithAggregatesInput = {
    AND?: StripeActivityScalarWhereWithAggregatesInput | StripeActivityScalarWhereWithAggregatesInput[]
    OR?: StripeActivityScalarWhereWithAggregatesInput[]
    NOT?: StripeActivityScalarWhereWithAggregatesInput | StripeActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StripeActivity"> | string
    title?: StringNullableWithAggregatesFilter<"StripeActivity"> | string | null
    amount?: FloatNullableWithAggregatesFilter<"StripeActivity"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"StripeActivity"> | Date | string
    status?: StringNullableWithAggregatesFilter<"StripeActivity"> | string | null
    type?: StringNullableWithAggregatesFilter<"StripeActivity"> | string | null
    applicationId?: StringNullableWithAggregatesFilter<"StripeActivity"> | string | null
    description?: StringNullableWithAggregatesFilter<"StripeActivity"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"StripeActivity"> | Date | string | null
    transactionId?: StringNullableWithAggregatesFilter<"StripeActivity"> | string | null
    govFeeRefund?: DecimalNullableWithAggregatesFilter<"StripeActivity"> | Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: DecimalNullableWithAggregatesFilter<"StripeActivity"> | Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: StringNullableWithAggregatesFilter<"StripeActivity"> | string | null
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    assignedTo?: StringNullableFilter<"Task"> | string | null
    assignedToEmail?: StringNullableFilter<"Task"> | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    taskType?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    applicationId?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    taskId?: StringFilter<"Task"> | string
    Application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
    TaskActivity?: TaskActivityListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedToEmail?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    taskType?: SortOrderInput | SortOrder
    status?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
    Application?: ApplicationOrderByWithRelationInput
    TaskActivity?: TaskActivityOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taskId?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    assignedTo?: StringNullableFilter<"Task"> | string | null
    assignedToEmail?: StringNullableFilter<"Task"> | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    taskType?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    applicationId?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    Application?: XOR<ApplicationScalarRelationFilter, ApplicationWhereInput>
    TaskActivity?: TaskActivityListRelationFilter
  }, "id" | "taskId">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedToEmail?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    taskType?: SortOrderInput | SortOrder
    status?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Task"> | string | null
    assignedToEmail?: StringNullableWithAggregatesFilter<"Task"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    taskType?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: StringWithAggregatesFilter<"Task"> | string
    applicationId?: StringWithAggregatesFilter<"Task"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    taskId?: StringWithAggregatesFilter<"Task"> | string
  }

  export type TaskActivityWhereInput = {
    AND?: TaskActivityWhereInput | TaskActivityWhereInput[]
    OR?: TaskActivityWhereInput[]
    NOT?: TaskActivityWhereInput | TaskActivityWhereInput[]
    id?: StringFilter<"TaskActivity"> | string
    taskId?: StringFilter<"TaskActivity"> | string
    status?: StringFilter<"TaskActivity"> | string
    description?: StringFilter<"TaskActivity"> | string
    timestamp?: DateTimeFilter<"TaskActivity"> | Date | string
    createdAt?: DateTimeFilter<"TaskActivity"> | Date | string
    Task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskActivityOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    Task?: TaskOrderByWithRelationInput
  }

  export type TaskActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskActivityWhereInput | TaskActivityWhereInput[]
    OR?: TaskActivityWhereInput[]
    NOT?: TaskActivityWhereInput | TaskActivityWhereInput[]
    taskId?: StringFilter<"TaskActivity"> | string
    status?: StringFilter<"TaskActivity"> | string
    description?: StringFilter<"TaskActivity"> | string
    timestamp?: DateTimeFilter<"TaskActivity"> | Date | string
    createdAt?: DateTimeFilter<"TaskActivity"> | Date | string
    Task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id">

  export type TaskActivityOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: TaskActivityCountOrderByAggregateInput
    _max?: TaskActivityMaxOrderByAggregateInput
    _min?: TaskActivityMinOrderByAggregateInput
  }

  export type TaskActivityScalarWhereWithAggregatesInput = {
    AND?: TaskActivityScalarWhereWithAggregatesInput | TaskActivityScalarWhereWithAggregatesInput[]
    OR?: TaskActivityScalarWhereWithAggregatesInput[]
    NOT?: TaskActivityScalarWhereWithAggregatesInput | TaskActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskActivity"> | string
    taskId?: StringWithAggregatesFilter<"TaskActivity"> | string
    status?: StringWithAggregatesFilter<"TaskActivity"> | string
    description?: StringWithAggregatesFilter<"TaskActivity"> | string
    timestamp?: DateTimeWithAggregatesFilter<"TaskActivity"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TaskActivity"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
  }

  export type VisaTypeWhereInput = {
    AND?: VisaTypeWhereInput | VisaTypeWhereInput[]
    OR?: VisaTypeWhereInput[]
    NOT?: VisaTypeWhereInput | VisaTypeWhereInput[]
    id?: StringFilter<"VisaType"> | string
    name?: StringFilter<"VisaType"> | string
    waitTime?: StringNullableFilter<"VisaType"> | string | null
    fees?: FloatNullableFilter<"VisaType"> | number | null
    requiredDocuments?: StringNullableFilter<"VisaType"> | string | null
    allowedNationalities?: JsonNullableFilter<"VisaType">
    destinationId?: StringFilter<"VisaType"> | string
    Application?: ApplicationListRelationFilter
    Destination?: XOR<DestinationScalarRelationFilter, DestinationWhereInput>
  }

  export type VisaTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    waitTime?: SortOrderInput | SortOrder
    fees?: SortOrderInput | SortOrder
    requiredDocuments?: SortOrderInput | SortOrder
    allowedNationalities?: SortOrderInput | SortOrder
    destinationId?: SortOrder
    Application?: ApplicationOrderByRelationAggregateInput
    Destination?: DestinationOrderByWithRelationInput
  }

  export type VisaTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_destinationId?: VisaTypeNameDestinationIdCompoundUniqueInput
    AND?: VisaTypeWhereInput | VisaTypeWhereInput[]
    OR?: VisaTypeWhereInput[]
    NOT?: VisaTypeWhereInput | VisaTypeWhereInput[]
    name?: StringFilter<"VisaType"> | string
    waitTime?: StringNullableFilter<"VisaType"> | string | null
    fees?: FloatNullableFilter<"VisaType"> | number | null
    requiredDocuments?: StringNullableFilter<"VisaType"> | string | null
    allowedNationalities?: JsonNullableFilter<"VisaType">
    destinationId?: StringFilter<"VisaType"> | string
    Application?: ApplicationListRelationFilter
    Destination?: XOR<DestinationScalarRelationFilter, DestinationWhereInput>
  }, "id" | "name_destinationId">

  export type VisaTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    waitTime?: SortOrderInput | SortOrder
    fees?: SortOrderInput | SortOrder
    requiredDocuments?: SortOrderInput | SortOrder
    allowedNationalities?: SortOrderInput | SortOrder
    destinationId?: SortOrder
    _count?: VisaTypeCountOrderByAggregateInput
    _avg?: VisaTypeAvgOrderByAggregateInput
    _max?: VisaTypeMaxOrderByAggregateInput
    _min?: VisaTypeMinOrderByAggregateInput
    _sum?: VisaTypeSumOrderByAggregateInput
  }

  export type VisaTypeScalarWhereWithAggregatesInput = {
    AND?: VisaTypeScalarWhereWithAggregatesInput | VisaTypeScalarWhereWithAggregatesInput[]
    OR?: VisaTypeScalarWhereWithAggregatesInput[]
    NOT?: VisaTypeScalarWhereWithAggregatesInput | VisaTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisaType"> | string
    name?: StringWithAggregatesFilter<"VisaType"> | string
    waitTime?: StringNullableWithAggregatesFilter<"VisaType"> | string | null
    fees?: FloatNullableWithAggregatesFilter<"VisaType"> | number | null
    requiredDocuments?: StringNullableWithAggregatesFilter<"VisaType"> | string | null
    allowedNationalities?: JsonNullableWithAggregatesFilter<"VisaType">
    destinationId?: StringWithAggregatesFilter<"VisaType"> | string
  }

  export type password_reset_tokensWhereInput = {
    AND?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    OR?: password_reset_tokensWhereInput[]
    NOT?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    id?: StringFilter<"password_reset_tokens"> | string
    accountId?: StringFilter<"password_reset_tokens"> | string
    token?: StringFilter<"password_reset_tokens"> | string
    expiresAt?: DateTimeFilter<"password_reset_tokens"> | Date | string
    used?: BoolFilter<"password_reset_tokens"> | boolean
    createdAt?: DateTimeFilter<"password_reset_tokens"> | Date | string
    Account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type password_reset_tokensOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    Account?: AccountOrderByWithRelationInput
  }

  export type password_reset_tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    OR?: password_reset_tokensWhereInput[]
    NOT?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    accountId?: StringFilter<"password_reset_tokens"> | string
    expiresAt?: DateTimeFilter<"password_reset_tokens"> | Date | string
    used?: BoolFilter<"password_reset_tokens"> | boolean
    createdAt?: DateTimeFilter<"password_reset_tokens"> | Date | string
    Account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "token">

  export type password_reset_tokensOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    _count?: password_reset_tokensCountOrderByAggregateInput
    _max?: password_reset_tokensMaxOrderByAggregateInput
    _min?: password_reset_tokensMinOrderByAggregateInput
  }

  export type password_reset_tokensScalarWhereWithAggregatesInput = {
    AND?: password_reset_tokensScalarWhereWithAggregatesInput | password_reset_tokensScalarWhereWithAggregatesInput[]
    OR?: password_reset_tokensScalarWhereWithAggregatesInput[]
    NOT?: password_reset_tokensScalarWhereWithAggregatesInput | password_reset_tokensScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"password_reset_tokens"> | string
    accountId?: StringWithAggregatesFilter<"password_reset_tokens"> | string
    token?: StringWithAggregatesFilter<"password_reset_tokens"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"password_reset_tokens"> | Date | string
    used?: BoolWithAggregatesFilter<"password_reset_tokens"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"password_reset_tokens"> | Date | string
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    id?: StringFilter<"sessions"> | string
    accountId?: StringFilter<"sessions"> | string
    token?: StringFilter<"sessions"> | string
    expiresAt?: DateTimeFilter<"sessions"> | Date | string
    createdAt?: DateTimeFilter<"sessions"> | Date | string
    Account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type sessionsOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    Account?: AccountOrderByWithRelationInput
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    accountId?: StringFilter<"sessions"> | string
    expiresAt?: DateTimeFilter<"sessions"> | Date | string
    createdAt?: DateTimeFilter<"sessions"> | Date | string
    Account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "token">

  export type sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"sessions"> | string
    accountId?: StringWithAggregatesFilter<"sessions"> | string
    token?: StringWithAggregatesFilter<"sessions"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
  }

  export type AccountCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    email: string
    fullName?: string
    areaCode?: string
    phoneNumber?: string
    gender?: string
    password?: string | null
    emailVerified?: boolean
    websiteCreatedAt?: string
    Application?: ApplicationCreateNestedManyWithoutAccountInput
    Case?: CaseCreateNestedManyWithoutAccountInput
    password_reset_tokens?: password_reset_tokensCreateNestedManyWithoutAccountInput
    sessions?: sessionsCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    email: string
    fullName?: string
    areaCode?: string
    phoneNumber?: string
    gender?: string
    password?: string | null
    emailVerified?: boolean
    websiteCreatedAt?: string
    Application?: ApplicationUncheckedCreateNestedManyWithoutAccountInput
    Case?: CaseUncheckedCreateNestedManyWithoutAccountInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedManyWithoutAccountInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    areaCode?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    Application?: ApplicationUpdateManyWithoutAccountNestedInput
    Case?: CaseUpdateManyWithoutAccountNestedInput
    password_reset_tokens?: password_reset_tokensUpdateManyWithoutAccountNestedInput
    sessions?: sessionsUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    areaCode?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    Application?: ApplicationUncheckedUpdateManyWithoutAccountNestedInput
    Case?: CaseUncheckedUpdateManyWithoutAccountNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateManyWithoutAccountNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    email: string
    fullName?: string
    areaCode?: string
    phoneNumber?: string
    gender?: string
    password?: string | null
    emailVerified?: boolean
    websiteCreatedAt?: string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    areaCode?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    areaCode?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
  }

  export type ApplicationCreateInput = {
    id?: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    Account: AccountCreateNestedOneWithoutApplicationInput
    Destination: DestinationCreateNestedOneWithoutApplicationInput
    VisaType: VisaTypeCreateNestedOneWithoutApplicationInput
    ApplicationDocument?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderCreateNestedOneWithoutApplicationInput
    Case?: CaseCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerCreateNestedManyWithoutApplicationInput
    Risk?: RiskCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityCreateNestedManyWithoutApplicationInput
    Task?: TaskCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateInput = {
    id?: string
    destinationId: string
    visaTypeId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    ApplicationDocument?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderUncheckedCreateNestedOneWithoutApplicationInput
    Case?: CaseUncheckedCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerUncheckedCreateNestedManyWithoutApplicationInput
    Risk?: RiskUncheckedCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityUncheckedCreateNestedManyWithoutApplicationInput
    Task?: TaskUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUpdateOneRequiredWithoutApplicationNestedInput
    Destination?: DestinationUpdateOneRequiredWithoutApplicationNestedInput
    VisaType?: VisaTypeUpdateOneRequiredWithoutApplicationNestedInput
    ApplicationDocument?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUpdateOneWithoutApplicationNestedInput
    Case?: CaseUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUpdateManyWithoutApplicationNestedInput
    Task?: TaskUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    ApplicationDocument?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUncheckedUpdateOneWithoutApplicationNestedInput
    Case?: CaseUncheckedUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUncheckedUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUncheckedUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUncheckedUpdateManyWithoutApplicationNestedInput
    Task?: TaskUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationCreateManyInput = {
    id?: string
    destinationId: string
    visaTypeId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
  }

  export type ApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationDocumentCreateInput = {
    id: string
    name: string
    type: string
    content: Uint8Array
    status?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Application: ApplicationCreateNestedOneWithoutApplicationDocumentInput
    DocumentMapping?: DocumentMappingCreateNestedOneWithoutApplicationDocumentInput
  }

  export type ApplicationDocumentUncheckedCreateInput = {
    id: string
    applicationId: string
    name: string
    type: string
    content: Uint8Array
    status?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    DocumentMapping?: DocumentMappingUncheckedCreateNestedOneWithoutApplicationDocumentInput
  }

  export type ApplicationDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    status?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Application?: ApplicationUpdateOneRequiredWithoutApplicationDocumentNestedInput
    DocumentMapping?: DocumentMappingUpdateOneWithoutApplicationDocumentNestedInput
  }

  export type ApplicationDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    status?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DocumentMapping?: DocumentMappingUncheckedUpdateOneWithoutApplicationDocumentNestedInput
  }

  export type ApplicationDocumentCreateManyInput = {
    id: string
    applicationId: string
    name: string
    type: string
    content: Uint8Array
    status?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ApplicationDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    status?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    status?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateInput = {
    id: string
    filename: string
    content: Uint8Array
    createdAt?: Date | string
    EmailThread: EmailThreadCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateInput = {
    id: string
    emailThreadId: string
    filename: string
    content: Uint8Array
    createdAt?: Date | string
  }

  export type AttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EmailThread?: EmailThreadUpdateOneRequiredWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailThreadId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyInput = {
    id: string
    emailThreadId: string
    filename: string
    content: Uint8Array
    createdAt?: Date | string
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailThreadId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardHolderCreateInput = {
    id: string
    name: string
    cardType: string
    cardNumber: string
    address: string
    zipcode: string
    Application: ApplicationCreateNestedOneWithoutCardHolderInput
  }

  export type CardHolderUncheckedCreateInput = {
    id: string
    name: string
    cardType: string
    cardNumber: string
    address: string
    zipcode: string
    applicationId: string
  }

  export type CardHolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cardType?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    Application?: ApplicationUpdateOneRequiredWithoutCardHolderNestedInput
  }

  export type CardHolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cardType?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
  }

  export type CardHolderCreateManyInput = {
    id: string
    name: string
    cardType: string
    cardNumber: string
    address: string
    zipcode: string
    applicationId: string
  }

  export type CardHolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cardType?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
  }

  export type CardHolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cardType?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
  }

  export type CaseCreateInput = {
    id: string
    gmailThreadId?: string | null
    email: string
    subject: string
    status?: string
    lastUpdate?: Date | string
    websiteCreatedAt: string
    assignedTo?: string | null
    topic?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Account?: AccountCreateNestedOneWithoutCaseInput
    Application?: ApplicationCreateNestedOneWithoutCaseInput
    EmailThread?: EmailThreadCreateNestedManyWithoutCaseInput
  }

  export type CaseUncheckedCreateInput = {
    id: string
    gmailThreadId?: string | null
    email: string
    subject: string
    status?: string
    lastUpdate?: Date | string
    websiteCreatedAt: string
    accountId?: string | null
    applicationId?: string | null
    assignedTo?: string | null
    topic?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    EmailThread?: EmailThreadUncheckedCreateNestedManyWithoutCaseInput
  }

  export type CaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Account?: AccountUpdateOneWithoutCaseNestedInput
    Application?: ApplicationUpdateOneWithoutCaseNestedInput
    EmailThread?: EmailThreadUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EmailThread?: EmailThreadUncheckedUpdateManyWithoutCaseNestedInput
  }

  export type CaseCreateManyInput = {
    id: string
    gmailThreadId?: string | null
    email: string
    subject: string
    status?: string
    lastUpdate?: Date | string
    websiteCreatedAt: string
    accountId?: string | null
    applicationId?: string | null
    assignedTo?: string | null
    topic?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseSequenceCreateInput = {
    year: number
    currentSequence?: number | null
    updatedAt?: Date | string
  }

  export type CaseSequenceUncheckedCreateInput = {
    year: number
    currentSequence?: number | null
    updatedAt?: Date | string
  }

  export type CaseSequenceUpdateInput = {
    year?: IntFieldUpdateOperationsInput | number
    currentSequence?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseSequenceUncheckedUpdateInput = {
    year?: IntFieldUpdateOperationsInput | number
    currentSequence?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseSequenceCreateManyInput = {
    year: number
    currentSequence?: number | null
    updatedAt?: Date | string
  }

  export type CaseSequenceUpdateManyMutationInput = {
    year?: IntFieldUpdateOperationsInput | number
    currentSequence?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseSequenceUncheckedUpdateManyInput = {
    year?: IntFieldUpdateOperationsInput | number
    currentSequence?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomRequirementCreateInput = {
    id: string
    applicationId: string
    passengerId: string
    title: string
    createdAt?: Date | string
  }

  export type CustomRequirementUncheckedCreateInput = {
    id: string
    applicationId: string
    passengerId: string
    title: string
    createdAt?: Date | string
  }

  export type CustomRequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomRequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomRequirementCreateManyInput = {
    id: string
    applicationId: string
    passengerId: string
    title: string
    createdAt?: Date | string
  }

  export type CustomRequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomRequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationCreateInput = {
    id: string
    name: string
    code?: string | null
    Application?: ApplicationCreateNestedManyWithoutDestinationInput
    VisaType?: VisaTypeCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateInput = {
    id: string
    name: string
    code?: string | null
    Application?: ApplicationUncheckedCreateNestedManyWithoutDestinationInput
    VisaType?: VisaTypeUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    Application?: ApplicationUpdateManyWithoutDestinationNestedInput
    VisaType?: VisaTypeUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    Application?: ApplicationUncheckedUpdateManyWithoutDestinationNestedInput
    VisaType?: VisaTypeUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationCreateManyInput = {
    id: string
    name: string
    code?: string | null
  }

  export type DestinationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DestinationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentMappingCreateInput = {
    id: string
    mappedTo?: string | null
    isInvalid?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    ApplicationDocument: ApplicationDocumentCreateNestedOneWithoutDocumentMappingInput
  }

  export type DocumentMappingUncheckedCreateInput = {
    id: string
    documentId: string
    mappedTo?: string | null
    isInvalid?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DocumentMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mappedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isInvalid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ApplicationDocument?: ApplicationDocumentUpdateOneRequiredWithoutDocumentMappingNestedInput
  }

  export type DocumentMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    mappedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isInvalid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentMappingCreateManyInput = {
    id: string
    documentId: string
    mappedTo?: string | null
    isInvalid?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DocumentMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mappedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isInvalid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    mappedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isInvalid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateInput = {
    id: string
    name: string
    subject: string
    body: string
    websiteCreatedAt?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type EmailTemplateUncheckedCreateInput = {
    id: string
    name: string
    subject: string
    body: string
    websiteCreatedAt?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    websiteCreatedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    websiteCreatedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateManyInput = {
    id: string
    name: string
    subject: string
    body: string
    websiteCreatedAt?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    websiteCreatedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    websiteCreatedAt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailThreadCreateInput = {
    id: string
    messageId: string
    fromEmail: string
    toEmail: string
    subject: string
    body: string
    timestamp?: Date | string
    direction: string
    cc?: string | null
    bcc?: string | null
    Attachment?: AttachmentCreateNestedManyWithoutEmailThreadInput
    Case: CaseCreateNestedOneWithoutEmailThreadInput
  }

  export type EmailThreadUncheckedCreateInput = {
    id: string
    caseId: string
    messageId: string
    fromEmail: string
    toEmail: string
    subject: string
    body: string
    timestamp?: Date | string
    direction: string
    cc?: string | null
    bcc?: string | null
    Attachment?: AttachmentUncheckedCreateNestedManyWithoutEmailThreadInput
  }

  export type EmailThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    toEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    direction?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    Attachment?: AttachmentUpdateManyWithoutEmailThreadNestedInput
    Case?: CaseUpdateOneRequiredWithoutEmailThreadNestedInput
  }

  export type EmailThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    toEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    direction?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    Attachment?: AttachmentUncheckedUpdateManyWithoutEmailThreadNestedInput
  }

  export type EmailThreadCreateManyInput = {
    id: string
    caseId: string
    messageId: string
    fromEmail: string
    toEmail: string
    subject: string
    body: string
    timestamp?: Date | string
    direction: string
    cc?: string | null
    bcc?: string | null
  }

  export type EmailThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    toEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    direction?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    toEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    direction?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PassengerCreateInput = {
    id: string
    createdAt?: Date | string
    name?: string | null
    passportNumber?: string | null
    updatedAt?: Date | string | null
    dateOfBirth?: Date | string | null
    fullName?: string | null
    gender?: string | null
    nationality?: string | null
    passportId?: string | null
    status?: string | null
    Application: ApplicationCreateNestedOneWithoutPassengerInput
  }

  export type PassengerUncheckedCreateInput = {
    id: string
    applicationId: string
    createdAt?: Date | string
    name?: string | null
    passportNumber?: string | null
    updatedAt?: Date | string | null
    dateOfBirth?: Date | string | null
    fullName?: string | null
    gender?: string | null
    nationality?: string | null
    passportId?: string | null
    status?: string | null
  }

  export type PassengerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    Application?: ApplicationUpdateOneRequiredWithoutPassengerNestedInput
  }

  export type PassengerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PassengerCreateManyInput = {
    id: string
    applicationId: string
    createdAt?: Date | string
    name?: string | null
    passportNumber?: string | null
    updatedAt?: Date | string | null
    dateOfBirth?: Date | string | null
    fullName?: string | null
    gender?: string | null
    nationality?: string | null
    passportId?: string | null
    status?: string | null
  }

  export type PassengerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PassengerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RiskCreateInput = {
    id: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastUpdated?: Date | string | null
    Application: ApplicationCreateNestedOneWithoutRiskInput
    RiskActivity?: RiskActivityCreateNestedManyWithoutRiskInput
    RiskDocument?: RiskDocumentCreateNestedManyWithoutRiskInput
  }

  export type RiskUncheckedCreateInput = {
    id: string
    status: string
    applicationId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastUpdated?: Date | string | null
    RiskActivity?: RiskActivityUncheckedCreateNestedManyWithoutRiskInput
    RiskDocument?: RiskDocumentUncheckedCreateNestedManyWithoutRiskInput
  }

  export type RiskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Application?: ApplicationUpdateOneRequiredWithoutRiskNestedInput
    RiskActivity?: RiskActivityUpdateManyWithoutRiskNestedInput
    RiskDocument?: RiskDocumentUpdateManyWithoutRiskNestedInput
  }

  export type RiskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RiskActivity?: RiskActivityUncheckedUpdateManyWithoutRiskNestedInput
    RiskDocument?: RiskDocumentUncheckedUpdateManyWithoutRiskNestedInput
  }

  export type RiskCreateManyInput = {
    id: string
    status: string
    applicationId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastUpdated?: Date | string | null
  }

  export type RiskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskActivityCreateInput = {
    id: string
    createdAt?: Date | string
    description?: string | null
    type?: string | null
    details?: string | null
    timestamp?: Date | string | null
    title?: string | null
    Risk: RiskCreateNestedOneWithoutRiskActivityInput
  }

  export type RiskActivityUncheckedCreateInput = {
    id: string
    riskId: string
    createdAt?: Date | string
    description?: string | null
    type?: string | null
    details?: string | null
    timestamp?: Date | string | null
    title?: string | null
  }

  export type RiskActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    Risk?: RiskUpdateOneRequiredWithoutRiskActivityNestedInput
  }

  export type RiskActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RiskActivityCreateManyInput = {
    id: string
    riskId: string
    createdAt?: Date | string
    description?: string | null
    type?: string | null
    details?: string | null
    timestamp?: Date | string | null
    title?: string | null
  }

  export type RiskActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RiskActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RiskDocumentCreateInput = {
    id: string
    name: string
    createdAt?: Date | string
    status?: string
    updatedAt: Date | string
    type: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
    content: Uint8Array
    Risk: RiskCreateNestedOneWithoutRiskDocumentInput
  }

  export type RiskDocumentUncheckedCreateInput = {
    id: string
    name: string
    riskId: string
    createdAt?: Date | string
    status?: string
    updatedAt: Date | string
    type: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
    content: Uint8Array
  }

  export type RiskDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    Risk?: RiskUpdateOneRequiredWithoutRiskDocumentNestedInput
  }

  export type RiskDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    riskId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    content?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type RiskDocumentCreateManyInput = {
    id: string
    name: string
    riskId: string
    createdAt?: Date | string
    status?: string
    updatedAt: Date | string
    type: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
    content: Uint8Array
  }

  export type RiskDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    content?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type RiskDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    riskId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    content?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type StripeActivityCreateInput = {
    id: string
    title?: string | null
    amount?: number | null
    createdAt?: Date | string
    status?: string | null
    type?: string | null
    description?: string | null
    timestamp?: Date | string | null
    transactionId?: string | null
    govFeeRefund?: Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: string | null
    Application?: ApplicationCreateNestedOneWithoutStripeActivityInput
  }

  export type StripeActivityUncheckedCreateInput = {
    id: string
    title?: string | null
    amount?: number | null
    createdAt?: Date | string
    status?: string | null
    type?: string | null
    applicationId?: string | null
    description?: string | null
    timestamp?: Date | string | null
    transactionId?: string | null
    govFeeRefund?: Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: string | null
  }

  export type StripeActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    govFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    Application?: ApplicationUpdateOneWithoutStripeActivityNestedInput
  }

  export type StripeActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    govFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StripeActivityCreateManyInput = {
    id: string
    title?: string | null
    amount?: number | null
    createdAt?: Date | string
    status?: string | null
    type?: string | null
    applicationId?: string | null
    description?: string | null
    timestamp?: Date | string | null
    transactionId?: string | null
    govFeeRefund?: Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: string | null
  }

  export type StripeActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    govFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StripeActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    govFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateInput = {
    id: string
    title: string
    description?: string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    dueDate?: Date | string | null
    taskType?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt: Date | string
    taskId: string
    Application: ApplicationCreateNestedOneWithoutTaskInput
    TaskActivity?: TaskActivityCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id: string
    title: string
    description?: string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    dueDate?: Date | string | null
    taskType?: string | null
    status?: string
    applicationId: string
    createdAt?: Date | string
    updatedAt: Date | string
    taskId: string
    TaskActivity?: TaskActivityUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    Application?: ApplicationUpdateOneRequiredWithoutTaskNestedInput
    TaskActivity?: TaskActivityUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    TaskActivity?: TaskActivityUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id: string
    title: string
    description?: string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    dueDate?: Date | string | null
    taskType?: string | null
    status?: string
    applicationId: string
    createdAt?: Date | string
    updatedAt: Date | string
    taskId: string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskActivityCreateInput = {
    id: string
    status: string
    description: string
    timestamp?: Date | string
    createdAt?: Date | string
    Task: TaskCreateNestedOneWithoutTaskActivityInput
  }

  export type TaskActivityUncheckedCreateInput = {
    id: string
    taskId: string
    status: string
    description: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type TaskActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Task?: TaskUpdateOneRequiredWithoutTaskActivityNestedInput
  }

  export type TaskActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskActivityCreateManyInput = {
    id: string
    taskId: string
    status: string
    description: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type TaskActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id: string
    name: string
    email: string
    role: string
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    email: string
    role: string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    email: string
    role: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type VisaTypeCreateInput = {
    id: string
    name: string
    waitTime?: string | null
    fees?: number | null
    requiredDocuments?: string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    Application?: ApplicationCreateNestedManyWithoutVisaTypeInput
    Destination: DestinationCreateNestedOneWithoutVisaTypeInput
  }

  export type VisaTypeUncheckedCreateInput = {
    id: string
    name: string
    waitTime?: string | null
    fees?: number | null
    requiredDocuments?: string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    destinationId: string
    Application?: ApplicationUncheckedCreateNestedManyWithoutVisaTypeInput
  }

  export type VisaTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    waitTime?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    Application?: ApplicationUpdateManyWithoutVisaTypeNestedInput
    Destination?: DestinationUpdateOneRequiredWithoutVisaTypeNestedInput
  }

  export type VisaTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    waitTime?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    destinationId?: StringFieldUpdateOperationsInput | string
    Application?: ApplicationUncheckedUpdateManyWithoutVisaTypeNestedInput
  }

  export type VisaTypeCreateManyInput = {
    id: string
    name: string
    waitTime?: string | null
    fees?: number | null
    requiredDocuments?: string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    destinationId: string
  }

  export type VisaTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    waitTime?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VisaTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    waitTime?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    destinationId?: StringFieldUpdateOperationsInput | string
  }

  export type password_reset_tokensCreateInput = {
    id: string
    token: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    Account: AccountCreateNestedOneWithoutPassword_reset_tokensInput
  }

  export type password_reset_tokensUncheckedCreateInput = {
    id: string
    accountId: string
    token: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type password_reset_tokensUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Account?: AccountUpdateOneRequiredWithoutPassword_reset_tokensNestedInput
  }

  export type password_reset_tokensUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_reset_tokensCreateManyInput = {
    id: string
    accountId: string
    token: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type password_reset_tokensUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_reset_tokensUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsCreateInput = {
    id: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    Account: AccountCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateInput = {
    id: string
    accountId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Account?: AccountUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsCreateManyInput = {
    id: string
    accountId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ApplicationListRelationFilter = {
    every?: ApplicationWhereInput
    some?: ApplicationWhereInput
    none?: ApplicationWhereInput
  }

  export type CaseListRelationFilter = {
    every?: CaseWhereInput
    some?: CaseWhereInput
    none?: CaseWhereInput
  }

  export type Password_reset_tokensListRelationFilter = {
    every?: password_reset_tokensWhereInput
    some?: password_reset_tokensWhereInput
    none?: password_reset_tokensWhereInput
  }

  export type SessionsListRelationFilter = {
    every?: sessionsWhereInput
    some?: sessionsWhereInput
    none?: sessionsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type password_reset_tokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountEmailWebsiteCreatedAtCompoundUniqueInput = {
    email: string
    websiteCreatedAt: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    areaCode?: SortOrder
    phoneNumber?: SortOrder
    gender?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    websiteCreatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    areaCode?: SortOrder
    phoneNumber?: SortOrder
    gender?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    websiteCreatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    areaCode?: SortOrder
    phoneNumber?: SortOrder
    gender?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    websiteCreatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AccountScalarRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type DestinationScalarRelationFilter = {
    is?: DestinationWhereInput
    isNot?: DestinationWhereInput
  }

  export type VisaTypeScalarRelationFilter = {
    is?: VisaTypeWhereInput
    isNot?: VisaTypeWhereInput
  }

  export type ApplicationDocumentListRelationFilter = {
    every?: ApplicationDocumentWhereInput
    some?: ApplicationDocumentWhereInput
    none?: ApplicationDocumentWhereInput
  }

  export type CardHolderNullableScalarRelationFilter = {
    is?: CardHolderWhereInput | null
    isNot?: CardHolderWhereInput | null
  }

  export type PassengerListRelationFilter = {
    every?: PassengerWhereInput
    some?: PassengerWhereInput
    none?: PassengerWhereInput
  }

  export type RiskListRelationFilter = {
    every?: RiskWhereInput
    some?: RiskWhereInput
    none?: RiskWhereInput
  }

  export type StripeActivityListRelationFilter = {
    every?: StripeActivityWhereInput
    some?: StripeActivityWhereInput
    none?: StripeActivityWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type ApplicationDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PassengerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RiskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StripeActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    destinationId?: SortOrder
    visaTypeId?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicationId?: SortOrder
    passengerCount?: SortOrder
    stayingEnd?: SortOrder
    stayingStart?: SortOrder
    total?: SortOrder
    cancellationDetails?: SortOrder
    cancellationReason?: SortOrder
    cancelledAt?: SortOrder
    cancelledBy?: SortOrder
    applyDate?: SortOrder
    paymentStatus?: SortOrder
  }

  export type ApplicationAvgOrderByAggregateInput = {
    passengerCount?: SortOrder
    total?: SortOrder
  }

  export type ApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    destinationId?: SortOrder
    visaTypeId?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicationId?: SortOrder
    passengerCount?: SortOrder
    stayingEnd?: SortOrder
    stayingStart?: SortOrder
    total?: SortOrder
    cancellationDetails?: SortOrder
    cancellationReason?: SortOrder
    cancelledAt?: SortOrder
    cancelledBy?: SortOrder
    applyDate?: SortOrder
    paymentStatus?: SortOrder
  }

  export type ApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    destinationId?: SortOrder
    visaTypeId?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicationId?: SortOrder
    passengerCount?: SortOrder
    stayingEnd?: SortOrder
    stayingStart?: SortOrder
    total?: SortOrder
    cancellationDetails?: SortOrder
    cancellationReason?: SortOrder
    cancelledAt?: SortOrder
    cancelledBy?: SortOrder
    applyDate?: SortOrder
    paymentStatus?: SortOrder
  }

  export type ApplicationSumOrderByAggregateInput = {
    passengerCount?: SortOrder
    total?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type ApplicationScalarRelationFilter = {
    is?: ApplicationWhereInput
    isNot?: ApplicationWhereInput
  }

  export type DocumentMappingNullableScalarRelationFilter = {
    is?: DocumentMappingWhereInput | null
    isNot?: DocumentMappingWhereInput | null
  }

  export type ApplicationDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    content?: SortOrder
    status?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    content?: SortOrder
    status?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    content?: SortOrder
    status?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type EmailThreadScalarRelationFilter = {
    is?: EmailThreadWhereInput
    isNot?: EmailThreadWhereInput
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    emailThreadId?: SortOrder
    filename?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    emailThreadId?: SortOrder
    filename?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    emailThreadId?: SortOrder
    filename?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CardHolderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cardType?: SortOrder
    cardNumber?: SortOrder
    address?: SortOrder
    zipcode?: SortOrder
    applicationId?: SortOrder
  }

  export type CardHolderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cardType?: SortOrder
    cardNumber?: SortOrder
    address?: SortOrder
    zipcode?: SortOrder
    applicationId?: SortOrder
  }

  export type CardHolderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cardType?: SortOrder
    cardNumber?: SortOrder
    address?: SortOrder
    zipcode?: SortOrder
    applicationId?: SortOrder
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type ApplicationNullableScalarRelationFilter = {
    is?: ApplicationWhereInput | null
    isNot?: ApplicationWhereInput | null
  }

  export type EmailThreadListRelationFilter = {
    every?: EmailThreadWhereInput
    some?: EmailThreadWhereInput
    none?: EmailThreadWhereInput
  }

  export type EmailThreadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaseCountOrderByAggregateInput = {
    id?: SortOrder
    gmailThreadId?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    lastUpdate?: SortOrder
    websiteCreatedAt?: SortOrder
    accountId?: SortOrder
    applicationId?: SortOrder
    assignedTo?: SortOrder
    topic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaseMaxOrderByAggregateInput = {
    id?: SortOrder
    gmailThreadId?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    lastUpdate?: SortOrder
    websiteCreatedAt?: SortOrder
    accountId?: SortOrder
    applicationId?: SortOrder
    assignedTo?: SortOrder
    topic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaseMinOrderByAggregateInput = {
    id?: SortOrder
    gmailThreadId?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    lastUpdate?: SortOrder
    websiteCreatedAt?: SortOrder
    accountId?: SortOrder
    applicationId?: SortOrder
    assignedTo?: SortOrder
    topic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CaseSequenceCountOrderByAggregateInput = {
    year?: SortOrder
    currentSequence?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaseSequenceAvgOrderByAggregateInput = {
    year?: SortOrder
    currentSequence?: SortOrder
  }

  export type CaseSequenceMaxOrderByAggregateInput = {
    year?: SortOrder
    currentSequence?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaseSequenceMinOrderByAggregateInput = {
    year?: SortOrder
    currentSequence?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaseSequenceSumOrderByAggregateInput = {
    year?: SortOrder
    currentSequence?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CustomRequirementCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    passengerId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomRequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    passengerId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomRequirementMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    passengerId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
  }

  export type VisaTypeListRelationFilter = {
    every?: VisaTypeWhereInput
    some?: VisaTypeWhereInput
    none?: VisaTypeWhereInput
  }

  export type VisaTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DestinationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type DestinationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type DestinationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type ApplicationDocumentScalarRelationFilter = {
    is?: ApplicationDocumentWhereInput
    isNot?: ApplicationDocumentWhereInput
  }

  export type DocumentMappingCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    mappedTo?: SortOrder
    isInvalid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    mappedTo?: SortOrder
    isInvalid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMappingMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    mappedTo?: SortOrder
    isInvalid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    websiteCreatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    websiteCreatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    websiteCreatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type CaseScalarRelationFilter = {
    is?: CaseWhereInput
    isNot?: CaseWhereInput
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailThreadCountOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrder
    toEmail?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    timestamp?: SortOrder
    direction?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
  }

  export type EmailThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrder
    toEmail?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    timestamp?: SortOrder
    direction?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
  }

  export type EmailThreadMinOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    messageId?: SortOrder
    fromEmail?: SortOrder
    toEmail?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    timestamp?: SortOrder
    direction?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
  }

  export type PassengerCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    passportNumber?: SortOrder
    updatedAt?: SortOrder
    dateOfBirth?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    passportId?: SortOrder
    status?: SortOrder
  }

  export type PassengerMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    passportNumber?: SortOrder
    updatedAt?: SortOrder
    dateOfBirth?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    passportId?: SortOrder
    status?: SortOrder
  }

  export type PassengerMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    passportNumber?: SortOrder
    updatedAt?: SortOrder
    dateOfBirth?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    passportId?: SortOrder
    status?: SortOrder
  }

  export type RiskActivityListRelationFilter = {
    every?: RiskActivityWhereInput
    some?: RiskActivityWhereInput
    none?: RiskActivityWhereInput
  }

  export type RiskDocumentListRelationFilter = {
    every?: RiskDocumentWhereInput
    some?: RiskDocumentWhereInput
    none?: RiskDocumentWhereInput
  }

  export type RiskActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RiskDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RiskCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
  }

  export type RiskMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
  }

  export type RiskMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdated?: SortOrder
  }

  export type RiskScalarRelationFilter = {
    is?: RiskWhereInput
    isNot?: RiskWhereInput
  }

  export type RiskActivityCountOrderByAggregateInput = {
    id?: SortOrder
    riskId?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    type?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    title?: SortOrder
  }

  export type RiskActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    riskId?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    type?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    title?: SortOrder
  }

  export type RiskActivityMinOrderByAggregateInput = {
    id?: SortOrder
    riskId?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    type?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    title?: SortOrder
  }

  export type RiskDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    riskId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    content?: SortOrder
  }

  export type RiskDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    riskId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    content?: SortOrder
  }

  export type RiskDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    riskId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    content?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type StripeActivityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    type?: SortOrder
    applicationId?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    transactionId?: SortOrder
    govFeeRefund?: SortOrder
    serviceFeeRefund?: SortOrder
    originalTransactionId?: SortOrder
  }

  export type StripeActivityAvgOrderByAggregateInput = {
    amount?: SortOrder
    govFeeRefund?: SortOrder
    serviceFeeRefund?: SortOrder
  }

  export type StripeActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    type?: SortOrder
    applicationId?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    transactionId?: SortOrder
    govFeeRefund?: SortOrder
    serviceFeeRefund?: SortOrder
    originalTransactionId?: SortOrder
  }

  export type StripeActivityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    type?: SortOrder
    applicationId?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    transactionId?: SortOrder
    govFeeRefund?: SortOrder
    serviceFeeRefund?: SortOrder
    originalTransactionId?: SortOrder
  }

  export type StripeActivitySumOrderByAggregateInput = {
    amount?: SortOrder
    govFeeRefund?: SortOrder
    serviceFeeRefund?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type TaskActivityListRelationFilter = {
    every?: TaskActivityWhereInput
    some?: TaskActivityWhereInput
    none?: TaskActivityWhereInput
  }

  export type TaskActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assignedTo?: SortOrder
    assignedToEmail?: SortOrder
    dueDate?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assignedTo?: SortOrder
    assignedToEmail?: SortOrder
    dueDate?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    assignedTo?: SortOrder
    assignedToEmail?: SortOrder
    dueDate?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    applicationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taskId?: SortOrder
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskActivityCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskActivityMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type VisaTypeNameDestinationIdCompoundUniqueInput = {
    name: string
    destinationId: string
  }

  export type VisaTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    waitTime?: SortOrder
    fees?: SortOrder
    requiredDocuments?: SortOrder
    allowedNationalities?: SortOrder
    destinationId?: SortOrder
  }

  export type VisaTypeAvgOrderByAggregateInput = {
    fees?: SortOrder
  }

  export type VisaTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    waitTime?: SortOrder
    fees?: SortOrder
    requiredDocuments?: SortOrder
    destinationId?: SortOrder
  }

  export type VisaTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    waitTime?: SortOrder
    fees?: SortOrder
    requiredDocuments?: SortOrder
    destinationId?: SortOrder
  }

  export type VisaTypeSumOrderByAggregateInput = {
    fees?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type password_reset_tokensCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type password_reset_tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type password_reset_tokensMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApplicationCreateNestedManyWithoutAccountInput = {
    create?: XOR<ApplicationCreateWithoutAccountInput, ApplicationUncheckedCreateWithoutAccountInput> | ApplicationCreateWithoutAccountInput[] | ApplicationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutAccountInput | ApplicationCreateOrConnectWithoutAccountInput[]
    createMany?: ApplicationCreateManyAccountInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type CaseCreateNestedManyWithoutAccountInput = {
    create?: XOR<CaseCreateWithoutAccountInput, CaseUncheckedCreateWithoutAccountInput> | CaseCreateWithoutAccountInput[] | CaseUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutAccountInput | CaseCreateOrConnectWithoutAccountInput[]
    createMany?: CaseCreateManyAccountInputEnvelope
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
  }

  export type password_reset_tokensCreateNestedManyWithoutAccountInput = {
    create?: XOR<password_reset_tokensCreateWithoutAccountInput, password_reset_tokensUncheckedCreateWithoutAccountInput> | password_reset_tokensCreateWithoutAccountInput[] | password_reset_tokensUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: password_reset_tokensCreateOrConnectWithoutAccountInput | password_reset_tokensCreateOrConnectWithoutAccountInput[]
    createMany?: password_reset_tokensCreateManyAccountInputEnvelope
    connect?: password_reset_tokensWhereUniqueInput | password_reset_tokensWhereUniqueInput[]
  }

  export type sessionsCreateNestedManyWithoutAccountInput = {
    create?: XOR<sessionsCreateWithoutAccountInput, sessionsUncheckedCreateWithoutAccountInput> | sessionsCreateWithoutAccountInput[] | sessionsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutAccountInput | sessionsCreateOrConnectWithoutAccountInput[]
    createMany?: sessionsCreateManyAccountInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ApplicationCreateWithoutAccountInput, ApplicationUncheckedCreateWithoutAccountInput> | ApplicationCreateWithoutAccountInput[] | ApplicationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutAccountInput | ApplicationCreateOrConnectWithoutAccountInput[]
    createMany?: ApplicationCreateManyAccountInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type CaseUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<CaseCreateWithoutAccountInput, CaseUncheckedCreateWithoutAccountInput> | CaseCreateWithoutAccountInput[] | CaseUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutAccountInput | CaseCreateOrConnectWithoutAccountInput[]
    createMany?: CaseCreateManyAccountInputEnvelope
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
  }

  export type password_reset_tokensUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<password_reset_tokensCreateWithoutAccountInput, password_reset_tokensUncheckedCreateWithoutAccountInput> | password_reset_tokensCreateWithoutAccountInput[] | password_reset_tokensUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: password_reset_tokensCreateOrConnectWithoutAccountInput | password_reset_tokensCreateOrConnectWithoutAccountInput[]
    createMany?: password_reset_tokensCreateManyAccountInputEnvelope
    connect?: password_reset_tokensWhereUniqueInput | password_reset_tokensWhereUniqueInput[]
  }

  export type sessionsUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<sessionsCreateWithoutAccountInput, sessionsUncheckedCreateWithoutAccountInput> | sessionsCreateWithoutAccountInput[] | sessionsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutAccountInput | sessionsCreateOrConnectWithoutAccountInput[]
    createMany?: sessionsCreateManyAccountInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ApplicationUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ApplicationCreateWithoutAccountInput, ApplicationUncheckedCreateWithoutAccountInput> | ApplicationCreateWithoutAccountInput[] | ApplicationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutAccountInput | ApplicationCreateOrConnectWithoutAccountInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutAccountInput | ApplicationUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ApplicationCreateManyAccountInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutAccountInput | ApplicationUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutAccountInput | ApplicationUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type CaseUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CaseCreateWithoutAccountInput, CaseUncheckedCreateWithoutAccountInput> | CaseCreateWithoutAccountInput[] | CaseUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutAccountInput | CaseCreateOrConnectWithoutAccountInput[]
    upsert?: CaseUpsertWithWhereUniqueWithoutAccountInput | CaseUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CaseCreateManyAccountInputEnvelope
    set?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    disconnect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    delete?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    update?: CaseUpdateWithWhereUniqueWithoutAccountInput | CaseUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CaseUpdateManyWithWhereWithoutAccountInput | CaseUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CaseScalarWhereInput | CaseScalarWhereInput[]
  }

  export type password_reset_tokensUpdateManyWithoutAccountNestedInput = {
    create?: XOR<password_reset_tokensCreateWithoutAccountInput, password_reset_tokensUncheckedCreateWithoutAccountInput> | password_reset_tokensCreateWithoutAccountInput[] | password_reset_tokensUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: password_reset_tokensCreateOrConnectWithoutAccountInput | password_reset_tokensCreateOrConnectWithoutAccountInput[]
    upsert?: password_reset_tokensUpsertWithWhereUniqueWithoutAccountInput | password_reset_tokensUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: password_reset_tokensCreateManyAccountInputEnvelope
    set?: password_reset_tokensWhereUniqueInput | password_reset_tokensWhereUniqueInput[]
    disconnect?: password_reset_tokensWhereUniqueInput | password_reset_tokensWhereUniqueInput[]
    delete?: password_reset_tokensWhereUniqueInput | password_reset_tokensWhereUniqueInput[]
    connect?: password_reset_tokensWhereUniqueInput | password_reset_tokensWhereUniqueInput[]
    update?: password_reset_tokensUpdateWithWhereUniqueWithoutAccountInput | password_reset_tokensUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: password_reset_tokensUpdateManyWithWhereWithoutAccountInput | password_reset_tokensUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: password_reset_tokensScalarWhereInput | password_reset_tokensScalarWhereInput[]
  }

  export type sessionsUpdateManyWithoutAccountNestedInput = {
    create?: XOR<sessionsCreateWithoutAccountInput, sessionsUncheckedCreateWithoutAccountInput> | sessionsCreateWithoutAccountInput[] | sessionsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutAccountInput | sessionsCreateOrConnectWithoutAccountInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutAccountInput | sessionsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: sessionsCreateManyAccountInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutAccountInput | sessionsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutAccountInput | sessionsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ApplicationCreateWithoutAccountInput, ApplicationUncheckedCreateWithoutAccountInput> | ApplicationCreateWithoutAccountInput[] | ApplicationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutAccountInput | ApplicationCreateOrConnectWithoutAccountInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutAccountInput | ApplicationUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ApplicationCreateManyAccountInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutAccountInput | ApplicationUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutAccountInput | ApplicationUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type CaseUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CaseCreateWithoutAccountInput, CaseUncheckedCreateWithoutAccountInput> | CaseCreateWithoutAccountInput[] | CaseUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutAccountInput | CaseCreateOrConnectWithoutAccountInput[]
    upsert?: CaseUpsertWithWhereUniqueWithoutAccountInput | CaseUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CaseCreateManyAccountInputEnvelope
    set?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    disconnect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    delete?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    update?: CaseUpdateWithWhereUniqueWithoutAccountInput | CaseUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CaseUpdateManyWithWhereWithoutAccountInput | CaseUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CaseScalarWhereInput | CaseScalarWhereInput[]
  }

  export type password_reset_tokensUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<password_reset_tokensCreateWithoutAccountInput, password_reset_tokensUncheckedCreateWithoutAccountInput> | password_reset_tokensCreateWithoutAccountInput[] | password_reset_tokensUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: password_reset_tokensCreateOrConnectWithoutAccountInput | password_reset_tokensCreateOrConnectWithoutAccountInput[]
    upsert?: password_reset_tokensUpsertWithWhereUniqueWithoutAccountInput | password_reset_tokensUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: password_reset_tokensCreateManyAccountInputEnvelope
    set?: password_reset_tokensWhereUniqueInput | password_reset_tokensWhereUniqueInput[]
    disconnect?: password_reset_tokensWhereUniqueInput | password_reset_tokensWhereUniqueInput[]
    delete?: password_reset_tokensWhereUniqueInput | password_reset_tokensWhereUniqueInput[]
    connect?: password_reset_tokensWhereUniqueInput | password_reset_tokensWhereUniqueInput[]
    update?: password_reset_tokensUpdateWithWhereUniqueWithoutAccountInput | password_reset_tokensUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: password_reset_tokensUpdateManyWithWhereWithoutAccountInput | password_reset_tokensUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: password_reset_tokensScalarWhereInput | password_reset_tokensScalarWhereInput[]
  }

  export type sessionsUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<sessionsCreateWithoutAccountInput, sessionsUncheckedCreateWithoutAccountInput> | sessionsCreateWithoutAccountInput[] | sessionsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutAccountInput | sessionsCreateOrConnectWithoutAccountInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutAccountInput | sessionsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: sessionsCreateManyAccountInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutAccountInput | sessionsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutAccountInput | sessionsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutApplicationInput = {
    create?: XOR<AccountCreateWithoutApplicationInput, AccountUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutApplicationInput
    connect?: AccountWhereUniqueInput
  }

  export type DestinationCreateNestedOneWithoutApplicationInput = {
    create?: XOR<DestinationCreateWithoutApplicationInput, DestinationUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutApplicationInput
    connect?: DestinationWhereUniqueInput
  }

  export type VisaTypeCreateNestedOneWithoutApplicationInput = {
    create?: XOR<VisaTypeCreateWithoutApplicationInput, VisaTypeUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: VisaTypeCreateOrConnectWithoutApplicationInput
    connect?: VisaTypeWhereUniqueInput
  }

  export type ApplicationDocumentCreateNestedManyWithoutApplicationInput = {
    create?: XOR<ApplicationDocumentCreateWithoutApplicationInput, ApplicationDocumentUncheckedCreateWithoutApplicationInput> | ApplicationDocumentCreateWithoutApplicationInput[] | ApplicationDocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: ApplicationDocumentCreateOrConnectWithoutApplicationInput | ApplicationDocumentCreateOrConnectWithoutApplicationInput[]
    createMany?: ApplicationDocumentCreateManyApplicationInputEnvelope
    connect?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
  }

  export type CardHolderCreateNestedOneWithoutApplicationInput = {
    create?: XOR<CardHolderCreateWithoutApplicationInput, CardHolderUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: CardHolderCreateOrConnectWithoutApplicationInput
    connect?: CardHolderWhereUniqueInput
  }

  export type CaseCreateNestedManyWithoutApplicationInput = {
    create?: XOR<CaseCreateWithoutApplicationInput, CaseUncheckedCreateWithoutApplicationInput> | CaseCreateWithoutApplicationInput[] | CaseUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutApplicationInput | CaseCreateOrConnectWithoutApplicationInput[]
    createMany?: CaseCreateManyApplicationInputEnvelope
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
  }

  export type PassengerCreateNestedManyWithoutApplicationInput = {
    create?: XOR<PassengerCreateWithoutApplicationInput, PassengerUncheckedCreateWithoutApplicationInput> | PassengerCreateWithoutApplicationInput[] | PassengerUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: PassengerCreateOrConnectWithoutApplicationInput | PassengerCreateOrConnectWithoutApplicationInput[]
    createMany?: PassengerCreateManyApplicationInputEnvelope
    connect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
  }

  export type RiskCreateNestedManyWithoutApplicationInput = {
    create?: XOR<RiskCreateWithoutApplicationInput, RiskUncheckedCreateWithoutApplicationInput> | RiskCreateWithoutApplicationInput[] | RiskUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: RiskCreateOrConnectWithoutApplicationInput | RiskCreateOrConnectWithoutApplicationInput[]
    createMany?: RiskCreateManyApplicationInputEnvelope
    connect?: RiskWhereUniqueInput | RiskWhereUniqueInput[]
  }

  export type StripeActivityCreateNestedManyWithoutApplicationInput = {
    create?: XOR<StripeActivityCreateWithoutApplicationInput, StripeActivityUncheckedCreateWithoutApplicationInput> | StripeActivityCreateWithoutApplicationInput[] | StripeActivityUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: StripeActivityCreateOrConnectWithoutApplicationInput | StripeActivityCreateOrConnectWithoutApplicationInput[]
    createMany?: StripeActivityCreateManyApplicationInputEnvelope
    connect?: StripeActivityWhereUniqueInput | StripeActivityWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutApplicationInput = {
    create?: XOR<TaskCreateWithoutApplicationInput, TaskUncheckedCreateWithoutApplicationInput> | TaskCreateWithoutApplicationInput[] | TaskUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutApplicationInput | TaskCreateOrConnectWithoutApplicationInput[]
    createMany?: TaskCreateManyApplicationInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<ApplicationDocumentCreateWithoutApplicationInput, ApplicationDocumentUncheckedCreateWithoutApplicationInput> | ApplicationDocumentCreateWithoutApplicationInput[] | ApplicationDocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: ApplicationDocumentCreateOrConnectWithoutApplicationInput | ApplicationDocumentCreateOrConnectWithoutApplicationInput[]
    createMany?: ApplicationDocumentCreateManyApplicationInputEnvelope
    connect?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
  }

  export type CardHolderUncheckedCreateNestedOneWithoutApplicationInput = {
    create?: XOR<CardHolderCreateWithoutApplicationInput, CardHolderUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: CardHolderCreateOrConnectWithoutApplicationInput
    connect?: CardHolderWhereUniqueInput
  }

  export type CaseUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<CaseCreateWithoutApplicationInput, CaseUncheckedCreateWithoutApplicationInput> | CaseCreateWithoutApplicationInput[] | CaseUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutApplicationInput | CaseCreateOrConnectWithoutApplicationInput[]
    createMany?: CaseCreateManyApplicationInputEnvelope
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
  }

  export type PassengerUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<PassengerCreateWithoutApplicationInput, PassengerUncheckedCreateWithoutApplicationInput> | PassengerCreateWithoutApplicationInput[] | PassengerUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: PassengerCreateOrConnectWithoutApplicationInput | PassengerCreateOrConnectWithoutApplicationInput[]
    createMany?: PassengerCreateManyApplicationInputEnvelope
    connect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
  }

  export type RiskUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<RiskCreateWithoutApplicationInput, RiskUncheckedCreateWithoutApplicationInput> | RiskCreateWithoutApplicationInput[] | RiskUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: RiskCreateOrConnectWithoutApplicationInput | RiskCreateOrConnectWithoutApplicationInput[]
    createMany?: RiskCreateManyApplicationInputEnvelope
    connect?: RiskWhereUniqueInput | RiskWhereUniqueInput[]
  }

  export type StripeActivityUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<StripeActivityCreateWithoutApplicationInput, StripeActivityUncheckedCreateWithoutApplicationInput> | StripeActivityCreateWithoutApplicationInput[] | StripeActivityUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: StripeActivityCreateOrConnectWithoutApplicationInput | StripeActivityCreateOrConnectWithoutApplicationInput[]
    createMany?: StripeActivityCreateManyApplicationInputEnvelope
    connect?: StripeActivityWhereUniqueInput | StripeActivityWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<TaskCreateWithoutApplicationInput, TaskUncheckedCreateWithoutApplicationInput> | TaskCreateWithoutApplicationInput[] | TaskUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutApplicationInput | TaskCreateOrConnectWithoutApplicationInput[]
    createMany?: TaskCreateManyApplicationInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUpdateOneRequiredWithoutApplicationNestedInput = {
    create?: XOR<AccountCreateWithoutApplicationInput, AccountUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutApplicationInput
    upsert?: AccountUpsertWithoutApplicationInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutApplicationInput, AccountUpdateWithoutApplicationInput>, AccountUncheckedUpdateWithoutApplicationInput>
  }

  export type DestinationUpdateOneRequiredWithoutApplicationNestedInput = {
    create?: XOR<DestinationCreateWithoutApplicationInput, DestinationUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutApplicationInput
    upsert?: DestinationUpsertWithoutApplicationInput
    connect?: DestinationWhereUniqueInput
    update?: XOR<XOR<DestinationUpdateToOneWithWhereWithoutApplicationInput, DestinationUpdateWithoutApplicationInput>, DestinationUncheckedUpdateWithoutApplicationInput>
  }

  export type VisaTypeUpdateOneRequiredWithoutApplicationNestedInput = {
    create?: XOR<VisaTypeCreateWithoutApplicationInput, VisaTypeUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: VisaTypeCreateOrConnectWithoutApplicationInput
    upsert?: VisaTypeUpsertWithoutApplicationInput
    connect?: VisaTypeWhereUniqueInput
    update?: XOR<XOR<VisaTypeUpdateToOneWithWhereWithoutApplicationInput, VisaTypeUpdateWithoutApplicationInput>, VisaTypeUncheckedUpdateWithoutApplicationInput>
  }

  export type ApplicationDocumentUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<ApplicationDocumentCreateWithoutApplicationInput, ApplicationDocumentUncheckedCreateWithoutApplicationInput> | ApplicationDocumentCreateWithoutApplicationInput[] | ApplicationDocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: ApplicationDocumentCreateOrConnectWithoutApplicationInput | ApplicationDocumentCreateOrConnectWithoutApplicationInput[]
    upsert?: ApplicationDocumentUpsertWithWhereUniqueWithoutApplicationInput | ApplicationDocumentUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: ApplicationDocumentCreateManyApplicationInputEnvelope
    set?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    disconnect?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    delete?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    connect?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    update?: ApplicationDocumentUpdateWithWhereUniqueWithoutApplicationInput | ApplicationDocumentUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: ApplicationDocumentUpdateManyWithWhereWithoutApplicationInput | ApplicationDocumentUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: ApplicationDocumentScalarWhereInput | ApplicationDocumentScalarWhereInput[]
  }

  export type CardHolderUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<CardHolderCreateWithoutApplicationInput, CardHolderUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: CardHolderCreateOrConnectWithoutApplicationInput
    upsert?: CardHolderUpsertWithoutApplicationInput
    disconnect?: CardHolderWhereInput | boolean
    delete?: CardHolderWhereInput | boolean
    connect?: CardHolderWhereUniqueInput
    update?: XOR<XOR<CardHolderUpdateToOneWithWhereWithoutApplicationInput, CardHolderUpdateWithoutApplicationInput>, CardHolderUncheckedUpdateWithoutApplicationInput>
  }

  export type CaseUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<CaseCreateWithoutApplicationInput, CaseUncheckedCreateWithoutApplicationInput> | CaseCreateWithoutApplicationInput[] | CaseUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutApplicationInput | CaseCreateOrConnectWithoutApplicationInput[]
    upsert?: CaseUpsertWithWhereUniqueWithoutApplicationInput | CaseUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: CaseCreateManyApplicationInputEnvelope
    set?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    disconnect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    delete?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    update?: CaseUpdateWithWhereUniqueWithoutApplicationInput | CaseUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: CaseUpdateManyWithWhereWithoutApplicationInput | CaseUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: CaseScalarWhereInput | CaseScalarWhereInput[]
  }

  export type PassengerUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<PassengerCreateWithoutApplicationInput, PassengerUncheckedCreateWithoutApplicationInput> | PassengerCreateWithoutApplicationInput[] | PassengerUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: PassengerCreateOrConnectWithoutApplicationInput | PassengerCreateOrConnectWithoutApplicationInput[]
    upsert?: PassengerUpsertWithWhereUniqueWithoutApplicationInput | PassengerUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: PassengerCreateManyApplicationInputEnvelope
    set?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    disconnect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    delete?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    connect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    update?: PassengerUpdateWithWhereUniqueWithoutApplicationInput | PassengerUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: PassengerUpdateManyWithWhereWithoutApplicationInput | PassengerUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: PassengerScalarWhereInput | PassengerScalarWhereInput[]
  }

  export type RiskUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<RiskCreateWithoutApplicationInput, RiskUncheckedCreateWithoutApplicationInput> | RiskCreateWithoutApplicationInput[] | RiskUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: RiskCreateOrConnectWithoutApplicationInput | RiskCreateOrConnectWithoutApplicationInput[]
    upsert?: RiskUpsertWithWhereUniqueWithoutApplicationInput | RiskUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: RiskCreateManyApplicationInputEnvelope
    set?: RiskWhereUniqueInput | RiskWhereUniqueInput[]
    disconnect?: RiskWhereUniqueInput | RiskWhereUniqueInput[]
    delete?: RiskWhereUniqueInput | RiskWhereUniqueInput[]
    connect?: RiskWhereUniqueInput | RiskWhereUniqueInput[]
    update?: RiskUpdateWithWhereUniqueWithoutApplicationInput | RiskUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: RiskUpdateManyWithWhereWithoutApplicationInput | RiskUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: RiskScalarWhereInput | RiskScalarWhereInput[]
  }

  export type StripeActivityUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<StripeActivityCreateWithoutApplicationInput, StripeActivityUncheckedCreateWithoutApplicationInput> | StripeActivityCreateWithoutApplicationInput[] | StripeActivityUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: StripeActivityCreateOrConnectWithoutApplicationInput | StripeActivityCreateOrConnectWithoutApplicationInput[]
    upsert?: StripeActivityUpsertWithWhereUniqueWithoutApplicationInput | StripeActivityUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: StripeActivityCreateManyApplicationInputEnvelope
    set?: StripeActivityWhereUniqueInput | StripeActivityWhereUniqueInput[]
    disconnect?: StripeActivityWhereUniqueInput | StripeActivityWhereUniqueInput[]
    delete?: StripeActivityWhereUniqueInput | StripeActivityWhereUniqueInput[]
    connect?: StripeActivityWhereUniqueInput | StripeActivityWhereUniqueInput[]
    update?: StripeActivityUpdateWithWhereUniqueWithoutApplicationInput | StripeActivityUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: StripeActivityUpdateManyWithWhereWithoutApplicationInput | StripeActivityUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: StripeActivityScalarWhereInput | StripeActivityScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<TaskCreateWithoutApplicationInput, TaskUncheckedCreateWithoutApplicationInput> | TaskCreateWithoutApplicationInput[] | TaskUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutApplicationInput | TaskCreateOrConnectWithoutApplicationInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutApplicationInput | TaskUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: TaskCreateManyApplicationInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutApplicationInput | TaskUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutApplicationInput | TaskUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<ApplicationDocumentCreateWithoutApplicationInput, ApplicationDocumentUncheckedCreateWithoutApplicationInput> | ApplicationDocumentCreateWithoutApplicationInput[] | ApplicationDocumentUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: ApplicationDocumentCreateOrConnectWithoutApplicationInput | ApplicationDocumentCreateOrConnectWithoutApplicationInput[]
    upsert?: ApplicationDocumentUpsertWithWhereUniqueWithoutApplicationInput | ApplicationDocumentUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: ApplicationDocumentCreateManyApplicationInputEnvelope
    set?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    disconnect?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    delete?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    connect?: ApplicationDocumentWhereUniqueInput | ApplicationDocumentWhereUniqueInput[]
    update?: ApplicationDocumentUpdateWithWhereUniqueWithoutApplicationInput | ApplicationDocumentUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: ApplicationDocumentUpdateManyWithWhereWithoutApplicationInput | ApplicationDocumentUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: ApplicationDocumentScalarWhereInput | ApplicationDocumentScalarWhereInput[]
  }

  export type CardHolderUncheckedUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<CardHolderCreateWithoutApplicationInput, CardHolderUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: CardHolderCreateOrConnectWithoutApplicationInput
    upsert?: CardHolderUpsertWithoutApplicationInput
    disconnect?: CardHolderWhereInput | boolean
    delete?: CardHolderWhereInput | boolean
    connect?: CardHolderWhereUniqueInput
    update?: XOR<XOR<CardHolderUpdateToOneWithWhereWithoutApplicationInput, CardHolderUpdateWithoutApplicationInput>, CardHolderUncheckedUpdateWithoutApplicationInput>
  }

  export type CaseUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<CaseCreateWithoutApplicationInput, CaseUncheckedCreateWithoutApplicationInput> | CaseCreateWithoutApplicationInput[] | CaseUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: CaseCreateOrConnectWithoutApplicationInput | CaseCreateOrConnectWithoutApplicationInput[]
    upsert?: CaseUpsertWithWhereUniqueWithoutApplicationInput | CaseUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: CaseCreateManyApplicationInputEnvelope
    set?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    disconnect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    delete?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    connect?: CaseWhereUniqueInput | CaseWhereUniqueInput[]
    update?: CaseUpdateWithWhereUniqueWithoutApplicationInput | CaseUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: CaseUpdateManyWithWhereWithoutApplicationInput | CaseUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: CaseScalarWhereInput | CaseScalarWhereInput[]
  }

  export type PassengerUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<PassengerCreateWithoutApplicationInput, PassengerUncheckedCreateWithoutApplicationInput> | PassengerCreateWithoutApplicationInput[] | PassengerUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: PassengerCreateOrConnectWithoutApplicationInput | PassengerCreateOrConnectWithoutApplicationInput[]
    upsert?: PassengerUpsertWithWhereUniqueWithoutApplicationInput | PassengerUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: PassengerCreateManyApplicationInputEnvelope
    set?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    disconnect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    delete?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    connect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    update?: PassengerUpdateWithWhereUniqueWithoutApplicationInput | PassengerUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: PassengerUpdateManyWithWhereWithoutApplicationInput | PassengerUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: PassengerScalarWhereInput | PassengerScalarWhereInput[]
  }

  export type RiskUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<RiskCreateWithoutApplicationInput, RiskUncheckedCreateWithoutApplicationInput> | RiskCreateWithoutApplicationInput[] | RiskUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: RiskCreateOrConnectWithoutApplicationInput | RiskCreateOrConnectWithoutApplicationInput[]
    upsert?: RiskUpsertWithWhereUniqueWithoutApplicationInput | RiskUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: RiskCreateManyApplicationInputEnvelope
    set?: RiskWhereUniqueInput | RiskWhereUniqueInput[]
    disconnect?: RiskWhereUniqueInput | RiskWhereUniqueInput[]
    delete?: RiskWhereUniqueInput | RiskWhereUniqueInput[]
    connect?: RiskWhereUniqueInput | RiskWhereUniqueInput[]
    update?: RiskUpdateWithWhereUniqueWithoutApplicationInput | RiskUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: RiskUpdateManyWithWhereWithoutApplicationInput | RiskUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: RiskScalarWhereInput | RiskScalarWhereInput[]
  }

  export type StripeActivityUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<StripeActivityCreateWithoutApplicationInput, StripeActivityUncheckedCreateWithoutApplicationInput> | StripeActivityCreateWithoutApplicationInput[] | StripeActivityUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: StripeActivityCreateOrConnectWithoutApplicationInput | StripeActivityCreateOrConnectWithoutApplicationInput[]
    upsert?: StripeActivityUpsertWithWhereUniqueWithoutApplicationInput | StripeActivityUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: StripeActivityCreateManyApplicationInputEnvelope
    set?: StripeActivityWhereUniqueInput | StripeActivityWhereUniqueInput[]
    disconnect?: StripeActivityWhereUniqueInput | StripeActivityWhereUniqueInput[]
    delete?: StripeActivityWhereUniqueInput | StripeActivityWhereUniqueInput[]
    connect?: StripeActivityWhereUniqueInput | StripeActivityWhereUniqueInput[]
    update?: StripeActivityUpdateWithWhereUniqueWithoutApplicationInput | StripeActivityUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: StripeActivityUpdateManyWithWhereWithoutApplicationInput | StripeActivityUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: StripeActivityScalarWhereInput | StripeActivityScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<TaskCreateWithoutApplicationInput, TaskUncheckedCreateWithoutApplicationInput> | TaskCreateWithoutApplicationInput[] | TaskUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutApplicationInput | TaskCreateOrConnectWithoutApplicationInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutApplicationInput | TaskUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: TaskCreateManyApplicationInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutApplicationInput | TaskUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutApplicationInput | TaskUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ApplicationCreateNestedOneWithoutApplicationDocumentInput = {
    create?: XOR<ApplicationCreateWithoutApplicationDocumentInput, ApplicationUncheckedCreateWithoutApplicationDocumentInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutApplicationDocumentInput
    connect?: ApplicationWhereUniqueInput
  }

  export type DocumentMappingCreateNestedOneWithoutApplicationDocumentInput = {
    create?: XOR<DocumentMappingCreateWithoutApplicationDocumentInput, DocumentMappingUncheckedCreateWithoutApplicationDocumentInput>
    connectOrCreate?: DocumentMappingCreateOrConnectWithoutApplicationDocumentInput
    connect?: DocumentMappingWhereUniqueInput
  }

  export type DocumentMappingUncheckedCreateNestedOneWithoutApplicationDocumentInput = {
    create?: XOR<DocumentMappingCreateWithoutApplicationDocumentInput, DocumentMappingUncheckedCreateWithoutApplicationDocumentInput>
    connectOrCreate?: DocumentMappingCreateOrConnectWithoutApplicationDocumentInput
    connect?: DocumentMappingWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type ApplicationUpdateOneRequiredWithoutApplicationDocumentNestedInput = {
    create?: XOR<ApplicationCreateWithoutApplicationDocumentInput, ApplicationUncheckedCreateWithoutApplicationDocumentInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutApplicationDocumentInput
    upsert?: ApplicationUpsertWithoutApplicationDocumentInput
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutApplicationDocumentInput, ApplicationUpdateWithoutApplicationDocumentInput>, ApplicationUncheckedUpdateWithoutApplicationDocumentInput>
  }

  export type DocumentMappingUpdateOneWithoutApplicationDocumentNestedInput = {
    create?: XOR<DocumentMappingCreateWithoutApplicationDocumentInput, DocumentMappingUncheckedCreateWithoutApplicationDocumentInput>
    connectOrCreate?: DocumentMappingCreateOrConnectWithoutApplicationDocumentInput
    upsert?: DocumentMappingUpsertWithoutApplicationDocumentInput
    disconnect?: DocumentMappingWhereInput | boolean
    delete?: DocumentMappingWhereInput | boolean
    connect?: DocumentMappingWhereUniqueInput
    update?: XOR<XOR<DocumentMappingUpdateToOneWithWhereWithoutApplicationDocumentInput, DocumentMappingUpdateWithoutApplicationDocumentInput>, DocumentMappingUncheckedUpdateWithoutApplicationDocumentInput>
  }

  export type DocumentMappingUncheckedUpdateOneWithoutApplicationDocumentNestedInput = {
    create?: XOR<DocumentMappingCreateWithoutApplicationDocumentInput, DocumentMappingUncheckedCreateWithoutApplicationDocumentInput>
    connectOrCreate?: DocumentMappingCreateOrConnectWithoutApplicationDocumentInput
    upsert?: DocumentMappingUpsertWithoutApplicationDocumentInput
    disconnect?: DocumentMappingWhereInput | boolean
    delete?: DocumentMappingWhereInput | boolean
    connect?: DocumentMappingWhereUniqueInput
    update?: XOR<XOR<DocumentMappingUpdateToOneWithWhereWithoutApplicationDocumentInput, DocumentMappingUpdateWithoutApplicationDocumentInput>, DocumentMappingUncheckedUpdateWithoutApplicationDocumentInput>
  }

  export type EmailThreadCreateNestedOneWithoutAttachmentInput = {
    create?: XOR<EmailThreadCreateWithoutAttachmentInput, EmailThreadUncheckedCreateWithoutAttachmentInput>
    connectOrCreate?: EmailThreadCreateOrConnectWithoutAttachmentInput
    connect?: EmailThreadWhereUniqueInput
  }

  export type EmailThreadUpdateOneRequiredWithoutAttachmentNestedInput = {
    create?: XOR<EmailThreadCreateWithoutAttachmentInput, EmailThreadUncheckedCreateWithoutAttachmentInput>
    connectOrCreate?: EmailThreadCreateOrConnectWithoutAttachmentInput
    upsert?: EmailThreadUpsertWithoutAttachmentInput
    connect?: EmailThreadWhereUniqueInput
    update?: XOR<XOR<EmailThreadUpdateToOneWithWhereWithoutAttachmentInput, EmailThreadUpdateWithoutAttachmentInput>, EmailThreadUncheckedUpdateWithoutAttachmentInput>
  }

  export type ApplicationCreateNestedOneWithoutCardHolderInput = {
    create?: XOR<ApplicationCreateWithoutCardHolderInput, ApplicationUncheckedCreateWithoutCardHolderInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutCardHolderInput
    connect?: ApplicationWhereUniqueInput
  }

  export type ApplicationUpdateOneRequiredWithoutCardHolderNestedInput = {
    create?: XOR<ApplicationCreateWithoutCardHolderInput, ApplicationUncheckedCreateWithoutCardHolderInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutCardHolderInput
    upsert?: ApplicationUpsertWithoutCardHolderInput
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutCardHolderInput, ApplicationUpdateWithoutCardHolderInput>, ApplicationUncheckedUpdateWithoutCardHolderInput>
  }

  export type AccountCreateNestedOneWithoutCaseInput = {
    create?: XOR<AccountCreateWithoutCaseInput, AccountUncheckedCreateWithoutCaseInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCaseInput
    connect?: AccountWhereUniqueInput
  }

  export type ApplicationCreateNestedOneWithoutCaseInput = {
    create?: XOR<ApplicationCreateWithoutCaseInput, ApplicationUncheckedCreateWithoutCaseInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutCaseInput
    connect?: ApplicationWhereUniqueInput
  }

  export type EmailThreadCreateNestedManyWithoutCaseInput = {
    create?: XOR<EmailThreadCreateWithoutCaseInput, EmailThreadUncheckedCreateWithoutCaseInput> | EmailThreadCreateWithoutCaseInput[] | EmailThreadUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutCaseInput | EmailThreadCreateOrConnectWithoutCaseInput[]
    createMany?: EmailThreadCreateManyCaseInputEnvelope
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type EmailThreadUncheckedCreateNestedManyWithoutCaseInput = {
    create?: XOR<EmailThreadCreateWithoutCaseInput, EmailThreadUncheckedCreateWithoutCaseInput> | EmailThreadCreateWithoutCaseInput[] | EmailThreadUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutCaseInput | EmailThreadCreateOrConnectWithoutCaseInput[]
    createMany?: EmailThreadCreateManyCaseInputEnvelope
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type AccountUpdateOneWithoutCaseNestedInput = {
    create?: XOR<AccountCreateWithoutCaseInput, AccountUncheckedCreateWithoutCaseInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCaseInput
    upsert?: AccountUpsertWithoutCaseInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCaseInput, AccountUpdateWithoutCaseInput>, AccountUncheckedUpdateWithoutCaseInput>
  }

  export type ApplicationUpdateOneWithoutCaseNestedInput = {
    create?: XOR<ApplicationCreateWithoutCaseInput, ApplicationUncheckedCreateWithoutCaseInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutCaseInput
    upsert?: ApplicationUpsertWithoutCaseInput
    disconnect?: ApplicationWhereInput | boolean
    delete?: ApplicationWhereInput | boolean
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutCaseInput, ApplicationUpdateWithoutCaseInput>, ApplicationUncheckedUpdateWithoutCaseInput>
  }

  export type EmailThreadUpdateManyWithoutCaseNestedInput = {
    create?: XOR<EmailThreadCreateWithoutCaseInput, EmailThreadUncheckedCreateWithoutCaseInput> | EmailThreadCreateWithoutCaseInput[] | EmailThreadUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutCaseInput | EmailThreadCreateOrConnectWithoutCaseInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutCaseInput | EmailThreadUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: EmailThreadCreateManyCaseInputEnvelope
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutCaseInput | EmailThreadUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutCaseInput | EmailThreadUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type EmailThreadUncheckedUpdateManyWithoutCaseNestedInput = {
    create?: XOR<EmailThreadCreateWithoutCaseInput, EmailThreadUncheckedCreateWithoutCaseInput> | EmailThreadCreateWithoutCaseInput[] | EmailThreadUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutCaseInput | EmailThreadCreateOrConnectWithoutCaseInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutCaseInput | EmailThreadUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: EmailThreadCreateManyCaseInputEnvelope
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutCaseInput | EmailThreadUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutCaseInput | EmailThreadUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ApplicationCreateNestedManyWithoutDestinationInput = {
    create?: XOR<ApplicationCreateWithoutDestinationInput, ApplicationUncheckedCreateWithoutDestinationInput> | ApplicationCreateWithoutDestinationInput[] | ApplicationUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutDestinationInput | ApplicationCreateOrConnectWithoutDestinationInput[]
    createMany?: ApplicationCreateManyDestinationInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type VisaTypeCreateNestedManyWithoutDestinationInput = {
    create?: XOR<VisaTypeCreateWithoutDestinationInput, VisaTypeUncheckedCreateWithoutDestinationInput> | VisaTypeCreateWithoutDestinationInput[] | VisaTypeUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: VisaTypeCreateOrConnectWithoutDestinationInput | VisaTypeCreateOrConnectWithoutDestinationInput[]
    createMany?: VisaTypeCreateManyDestinationInputEnvelope
    connect?: VisaTypeWhereUniqueInput | VisaTypeWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<ApplicationCreateWithoutDestinationInput, ApplicationUncheckedCreateWithoutDestinationInput> | ApplicationCreateWithoutDestinationInput[] | ApplicationUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutDestinationInput | ApplicationCreateOrConnectWithoutDestinationInput[]
    createMany?: ApplicationCreateManyDestinationInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type VisaTypeUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<VisaTypeCreateWithoutDestinationInput, VisaTypeUncheckedCreateWithoutDestinationInput> | VisaTypeCreateWithoutDestinationInput[] | VisaTypeUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: VisaTypeCreateOrConnectWithoutDestinationInput | VisaTypeCreateOrConnectWithoutDestinationInput[]
    createMany?: VisaTypeCreateManyDestinationInputEnvelope
    connect?: VisaTypeWhereUniqueInput | VisaTypeWhereUniqueInput[]
  }

  export type ApplicationUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<ApplicationCreateWithoutDestinationInput, ApplicationUncheckedCreateWithoutDestinationInput> | ApplicationCreateWithoutDestinationInput[] | ApplicationUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutDestinationInput | ApplicationCreateOrConnectWithoutDestinationInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutDestinationInput | ApplicationUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: ApplicationCreateManyDestinationInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutDestinationInput | ApplicationUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutDestinationInput | ApplicationUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type VisaTypeUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<VisaTypeCreateWithoutDestinationInput, VisaTypeUncheckedCreateWithoutDestinationInput> | VisaTypeCreateWithoutDestinationInput[] | VisaTypeUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: VisaTypeCreateOrConnectWithoutDestinationInput | VisaTypeCreateOrConnectWithoutDestinationInput[]
    upsert?: VisaTypeUpsertWithWhereUniqueWithoutDestinationInput | VisaTypeUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: VisaTypeCreateManyDestinationInputEnvelope
    set?: VisaTypeWhereUniqueInput | VisaTypeWhereUniqueInput[]
    disconnect?: VisaTypeWhereUniqueInput | VisaTypeWhereUniqueInput[]
    delete?: VisaTypeWhereUniqueInput | VisaTypeWhereUniqueInput[]
    connect?: VisaTypeWhereUniqueInput | VisaTypeWhereUniqueInput[]
    update?: VisaTypeUpdateWithWhereUniqueWithoutDestinationInput | VisaTypeUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: VisaTypeUpdateManyWithWhereWithoutDestinationInput | VisaTypeUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: VisaTypeScalarWhereInput | VisaTypeScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<ApplicationCreateWithoutDestinationInput, ApplicationUncheckedCreateWithoutDestinationInput> | ApplicationCreateWithoutDestinationInput[] | ApplicationUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutDestinationInput | ApplicationCreateOrConnectWithoutDestinationInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutDestinationInput | ApplicationUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: ApplicationCreateManyDestinationInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutDestinationInput | ApplicationUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutDestinationInput | ApplicationUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type VisaTypeUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<VisaTypeCreateWithoutDestinationInput, VisaTypeUncheckedCreateWithoutDestinationInput> | VisaTypeCreateWithoutDestinationInput[] | VisaTypeUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: VisaTypeCreateOrConnectWithoutDestinationInput | VisaTypeCreateOrConnectWithoutDestinationInput[]
    upsert?: VisaTypeUpsertWithWhereUniqueWithoutDestinationInput | VisaTypeUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: VisaTypeCreateManyDestinationInputEnvelope
    set?: VisaTypeWhereUniqueInput | VisaTypeWhereUniqueInput[]
    disconnect?: VisaTypeWhereUniqueInput | VisaTypeWhereUniqueInput[]
    delete?: VisaTypeWhereUniqueInput | VisaTypeWhereUniqueInput[]
    connect?: VisaTypeWhereUniqueInput | VisaTypeWhereUniqueInput[]
    update?: VisaTypeUpdateWithWhereUniqueWithoutDestinationInput | VisaTypeUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: VisaTypeUpdateManyWithWhereWithoutDestinationInput | VisaTypeUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: VisaTypeScalarWhereInput | VisaTypeScalarWhereInput[]
  }

  export type ApplicationDocumentCreateNestedOneWithoutDocumentMappingInput = {
    create?: XOR<ApplicationDocumentCreateWithoutDocumentMappingInput, ApplicationDocumentUncheckedCreateWithoutDocumentMappingInput>
    connectOrCreate?: ApplicationDocumentCreateOrConnectWithoutDocumentMappingInput
    connect?: ApplicationDocumentWhereUniqueInput
  }

  export type ApplicationDocumentUpdateOneRequiredWithoutDocumentMappingNestedInput = {
    create?: XOR<ApplicationDocumentCreateWithoutDocumentMappingInput, ApplicationDocumentUncheckedCreateWithoutDocumentMappingInput>
    connectOrCreate?: ApplicationDocumentCreateOrConnectWithoutDocumentMappingInput
    upsert?: ApplicationDocumentUpsertWithoutDocumentMappingInput
    connect?: ApplicationDocumentWhereUniqueInput
    update?: XOR<XOR<ApplicationDocumentUpdateToOneWithWhereWithoutDocumentMappingInput, ApplicationDocumentUpdateWithoutDocumentMappingInput>, ApplicationDocumentUncheckedUpdateWithoutDocumentMappingInput>
  }

  export type AttachmentCreateNestedManyWithoutEmailThreadInput = {
    create?: XOR<AttachmentCreateWithoutEmailThreadInput, AttachmentUncheckedCreateWithoutEmailThreadInput> | AttachmentCreateWithoutEmailThreadInput[] | AttachmentUncheckedCreateWithoutEmailThreadInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutEmailThreadInput | AttachmentCreateOrConnectWithoutEmailThreadInput[]
    createMany?: AttachmentCreateManyEmailThreadInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type CaseCreateNestedOneWithoutEmailThreadInput = {
    create?: XOR<CaseCreateWithoutEmailThreadInput, CaseUncheckedCreateWithoutEmailThreadInput>
    connectOrCreate?: CaseCreateOrConnectWithoutEmailThreadInput
    connect?: CaseWhereUniqueInput
  }

  export type AttachmentUncheckedCreateNestedManyWithoutEmailThreadInput = {
    create?: XOR<AttachmentCreateWithoutEmailThreadInput, AttachmentUncheckedCreateWithoutEmailThreadInput> | AttachmentCreateWithoutEmailThreadInput[] | AttachmentUncheckedCreateWithoutEmailThreadInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutEmailThreadInput | AttachmentCreateOrConnectWithoutEmailThreadInput[]
    createMany?: AttachmentCreateManyEmailThreadInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type AttachmentUpdateManyWithoutEmailThreadNestedInput = {
    create?: XOR<AttachmentCreateWithoutEmailThreadInput, AttachmentUncheckedCreateWithoutEmailThreadInput> | AttachmentCreateWithoutEmailThreadInput[] | AttachmentUncheckedCreateWithoutEmailThreadInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutEmailThreadInput | AttachmentCreateOrConnectWithoutEmailThreadInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutEmailThreadInput | AttachmentUpsertWithWhereUniqueWithoutEmailThreadInput[]
    createMany?: AttachmentCreateManyEmailThreadInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutEmailThreadInput | AttachmentUpdateWithWhereUniqueWithoutEmailThreadInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutEmailThreadInput | AttachmentUpdateManyWithWhereWithoutEmailThreadInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CaseUpdateOneRequiredWithoutEmailThreadNestedInput = {
    create?: XOR<CaseCreateWithoutEmailThreadInput, CaseUncheckedCreateWithoutEmailThreadInput>
    connectOrCreate?: CaseCreateOrConnectWithoutEmailThreadInput
    upsert?: CaseUpsertWithoutEmailThreadInput
    connect?: CaseWhereUniqueInput
    update?: XOR<XOR<CaseUpdateToOneWithWhereWithoutEmailThreadInput, CaseUpdateWithoutEmailThreadInput>, CaseUncheckedUpdateWithoutEmailThreadInput>
  }

  export type AttachmentUncheckedUpdateManyWithoutEmailThreadNestedInput = {
    create?: XOR<AttachmentCreateWithoutEmailThreadInput, AttachmentUncheckedCreateWithoutEmailThreadInput> | AttachmentCreateWithoutEmailThreadInput[] | AttachmentUncheckedCreateWithoutEmailThreadInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutEmailThreadInput | AttachmentCreateOrConnectWithoutEmailThreadInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutEmailThreadInput | AttachmentUpsertWithWhereUniqueWithoutEmailThreadInput[]
    createMany?: AttachmentCreateManyEmailThreadInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutEmailThreadInput | AttachmentUpdateWithWhereUniqueWithoutEmailThreadInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutEmailThreadInput | AttachmentUpdateManyWithWhereWithoutEmailThreadInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type ApplicationCreateNestedOneWithoutPassengerInput = {
    create?: XOR<ApplicationCreateWithoutPassengerInput, ApplicationUncheckedCreateWithoutPassengerInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutPassengerInput
    connect?: ApplicationWhereUniqueInput
  }

  export type ApplicationUpdateOneRequiredWithoutPassengerNestedInput = {
    create?: XOR<ApplicationCreateWithoutPassengerInput, ApplicationUncheckedCreateWithoutPassengerInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutPassengerInput
    upsert?: ApplicationUpsertWithoutPassengerInput
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutPassengerInput, ApplicationUpdateWithoutPassengerInput>, ApplicationUncheckedUpdateWithoutPassengerInput>
  }

  export type ApplicationCreateNestedOneWithoutRiskInput = {
    create?: XOR<ApplicationCreateWithoutRiskInput, ApplicationUncheckedCreateWithoutRiskInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutRiskInput
    connect?: ApplicationWhereUniqueInput
  }

  export type RiskActivityCreateNestedManyWithoutRiskInput = {
    create?: XOR<RiskActivityCreateWithoutRiskInput, RiskActivityUncheckedCreateWithoutRiskInput> | RiskActivityCreateWithoutRiskInput[] | RiskActivityUncheckedCreateWithoutRiskInput[]
    connectOrCreate?: RiskActivityCreateOrConnectWithoutRiskInput | RiskActivityCreateOrConnectWithoutRiskInput[]
    createMany?: RiskActivityCreateManyRiskInputEnvelope
    connect?: RiskActivityWhereUniqueInput | RiskActivityWhereUniqueInput[]
  }

  export type RiskDocumentCreateNestedManyWithoutRiskInput = {
    create?: XOR<RiskDocumentCreateWithoutRiskInput, RiskDocumentUncheckedCreateWithoutRiskInput> | RiskDocumentCreateWithoutRiskInput[] | RiskDocumentUncheckedCreateWithoutRiskInput[]
    connectOrCreate?: RiskDocumentCreateOrConnectWithoutRiskInput | RiskDocumentCreateOrConnectWithoutRiskInput[]
    createMany?: RiskDocumentCreateManyRiskInputEnvelope
    connect?: RiskDocumentWhereUniqueInput | RiskDocumentWhereUniqueInput[]
  }

  export type RiskActivityUncheckedCreateNestedManyWithoutRiskInput = {
    create?: XOR<RiskActivityCreateWithoutRiskInput, RiskActivityUncheckedCreateWithoutRiskInput> | RiskActivityCreateWithoutRiskInput[] | RiskActivityUncheckedCreateWithoutRiskInput[]
    connectOrCreate?: RiskActivityCreateOrConnectWithoutRiskInput | RiskActivityCreateOrConnectWithoutRiskInput[]
    createMany?: RiskActivityCreateManyRiskInputEnvelope
    connect?: RiskActivityWhereUniqueInput | RiskActivityWhereUniqueInput[]
  }

  export type RiskDocumentUncheckedCreateNestedManyWithoutRiskInput = {
    create?: XOR<RiskDocumentCreateWithoutRiskInput, RiskDocumentUncheckedCreateWithoutRiskInput> | RiskDocumentCreateWithoutRiskInput[] | RiskDocumentUncheckedCreateWithoutRiskInput[]
    connectOrCreate?: RiskDocumentCreateOrConnectWithoutRiskInput | RiskDocumentCreateOrConnectWithoutRiskInput[]
    createMany?: RiskDocumentCreateManyRiskInputEnvelope
    connect?: RiskDocumentWhereUniqueInput | RiskDocumentWhereUniqueInput[]
  }

  export type ApplicationUpdateOneRequiredWithoutRiskNestedInput = {
    create?: XOR<ApplicationCreateWithoutRiskInput, ApplicationUncheckedCreateWithoutRiskInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutRiskInput
    upsert?: ApplicationUpsertWithoutRiskInput
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutRiskInput, ApplicationUpdateWithoutRiskInput>, ApplicationUncheckedUpdateWithoutRiskInput>
  }

  export type RiskActivityUpdateManyWithoutRiskNestedInput = {
    create?: XOR<RiskActivityCreateWithoutRiskInput, RiskActivityUncheckedCreateWithoutRiskInput> | RiskActivityCreateWithoutRiskInput[] | RiskActivityUncheckedCreateWithoutRiskInput[]
    connectOrCreate?: RiskActivityCreateOrConnectWithoutRiskInput | RiskActivityCreateOrConnectWithoutRiskInput[]
    upsert?: RiskActivityUpsertWithWhereUniqueWithoutRiskInput | RiskActivityUpsertWithWhereUniqueWithoutRiskInput[]
    createMany?: RiskActivityCreateManyRiskInputEnvelope
    set?: RiskActivityWhereUniqueInput | RiskActivityWhereUniqueInput[]
    disconnect?: RiskActivityWhereUniqueInput | RiskActivityWhereUniqueInput[]
    delete?: RiskActivityWhereUniqueInput | RiskActivityWhereUniqueInput[]
    connect?: RiskActivityWhereUniqueInput | RiskActivityWhereUniqueInput[]
    update?: RiskActivityUpdateWithWhereUniqueWithoutRiskInput | RiskActivityUpdateWithWhereUniqueWithoutRiskInput[]
    updateMany?: RiskActivityUpdateManyWithWhereWithoutRiskInput | RiskActivityUpdateManyWithWhereWithoutRiskInput[]
    deleteMany?: RiskActivityScalarWhereInput | RiskActivityScalarWhereInput[]
  }

  export type RiskDocumentUpdateManyWithoutRiskNestedInput = {
    create?: XOR<RiskDocumentCreateWithoutRiskInput, RiskDocumentUncheckedCreateWithoutRiskInput> | RiskDocumentCreateWithoutRiskInput[] | RiskDocumentUncheckedCreateWithoutRiskInput[]
    connectOrCreate?: RiskDocumentCreateOrConnectWithoutRiskInput | RiskDocumentCreateOrConnectWithoutRiskInput[]
    upsert?: RiskDocumentUpsertWithWhereUniqueWithoutRiskInput | RiskDocumentUpsertWithWhereUniqueWithoutRiskInput[]
    createMany?: RiskDocumentCreateManyRiskInputEnvelope
    set?: RiskDocumentWhereUniqueInput | RiskDocumentWhereUniqueInput[]
    disconnect?: RiskDocumentWhereUniqueInput | RiskDocumentWhereUniqueInput[]
    delete?: RiskDocumentWhereUniqueInput | RiskDocumentWhereUniqueInput[]
    connect?: RiskDocumentWhereUniqueInput | RiskDocumentWhereUniqueInput[]
    update?: RiskDocumentUpdateWithWhereUniqueWithoutRiskInput | RiskDocumentUpdateWithWhereUniqueWithoutRiskInput[]
    updateMany?: RiskDocumentUpdateManyWithWhereWithoutRiskInput | RiskDocumentUpdateManyWithWhereWithoutRiskInput[]
    deleteMany?: RiskDocumentScalarWhereInput | RiskDocumentScalarWhereInput[]
  }

  export type RiskActivityUncheckedUpdateManyWithoutRiskNestedInput = {
    create?: XOR<RiskActivityCreateWithoutRiskInput, RiskActivityUncheckedCreateWithoutRiskInput> | RiskActivityCreateWithoutRiskInput[] | RiskActivityUncheckedCreateWithoutRiskInput[]
    connectOrCreate?: RiskActivityCreateOrConnectWithoutRiskInput | RiskActivityCreateOrConnectWithoutRiskInput[]
    upsert?: RiskActivityUpsertWithWhereUniqueWithoutRiskInput | RiskActivityUpsertWithWhereUniqueWithoutRiskInput[]
    createMany?: RiskActivityCreateManyRiskInputEnvelope
    set?: RiskActivityWhereUniqueInput | RiskActivityWhereUniqueInput[]
    disconnect?: RiskActivityWhereUniqueInput | RiskActivityWhereUniqueInput[]
    delete?: RiskActivityWhereUniqueInput | RiskActivityWhereUniqueInput[]
    connect?: RiskActivityWhereUniqueInput | RiskActivityWhereUniqueInput[]
    update?: RiskActivityUpdateWithWhereUniqueWithoutRiskInput | RiskActivityUpdateWithWhereUniqueWithoutRiskInput[]
    updateMany?: RiskActivityUpdateManyWithWhereWithoutRiskInput | RiskActivityUpdateManyWithWhereWithoutRiskInput[]
    deleteMany?: RiskActivityScalarWhereInput | RiskActivityScalarWhereInput[]
  }

  export type RiskDocumentUncheckedUpdateManyWithoutRiskNestedInput = {
    create?: XOR<RiskDocumentCreateWithoutRiskInput, RiskDocumentUncheckedCreateWithoutRiskInput> | RiskDocumentCreateWithoutRiskInput[] | RiskDocumentUncheckedCreateWithoutRiskInput[]
    connectOrCreate?: RiskDocumentCreateOrConnectWithoutRiskInput | RiskDocumentCreateOrConnectWithoutRiskInput[]
    upsert?: RiskDocumentUpsertWithWhereUniqueWithoutRiskInput | RiskDocumentUpsertWithWhereUniqueWithoutRiskInput[]
    createMany?: RiskDocumentCreateManyRiskInputEnvelope
    set?: RiskDocumentWhereUniqueInput | RiskDocumentWhereUniqueInput[]
    disconnect?: RiskDocumentWhereUniqueInput | RiskDocumentWhereUniqueInput[]
    delete?: RiskDocumentWhereUniqueInput | RiskDocumentWhereUniqueInput[]
    connect?: RiskDocumentWhereUniqueInput | RiskDocumentWhereUniqueInput[]
    update?: RiskDocumentUpdateWithWhereUniqueWithoutRiskInput | RiskDocumentUpdateWithWhereUniqueWithoutRiskInput[]
    updateMany?: RiskDocumentUpdateManyWithWhereWithoutRiskInput | RiskDocumentUpdateManyWithWhereWithoutRiskInput[]
    deleteMany?: RiskDocumentScalarWhereInput | RiskDocumentScalarWhereInput[]
  }

  export type RiskCreateNestedOneWithoutRiskActivityInput = {
    create?: XOR<RiskCreateWithoutRiskActivityInput, RiskUncheckedCreateWithoutRiskActivityInput>
    connectOrCreate?: RiskCreateOrConnectWithoutRiskActivityInput
    connect?: RiskWhereUniqueInput
  }

  export type RiskUpdateOneRequiredWithoutRiskActivityNestedInput = {
    create?: XOR<RiskCreateWithoutRiskActivityInput, RiskUncheckedCreateWithoutRiskActivityInput>
    connectOrCreate?: RiskCreateOrConnectWithoutRiskActivityInput
    upsert?: RiskUpsertWithoutRiskActivityInput
    connect?: RiskWhereUniqueInput
    update?: XOR<XOR<RiskUpdateToOneWithWhereWithoutRiskActivityInput, RiskUpdateWithoutRiskActivityInput>, RiskUncheckedUpdateWithoutRiskActivityInput>
  }

  export type RiskCreateNestedOneWithoutRiskDocumentInput = {
    create?: XOR<RiskCreateWithoutRiskDocumentInput, RiskUncheckedCreateWithoutRiskDocumentInput>
    connectOrCreate?: RiskCreateOrConnectWithoutRiskDocumentInput
    connect?: RiskWhereUniqueInput
  }

  export type RiskUpdateOneRequiredWithoutRiskDocumentNestedInput = {
    create?: XOR<RiskCreateWithoutRiskDocumentInput, RiskUncheckedCreateWithoutRiskDocumentInput>
    connectOrCreate?: RiskCreateOrConnectWithoutRiskDocumentInput
    upsert?: RiskUpsertWithoutRiskDocumentInput
    connect?: RiskWhereUniqueInput
    update?: XOR<XOR<RiskUpdateToOneWithWhereWithoutRiskDocumentInput, RiskUpdateWithoutRiskDocumentInput>, RiskUncheckedUpdateWithoutRiskDocumentInput>
  }

  export type ApplicationCreateNestedOneWithoutStripeActivityInput = {
    create?: XOR<ApplicationCreateWithoutStripeActivityInput, ApplicationUncheckedCreateWithoutStripeActivityInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutStripeActivityInput
    connect?: ApplicationWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ApplicationUpdateOneWithoutStripeActivityNestedInput = {
    create?: XOR<ApplicationCreateWithoutStripeActivityInput, ApplicationUncheckedCreateWithoutStripeActivityInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutStripeActivityInput
    upsert?: ApplicationUpsertWithoutStripeActivityInput
    disconnect?: ApplicationWhereInput | boolean
    delete?: ApplicationWhereInput | boolean
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutStripeActivityInput, ApplicationUpdateWithoutStripeActivityInput>, ApplicationUncheckedUpdateWithoutStripeActivityInput>
  }

  export type ApplicationCreateNestedOneWithoutTaskInput = {
    create?: XOR<ApplicationCreateWithoutTaskInput, ApplicationUncheckedCreateWithoutTaskInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutTaskInput
    connect?: ApplicationWhereUniqueInput
  }

  export type TaskActivityCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskActivityCreateWithoutTaskInput, TaskActivityUncheckedCreateWithoutTaskInput> | TaskActivityCreateWithoutTaskInput[] | TaskActivityUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskActivityCreateOrConnectWithoutTaskInput | TaskActivityCreateOrConnectWithoutTaskInput[]
    createMany?: TaskActivityCreateManyTaskInputEnvelope
    connect?: TaskActivityWhereUniqueInput | TaskActivityWhereUniqueInput[]
  }

  export type TaskActivityUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskActivityCreateWithoutTaskInput, TaskActivityUncheckedCreateWithoutTaskInput> | TaskActivityCreateWithoutTaskInput[] | TaskActivityUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskActivityCreateOrConnectWithoutTaskInput | TaskActivityCreateOrConnectWithoutTaskInput[]
    createMany?: TaskActivityCreateManyTaskInputEnvelope
    connect?: TaskActivityWhereUniqueInput | TaskActivityWhereUniqueInput[]
  }

  export type ApplicationUpdateOneRequiredWithoutTaskNestedInput = {
    create?: XOR<ApplicationCreateWithoutTaskInput, ApplicationUncheckedCreateWithoutTaskInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutTaskInput
    upsert?: ApplicationUpsertWithoutTaskInput
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutTaskInput, ApplicationUpdateWithoutTaskInput>, ApplicationUncheckedUpdateWithoutTaskInput>
  }

  export type TaskActivityUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskActivityCreateWithoutTaskInput, TaskActivityUncheckedCreateWithoutTaskInput> | TaskActivityCreateWithoutTaskInput[] | TaskActivityUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskActivityCreateOrConnectWithoutTaskInput | TaskActivityCreateOrConnectWithoutTaskInput[]
    upsert?: TaskActivityUpsertWithWhereUniqueWithoutTaskInput | TaskActivityUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskActivityCreateManyTaskInputEnvelope
    set?: TaskActivityWhereUniqueInput | TaskActivityWhereUniqueInput[]
    disconnect?: TaskActivityWhereUniqueInput | TaskActivityWhereUniqueInput[]
    delete?: TaskActivityWhereUniqueInput | TaskActivityWhereUniqueInput[]
    connect?: TaskActivityWhereUniqueInput | TaskActivityWhereUniqueInput[]
    update?: TaskActivityUpdateWithWhereUniqueWithoutTaskInput | TaskActivityUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskActivityUpdateManyWithWhereWithoutTaskInput | TaskActivityUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskActivityScalarWhereInput | TaskActivityScalarWhereInput[]
  }

  export type TaskActivityUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskActivityCreateWithoutTaskInput, TaskActivityUncheckedCreateWithoutTaskInput> | TaskActivityCreateWithoutTaskInput[] | TaskActivityUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskActivityCreateOrConnectWithoutTaskInput | TaskActivityCreateOrConnectWithoutTaskInput[]
    upsert?: TaskActivityUpsertWithWhereUniqueWithoutTaskInput | TaskActivityUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskActivityCreateManyTaskInputEnvelope
    set?: TaskActivityWhereUniqueInput | TaskActivityWhereUniqueInput[]
    disconnect?: TaskActivityWhereUniqueInput | TaskActivityWhereUniqueInput[]
    delete?: TaskActivityWhereUniqueInput | TaskActivityWhereUniqueInput[]
    connect?: TaskActivityWhereUniqueInput | TaskActivityWhereUniqueInput[]
    update?: TaskActivityUpdateWithWhereUniqueWithoutTaskInput | TaskActivityUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskActivityUpdateManyWithWhereWithoutTaskInput | TaskActivityUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskActivityScalarWhereInput | TaskActivityScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutTaskActivityInput = {
    create?: XOR<TaskCreateWithoutTaskActivityInput, TaskUncheckedCreateWithoutTaskActivityInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskActivityInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTaskActivityNestedInput = {
    create?: XOR<TaskCreateWithoutTaskActivityInput, TaskUncheckedCreateWithoutTaskActivityInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTaskActivityInput
    upsert?: TaskUpsertWithoutTaskActivityInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTaskActivityInput, TaskUpdateWithoutTaskActivityInput>, TaskUncheckedUpdateWithoutTaskActivityInput>
  }

  export type ApplicationCreateNestedManyWithoutVisaTypeInput = {
    create?: XOR<ApplicationCreateWithoutVisaTypeInput, ApplicationUncheckedCreateWithoutVisaTypeInput> | ApplicationCreateWithoutVisaTypeInput[] | ApplicationUncheckedCreateWithoutVisaTypeInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutVisaTypeInput | ApplicationCreateOrConnectWithoutVisaTypeInput[]
    createMany?: ApplicationCreateManyVisaTypeInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type DestinationCreateNestedOneWithoutVisaTypeInput = {
    create?: XOR<DestinationCreateWithoutVisaTypeInput, DestinationUncheckedCreateWithoutVisaTypeInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutVisaTypeInput
    connect?: DestinationWhereUniqueInput
  }

  export type ApplicationUncheckedCreateNestedManyWithoutVisaTypeInput = {
    create?: XOR<ApplicationCreateWithoutVisaTypeInput, ApplicationUncheckedCreateWithoutVisaTypeInput> | ApplicationCreateWithoutVisaTypeInput[] | ApplicationUncheckedCreateWithoutVisaTypeInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutVisaTypeInput | ApplicationCreateOrConnectWithoutVisaTypeInput[]
    createMany?: ApplicationCreateManyVisaTypeInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type ApplicationUpdateManyWithoutVisaTypeNestedInput = {
    create?: XOR<ApplicationCreateWithoutVisaTypeInput, ApplicationUncheckedCreateWithoutVisaTypeInput> | ApplicationCreateWithoutVisaTypeInput[] | ApplicationUncheckedCreateWithoutVisaTypeInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutVisaTypeInput | ApplicationCreateOrConnectWithoutVisaTypeInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutVisaTypeInput | ApplicationUpsertWithWhereUniqueWithoutVisaTypeInput[]
    createMany?: ApplicationCreateManyVisaTypeInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutVisaTypeInput | ApplicationUpdateWithWhereUniqueWithoutVisaTypeInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutVisaTypeInput | ApplicationUpdateManyWithWhereWithoutVisaTypeInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type DestinationUpdateOneRequiredWithoutVisaTypeNestedInput = {
    create?: XOR<DestinationCreateWithoutVisaTypeInput, DestinationUncheckedCreateWithoutVisaTypeInput>
    connectOrCreate?: DestinationCreateOrConnectWithoutVisaTypeInput
    upsert?: DestinationUpsertWithoutVisaTypeInput
    connect?: DestinationWhereUniqueInput
    update?: XOR<XOR<DestinationUpdateToOneWithWhereWithoutVisaTypeInput, DestinationUpdateWithoutVisaTypeInput>, DestinationUncheckedUpdateWithoutVisaTypeInput>
  }

  export type ApplicationUncheckedUpdateManyWithoutVisaTypeNestedInput = {
    create?: XOR<ApplicationCreateWithoutVisaTypeInput, ApplicationUncheckedCreateWithoutVisaTypeInput> | ApplicationCreateWithoutVisaTypeInput[] | ApplicationUncheckedCreateWithoutVisaTypeInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutVisaTypeInput | ApplicationCreateOrConnectWithoutVisaTypeInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutVisaTypeInput | ApplicationUpsertWithWhereUniqueWithoutVisaTypeInput[]
    createMany?: ApplicationCreateManyVisaTypeInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutVisaTypeInput | ApplicationUpdateWithWhereUniqueWithoutVisaTypeInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutVisaTypeInput | ApplicationUpdateManyWithWhereWithoutVisaTypeInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutPassword_reset_tokensInput = {
    create?: XOR<AccountCreateWithoutPassword_reset_tokensInput, AccountUncheckedCreateWithoutPassword_reset_tokensInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPassword_reset_tokensInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutPassword_reset_tokensNestedInput = {
    create?: XOR<AccountCreateWithoutPassword_reset_tokensInput, AccountUncheckedCreateWithoutPassword_reset_tokensInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPassword_reset_tokensInput
    upsert?: AccountUpsertWithoutPassword_reset_tokensInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutPassword_reset_tokensInput, AccountUpdateWithoutPassword_reset_tokensInput>, AccountUncheckedUpdateWithoutPassword_reset_tokensInput>
  }

  export type AccountCreateNestedOneWithoutSessionsInput = {
    create?: XOR<AccountCreateWithoutSessionsInput, AccountUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSessionsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<AccountCreateWithoutSessionsInput, AccountUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSessionsInput
    upsert?: AccountUpsertWithoutSessionsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutSessionsInput, AccountUpdateWithoutSessionsInput>, AccountUncheckedUpdateWithoutSessionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ApplicationCreateWithoutAccountInput = {
    id?: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    Destination: DestinationCreateNestedOneWithoutApplicationInput
    VisaType: VisaTypeCreateNestedOneWithoutApplicationInput
    ApplicationDocument?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderCreateNestedOneWithoutApplicationInput
    Case?: CaseCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerCreateNestedManyWithoutApplicationInput
    Risk?: RiskCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityCreateNestedManyWithoutApplicationInput
    Task?: TaskCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutAccountInput = {
    id?: string
    destinationId: string
    visaTypeId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    ApplicationDocument?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderUncheckedCreateNestedOneWithoutApplicationInput
    Case?: CaseUncheckedCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerUncheckedCreateNestedManyWithoutApplicationInput
    Risk?: RiskUncheckedCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityUncheckedCreateNestedManyWithoutApplicationInput
    Task?: TaskUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutAccountInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutAccountInput, ApplicationUncheckedCreateWithoutAccountInput>
  }

  export type ApplicationCreateManyAccountInputEnvelope = {
    data: ApplicationCreateManyAccountInput | ApplicationCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type CaseCreateWithoutAccountInput = {
    id: string
    gmailThreadId?: string | null
    email: string
    subject: string
    status?: string
    lastUpdate?: Date | string
    websiteCreatedAt: string
    assignedTo?: string | null
    topic?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Application?: ApplicationCreateNestedOneWithoutCaseInput
    EmailThread?: EmailThreadCreateNestedManyWithoutCaseInput
  }

  export type CaseUncheckedCreateWithoutAccountInput = {
    id: string
    gmailThreadId?: string | null
    email: string
    subject: string
    status?: string
    lastUpdate?: Date | string
    websiteCreatedAt: string
    applicationId?: string | null
    assignedTo?: string | null
    topic?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    EmailThread?: EmailThreadUncheckedCreateNestedManyWithoutCaseInput
  }

  export type CaseCreateOrConnectWithoutAccountInput = {
    where: CaseWhereUniqueInput
    create: XOR<CaseCreateWithoutAccountInput, CaseUncheckedCreateWithoutAccountInput>
  }

  export type CaseCreateManyAccountInputEnvelope = {
    data: CaseCreateManyAccountInput | CaseCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type password_reset_tokensCreateWithoutAccountInput = {
    id: string
    token: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type password_reset_tokensUncheckedCreateWithoutAccountInput = {
    id: string
    token: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type password_reset_tokensCreateOrConnectWithoutAccountInput = {
    where: password_reset_tokensWhereUniqueInput
    create: XOR<password_reset_tokensCreateWithoutAccountInput, password_reset_tokensUncheckedCreateWithoutAccountInput>
  }

  export type password_reset_tokensCreateManyAccountInputEnvelope = {
    data: password_reset_tokensCreateManyAccountInput | password_reset_tokensCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type sessionsCreateWithoutAccountInput = {
    id: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type sessionsUncheckedCreateWithoutAccountInput = {
    id: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type sessionsCreateOrConnectWithoutAccountInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutAccountInput, sessionsUncheckedCreateWithoutAccountInput>
  }

  export type sessionsCreateManyAccountInputEnvelope = {
    data: sessionsCreateManyAccountInput | sessionsCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationUpsertWithWhereUniqueWithoutAccountInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutAccountInput, ApplicationUncheckedUpdateWithoutAccountInput>
    create: XOR<ApplicationCreateWithoutAccountInput, ApplicationUncheckedCreateWithoutAccountInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutAccountInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutAccountInput, ApplicationUncheckedUpdateWithoutAccountInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutAccountInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutAccountInput>
  }

  export type ApplicationScalarWhereInput = {
    AND?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    OR?: ApplicationScalarWhereInput[]
    NOT?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    id?: StringFilter<"Application"> | string
    destinationId?: StringFilter<"Application"> | string
    visaTypeId?: StringFilter<"Application"> | string
    status?: StringFilter<"Application"> | string
    accountId?: StringFilter<"Application"> | string
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    applicationId?: StringFilter<"Application"> | string
    passengerCount?: IntNullableFilter<"Application"> | number | null
    stayingEnd?: DateTimeNullableFilter<"Application"> | Date | string | null
    stayingStart?: DateTimeNullableFilter<"Application"> | Date | string | null
    total?: FloatNullableFilter<"Application"> | number | null
    cancellationDetails?: StringNullableFilter<"Application"> | string | null
    cancellationReason?: StringNullableFilter<"Application"> | string | null
    cancelledAt?: DateTimeNullableFilter<"Application"> | Date | string | null
    cancelledBy?: StringNullableFilter<"Application"> | string | null
    applyDate?: DateTimeNullableFilter<"Application"> | Date | string | null
    paymentStatus?: StringNullableFilter<"Application"> | string | null
  }

  export type CaseUpsertWithWhereUniqueWithoutAccountInput = {
    where: CaseWhereUniqueInput
    update: XOR<CaseUpdateWithoutAccountInput, CaseUncheckedUpdateWithoutAccountInput>
    create: XOR<CaseCreateWithoutAccountInput, CaseUncheckedCreateWithoutAccountInput>
  }

  export type CaseUpdateWithWhereUniqueWithoutAccountInput = {
    where: CaseWhereUniqueInput
    data: XOR<CaseUpdateWithoutAccountInput, CaseUncheckedUpdateWithoutAccountInput>
  }

  export type CaseUpdateManyWithWhereWithoutAccountInput = {
    where: CaseScalarWhereInput
    data: XOR<CaseUpdateManyMutationInput, CaseUncheckedUpdateManyWithoutAccountInput>
  }

  export type CaseScalarWhereInput = {
    AND?: CaseScalarWhereInput | CaseScalarWhereInput[]
    OR?: CaseScalarWhereInput[]
    NOT?: CaseScalarWhereInput | CaseScalarWhereInput[]
    id?: StringFilter<"Case"> | string
    gmailThreadId?: StringNullableFilter<"Case"> | string | null
    email?: StringFilter<"Case"> | string
    subject?: StringFilter<"Case"> | string
    status?: StringFilter<"Case"> | string
    lastUpdate?: DateTimeFilter<"Case"> | Date | string
    websiteCreatedAt?: StringFilter<"Case"> | string
    accountId?: StringNullableFilter<"Case"> | string | null
    applicationId?: StringNullableFilter<"Case"> | string | null
    assignedTo?: StringNullableFilter<"Case"> | string | null
    topic?: StringNullableFilter<"Case"> | string | null
    createdAt?: DateTimeFilter<"Case"> | Date | string
    updatedAt?: DateTimeFilter<"Case"> | Date | string
  }

  export type password_reset_tokensUpsertWithWhereUniqueWithoutAccountInput = {
    where: password_reset_tokensWhereUniqueInput
    update: XOR<password_reset_tokensUpdateWithoutAccountInput, password_reset_tokensUncheckedUpdateWithoutAccountInput>
    create: XOR<password_reset_tokensCreateWithoutAccountInput, password_reset_tokensUncheckedCreateWithoutAccountInput>
  }

  export type password_reset_tokensUpdateWithWhereUniqueWithoutAccountInput = {
    where: password_reset_tokensWhereUniqueInput
    data: XOR<password_reset_tokensUpdateWithoutAccountInput, password_reset_tokensUncheckedUpdateWithoutAccountInput>
  }

  export type password_reset_tokensUpdateManyWithWhereWithoutAccountInput = {
    where: password_reset_tokensScalarWhereInput
    data: XOR<password_reset_tokensUpdateManyMutationInput, password_reset_tokensUncheckedUpdateManyWithoutAccountInput>
  }

  export type password_reset_tokensScalarWhereInput = {
    AND?: password_reset_tokensScalarWhereInput | password_reset_tokensScalarWhereInput[]
    OR?: password_reset_tokensScalarWhereInput[]
    NOT?: password_reset_tokensScalarWhereInput | password_reset_tokensScalarWhereInput[]
    id?: StringFilter<"password_reset_tokens"> | string
    accountId?: StringFilter<"password_reset_tokens"> | string
    token?: StringFilter<"password_reset_tokens"> | string
    expiresAt?: DateTimeFilter<"password_reset_tokens"> | Date | string
    used?: BoolFilter<"password_reset_tokens"> | boolean
    createdAt?: DateTimeFilter<"password_reset_tokens"> | Date | string
  }

  export type sessionsUpsertWithWhereUniqueWithoutAccountInput = {
    where: sessionsWhereUniqueInput
    update: XOR<sessionsUpdateWithoutAccountInput, sessionsUncheckedUpdateWithoutAccountInput>
    create: XOR<sessionsCreateWithoutAccountInput, sessionsUncheckedCreateWithoutAccountInput>
  }

  export type sessionsUpdateWithWhereUniqueWithoutAccountInput = {
    where: sessionsWhereUniqueInput
    data: XOR<sessionsUpdateWithoutAccountInput, sessionsUncheckedUpdateWithoutAccountInput>
  }

  export type sessionsUpdateManyWithWhereWithoutAccountInput = {
    where: sessionsScalarWhereInput
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyWithoutAccountInput>
  }

  export type sessionsScalarWhereInput = {
    AND?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    OR?: sessionsScalarWhereInput[]
    NOT?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    id?: StringFilter<"sessions"> | string
    accountId?: StringFilter<"sessions"> | string
    token?: StringFilter<"sessions"> | string
    expiresAt?: DateTimeFilter<"sessions"> | Date | string
    createdAt?: DateTimeFilter<"sessions"> | Date | string
  }

  export type AccountCreateWithoutApplicationInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    email: string
    fullName?: string
    areaCode?: string
    phoneNumber?: string
    gender?: string
    password?: string | null
    emailVerified?: boolean
    websiteCreatedAt?: string
    Case?: CaseCreateNestedManyWithoutAccountInput
    password_reset_tokens?: password_reset_tokensCreateNestedManyWithoutAccountInput
    sessions?: sessionsCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutApplicationInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    email: string
    fullName?: string
    areaCode?: string
    phoneNumber?: string
    gender?: string
    password?: string | null
    emailVerified?: boolean
    websiteCreatedAt?: string
    Case?: CaseUncheckedCreateNestedManyWithoutAccountInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedManyWithoutAccountInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutApplicationInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutApplicationInput, AccountUncheckedCreateWithoutApplicationInput>
  }

  export type DestinationCreateWithoutApplicationInput = {
    id: string
    name: string
    code?: string | null
    VisaType?: VisaTypeCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutApplicationInput = {
    id: string
    name: string
    code?: string | null
    VisaType?: VisaTypeUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutApplicationInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutApplicationInput, DestinationUncheckedCreateWithoutApplicationInput>
  }

  export type VisaTypeCreateWithoutApplicationInput = {
    id: string
    name: string
    waitTime?: string | null
    fees?: number | null
    requiredDocuments?: string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    Destination: DestinationCreateNestedOneWithoutVisaTypeInput
  }

  export type VisaTypeUncheckedCreateWithoutApplicationInput = {
    id: string
    name: string
    waitTime?: string | null
    fees?: number | null
    requiredDocuments?: string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    destinationId: string
  }

  export type VisaTypeCreateOrConnectWithoutApplicationInput = {
    where: VisaTypeWhereUniqueInput
    create: XOR<VisaTypeCreateWithoutApplicationInput, VisaTypeUncheckedCreateWithoutApplicationInput>
  }

  export type ApplicationDocumentCreateWithoutApplicationInput = {
    id: string
    name: string
    type: string
    content: Uint8Array
    status?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    DocumentMapping?: DocumentMappingCreateNestedOneWithoutApplicationDocumentInput
  }

  export type ApplicationDocumentUncheckedCreateWithoutApplicationInput = {
    id: string
    name: string
    type: string
    content: Uint8Array
    status?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    DocumentMapping?: DocumentMappingUncheckedCreateNestedOneWithoutApplicationDocumentInput
  }

  export type ApplicationDocumentCreateOrConnectWithoutApplicationInput = {
    where: ApplicationDocumentWhereUniqueInput
    create: XOR<ApplicationDocumentCreateWithoutApplicationInput, ApplicationDocumentUncheckedCreateWithoutApplicationInput>
  }

  export type ApplicationDocumentCreateManyApplicationInputEnvelope = {
    data: ApplicationDocumentCreateManyApplicationInput | ApplicationDocumentCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type CardHolderCreateWithoutApplicationInput = {
    id: string
    name: string
    cardType: string
    cardNumber: string
    address: string
    zipcode: string
  }

  export type CardHolderUncheckedCreateWithoutApplicationInput = {
    id: string
    name: string
    cardType: string
    cardNumber: string
    address: string
    zipcode: string
  }

  export type CardHolderCreateOrConnectWithoutApplicationInput = {
    where: CardHolderWhereUniqueInput
    create: XOR<CardHolderCreateWithoutApplicationInput, CardHolderUncheckedCreateWithoutApplicationInput>
  }

  export type CaseCreateWithoutApplicationInput = {
    id: string
    gmailThreadId?: string | null
    email: string
    subject: string
    status?: string
    lastUpdate?: Date | string
    websiteCreatedAt: string
    assignedTo?: string | null
    topic?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Account?: AccountCreateNestedOneWithoutCaseInput
    EmailThread?: EmailThreadCreateNestedManyWithoutCaseInput
  }

  export type CaseUncheckedCreateWithoutApplicationInput = {
    id: string
    gmailThreadId?: string | null
    email: string
    subject: string
    status?: string
    lastUpdate?: Date | string
    websiteCreatedAt: string
    accountId?: string | null
    assignedTo?: string | null
    topic?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    EmailThread?: EmailThreadUncheckedCreateNestedManyWithoutCaseInput
  }

  export type CaseCreateOrConnectWithoutApplicationInput = {
    where: CaseWhereUniqueInput
    create: XOR<CaseCreateWithoutApplicationInput, CaseUncheckedCreateWithoutApplicationInput>
  }

  export type CaseCreateManyApplicationInputEnvelope = {
    data: CaseCreateManyApplicationInput | CaseCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type PassengerCreateWithoutApplicationInput = {
    id: string
    createdAt?: Date | string
    name?: string | null
    passportNumber?: string | null
    updatedAt?: Date | string | null
    dateOfBirth?: Date | string | null
    fullName?: string | null
    gender?: string | null
    nationality?: string | null
    passportId?: string | null
    status?: string | null
  }

  export type PassengerUncheckedCreateWithoutApplicationInput = {
    id: string
    createdAt?: Date | string
    name?: string | null
    passportNumber?: string | null
    updatedAt?: Date | string | null
    dateOfBirth?: Date | string | null
    fullName?: string | null
    gender?: string | null
    nationality?: string | null
    passportId?: string | null
    status?: string | null
  }

  export type PassengerCreateOrConnectWithoutApplicationInput = {
    where: PassengerWhereUniqueInput
    create: XOR<PassengerCreateWithoutApplicationInput, PassengerUncheckedCreateWithoutApplicationInput>
  }

  export type PassengerCreateManyApplicationInputEnvelope = {
    data: PassengerCreateManyApplicationInput | PassengerCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type RiskCreateWithoutApplicationInput = {
    id: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastUpdated?: Date | string | null
    RiskActivity?: RiskActivityCreateNestedManyWithoutRiskInput
    RiskDocument?: RiskDocumentCreateNestedManyWithoutRiskInput
  }

  export type RiskUncheckedCreateWithoutApplicationInput = {
    id: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastUpdated?: Date | string | null
    RiskActivity?: RiskActivityUncheckedCreateNestedManyWithoutRiskInput
    RiskDocument?: RiskDocumentUncheckedCreateNestedManyWithoutRiskInput
  }

  export type RiskCreateOrConnectWithoutApplicationInput = {
    where: RiskWhereUniqueInput
    create: XOR<RiskCreateWithoutApplicationInput, RiskUncheckedCreateWithoutApplicationInput>
  }

  export type RiskCreateManyApplicationInputEnvelope = {
    data: RiskCreateManyApplicationInput | RiskCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type StripeActivityCreateWithoutApplicationInput = {
    id: string
    title?: string | null
    amount?: number | null
    createdAt?: Date | string
    status?: string | null
    type?: string | null
    description?: string | null
    timestamp?: Date | string | null
    transactionId?: string | null
    govFeeRefund?: Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: string | null
  }

  export type StripeActivityUncheckedCreateWithoutApplicationInput = {
    id: string
    title?: string | null
    amount?: number | null
    createdAt?: Date | string
    status?: string | null
    type?: string | null
    description?: string | null
    timestamp?: Date | string | null
    transactionId?: string | null
    govFeeRefund?: Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: string | null
  }

  export type StripeActivityCreateOrConnectWithoutApplicationInput = {
    where: StripeActivityWhereUniqueInput
    create: XOR<StripeActivityCreateWithoutApplicationInput, StripeActivityUncheckedCreateWithoutApplicationInput>
  }

  export type StripeActivityCreateManyApplicationInputEnvelope = {
    data: StripeActivityCreateManyApplicationInput | StripeActivityCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutApplicationInput = {
    id: string
    title: string
    description?: string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    dueDate?: Date | string | null
    taskType?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt: Date | string
    taskId: string
    TaskActivity?: TaskActivityCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutApplicationInput = {
    id: string
    title: string
    description?: string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    dueDate?: Date | string | null
    taskType?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt: Date | string
    taskId: string
    TaskActivity?: TaskActivityUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutApplicationInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutApplicationInput, TaskUncheckedCreateWithoutApplicationInput>
  }

  export type TaskCreateManyApplicationInputEnvelope = {
    data: TaskCreateManyApplicationInput | TaskCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutApplicationInput = {
    update: XOR<AccountUpdateWithoutApplicationInput, AccountUncheckedUpdateWithoutApplicationInput>
    create: XOR<AccountCreateWithoutApplicationInput, AccountUncheckedCreateWithoutApplicationInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutApplicationInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutApplicationInput, AccountUncheckedUpdateWithoutApplicationInput>
  }

  export type AccountUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    areaCode?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    Case?: CaseUpdateManyWithoutAccountNestedInput
    password_reset_tokens?: password_reset_tokensUpdateManyWithoutAccountNestedInput
    sessions?: sessionsUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    areaCode?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    Case?: CaseUncheckedUpdateManyWithoutAccountNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateManyWithoutAccountNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type DestinationUpsertWithoutApplicationInput = {
    update: XOR<DestinationUpdateWithoutApplicationInput, DestinationUncheckedUpdateWithoutApplicationInput>
    create: XOR<DestinationCreateWithoutApplicationInput, DestinationUncheckedCreateWithoutApplicationInput>
    where?: DestinationWhereInput
  }

  export type DestinationUpdateToOneWithWhereWithoutApplicationInput = {
    where?: DestinationWhereInput
    data: XOR<DestinationUpdateWithoutApplicationInput, DestinationUncheckedUpdateWithoutApplicationInput>
  }

  export type DestinationUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    VisaType?: VisaTypeUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    VisaType?: VisaTypeUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type VisaTypeUpsertWithoutApplicationInput = {
    update: XOR<VisaTypeUpdateWithoutApplicationInput, VisaTypeUncheckedUpdateWithoutApplicationInput>
    create: XOR<VisaTypeCreateWithoutApplicationInput, VisaTypeUncheckedCreateWithoutApplicationInput>
    where?: VisaTypeWhereInput
  }

  export type VisaTypeUpdateToOneWithWhereWithoutApplicationInput = {
    where?: VisaTypeWhereInput
    data: XOR<VisaTypeUpdateWithoutApplicationInput, VisaTypeUncheckedUpdateWithoutApplicationInput>
  }

  export type VisaTypeUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    waitTime?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    Destination?: DestinationUpdateOneRequiredWithoutVisaTypeNestedInput
  }

  export type VisaTypeUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    waitTime?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    destinationId?: StringFieldUpdateOperationsInput | string
  }

  export type ApplicationDocumentUpsertWithWhereUniqueWithoutApplicationInput = {
    where: ApplicationDocumentWhereUniqueInput
    update: XOR<ApplicationDocumentUpdateWithoutApplicationInput, ApplicationDocumentUncheckedUpdateWithoutApplicationInput>
    create: XOR<ApplicationDocumentCreateWithoutApplicationInput, ApplicationDocumentUncheckedCreateWithoutApplicationInput>
  }

  export type ApplicationDocumentUpdateWithWhereUniqueWithoutApplicationInput = {
    where: ApplicationDocumentWhereUniqueInput
    data: XOR<ApplicationDocumentUpdateWithoutApplicationInput, ApplicationDocumentUncheckedUpdateWithoutApplicationInput>
  }

  export type ApplicationDocumentUpdateManyWithWhereWithoutApplicationInput = {
    where: ApplicationDocumentScalarWhereInput
    data: XOR<ApplicationDocumentUpdateManyMutationInput, ApplicationDocumentUncheckedUpdateManyWithoutApplicationInput>
  }

  export type ApplicationDocumentScalarWhereInput = {
    AND?: ApplicationDocumentScalarWhereInput | ApplicationDocumentScalarWhereInput[]
    OR?: ApplicationDocumentScalarWhereInput[]
    NOT?: ApplicationDocumentScalarWhereInput | ApplicationDocumentScalarWhereInput[]
    id?: StringFilter<"ApplicationDocument"> | string
    applicationId?: StringFilter<"ApplicationDocument"> | string
    name?: StringFilter<"ApplicationDocument"> | string
    type?: StringFilter<"ApplicationDocument"> | string
    content?: BytesFilter<"ApplicationDocument"> | Uint8Array
    status?: StringNullableFilter<"ApplicationDocument"> | string | null
    uploadedAt?: DateTimeFilter<"ApplicationDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"ApplicationDocument"> | string | null
    createdAt?: DateTimeFilter<"ApplicationDocument"> | Date | string
    updatedAt?: DateTimeFilter<"ApplicationDocument"> | Date | string
  }

  export type CardHolderUpsertWithoutApplicationInput = {
    update: XOR<CardHolderUpdateWithoutApplicationInput, CardHolderUncheckedUpdateWithoutApplicationInput>
    create: XOR<CardHolderCreateWithoutApplicationInput, CardHolderUncheckedCreateWithoutApplicationInput>
    where?: CardHolderWhereInput
  }

  export type CardHolderUpdateToOneWithWhereWithoutApplicationInput = {
    where?: CardHolderWhereInput
    data: XOR<CardHolderUpdateWithoutApplicationInput, CardHolderUncheckedUpdateWithoutApplicationInput>
  }

  export type CardHolderUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cardType?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
  }

  export type CardHolderUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cardType?: StringFieldUpdateOperationsInput | string
    cardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
  }

  export type CaseUpsertWithWhereUniqueWithoutApplicationInput = {
    where: CaseWhereUniqueInput
    update: XOR<CaseUpdateWithoutApplicationInput, CaseUncheckedUpdateWithoutApplicationInput>
    create: XOR<CaseCreateWithoutApplicationInput, CaseUncheckedCreateWithoutApplicationInput>
  }

  export type CaseUpdateWithWhereUniqueWithoutApplicationInput = {
    where: CaseWhereUniqueInput
    data: XOR<CaseUpdateWithoutApplicationInput, CaseUncheckedUpdateWithoutApplicationInput>
  }

  export type CaseUpdateManyWithWhereWithoutApplicationInput = {
    where: CaseScalarWhereInput
    data: XOR<CaseUpdateManyMutationInput, CaseUncheckedUpdateManyWithoutApplicationInput>
  }

  export type PassengerUpsertWithWhereUniqueWithoutApplicationInput = {
    where: PassengerWhereUniqueInput
    update: XOR<PassengerUpdateWithoutApplicationInput, PassengerUncheckedUpdateWithoutApplicationInput>
    create: XOR<PassengerCreateWithoutApplicationInput, PassengerUncheckedCreateWithoutApplicationInput>
  }

  export type PassengerUpdateWithWhereUniqueWithoutApplicationInput = {
    where: PassengerWhereUniqueInput
    data: XOR<PassengerUpdateWithoutApplicationInput, PassengerUncheckedUpdateWithoutApplicationInput>
  }

  export type PassengerUpdateManyWithWhereWithoutApplicationInput = {
    where: PassengerScalarWhereInput
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyWithoutApplicationInput>
  }

  export type PassengerScalarWhereInput = {
    AND?: PassengerScalarWhereInput | PassengerScalarWhereInput[]
    OR?: PassengerScalarWhereInput[]
    NOT?: PassengerScalarWhereInput | PassengerScalarWhereInput[]
    id?: StringFilter<"Passenger"> | string
    applicationId?: StringFilter<"Passenger"> | string
    createdAt?: DateTimeFilter<"Passenger"> | Date | string
    name?: StringNullableFilter<"Passenger"> | string | null
    passportNumber?: StringNullableFilter<"Passenger"> | string | null
    updatedAt?: DateTimeNullableFilter<"Passenger"> | Date | string | null
    dateOfBirth?: DateTimeNullableFilter<"Passenger"> | Date | string | null
    fullName?: StringNullableFilter<"Passenger"> | string | null
    gender?: StringNullableFilter<"Passenger"> | string | null
    nationality?: StringNullableFilter<"Passenger"> | string | null
    passportId?: StringNullableFilter<"Passenger"> | string | null
    status?: StringNullableFilter<"Passenger"> | string | null
  }

  export type RiskUpsertWithWhereUniqueWithoutApplicationInput = {
    where: RiskWhereUniqueInput
    update: XOR<RiskUpdateWithoutApplicationInput, RiskUncheckedUpdateWithoutApplicationInput>
    create: XOR<RiskCreateWithoutApplicationInput, RiskUncheckedCreateWithoutApplicationInput>
  }

  export type RiskUpdateWithWhereUniqueWithoutApplicationInput = {
    where: RiskWhereUniqueInput
    data: XOR<RiskUpdateWithoutApplicationInput, RiskUncheckedUpdateWithoutApplicationInput>
  }

  export type RiskUpdateManyWithWhereWithoutApplicationInput = {
    where: RiskScalarWhereInput
    data: XOR<RiskUpdateManyMutationInput, RiskUncheckedUpdateManyWithoutApplicationInput>
  }

  export type RiskScalarWhereInput = {
    AND?: RiskScalarWhereInput | RiskScalarWhereInput[]
    OR?: RiskScalarWhereInput[]
    NOT?: RiskScalarWhereInput | RiskScalarWhereInput[]
    id?: StringFilter<"Risk"> | string
    status?: StringFilter<"Risk"> | string
    applicationId?: StringFilter<"Risk"> | string
    createdAt?: DateTimeFilter<"Risk"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Risk"> | Date | string | null
    lastUpdated?: DateTimeNullableFilter<"Risk"> | Date | string | null
  }

  export type StripeActivityUpsertWithWhereUniqueWithoutApplicationInput = {
    where: StripeActivityWhereUniqueInput
    update: XOR<StripeActivityUpdateWithoutApplicationInput, StripeActivityUncheckedUpdateWithoutApplicationInput>
    create: XOR<StripeActivityCreateWithoutApplicationInput, StripeActivityUncheckedCreateWithoutApplicationInput>
  }

  export type StripeActivityUpdateWithWhereUniqueWithoutApplicationInput = {
    where: StripeActivityWhereUniqueInput
    data: XOR<StripeActivityUpdateWithoutApplicationInput, StripeActivityUncheckedUpdateWithoutApplicationInput>
  }

  export type StripeActivityUpdateManyWithWhereWithoutApplicationInput = {
    where: StripeActivityScalarWhereInput
    data: XOR<StripeActivityUpdateManyMutationInput, StripeActivityUncheckedUpdateManyWithoutApplicationInput>
  }

  export type StripeActivityScalarWhereInput = {
    AND?: StripeActivityScalarWhereInput | StripeActivityScalarWhereInput[]
    OR?: StripeActivityScalarWhereInput[]
    NOT?: StripeActivityScalarWhereInput | StripeActivityScalarWhereInput[]
    id?: StringFilter<"StripeActivity"> | string
    title?: StringNullableFilter<"StripeActivity"> | string | null
    amount?: FloatNullableFilter<"StripeActivity"> | number | null
    createdAt?: DateTimeFilter<"StripeActivity"> | Date | string
    status?: StringNullableFilter<"StripeActivity"> | string | null
    type?: StringNullableFilter<"StripeActivity"> | string | null
    applicationId?: StringNullableFilter<"StripeActivity"> | string | null
    description?: StringNullableFilter<"StripeActivity"> | string | null
    timestamp?: DateTimeNullableFilter<"StripeActivity"> | Date | string | null
    transactionId?: StringNullableFilter<"StripeActivity"> | string | null
    govFeeRefund?: DecimalNullableFilter<"StripeActivity"> | Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: DecimalNullableFilter<"StripeActivity"> | Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: StringNullableFilter<"StripeActivity"> | string | null
  }

  export type TaskUpsertWithWhereUniqueWithoutApplicationInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutApplicationInput, TaskUncheckedUpdateWithoutApplicationInput>
    create: XOR<TaskCreateWithoutApplicationInput, TaskUncheckedCreateWithoutApplicationInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutApplicationInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutApplicationInput, TaskUncheckedUpdateWithoutApplicationInput>
  }

  export type TaskUpdateManyWithWhereWithoutApplicationInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutApplicationInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    assignedTo?: StringNullableFilter<"Task"> | string | null
    assignedToEmail?: StringNullableFilter<"Task"> | string | null
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    taskType?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    applicationId?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    taskId?: StringFilter<"Task"> | string
  }

  export type ApplicationCreateWithoutApplicationDocumentInput = {
    id?: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    Account: AccountCreateNestedOneWithoutApplicationInput
    Destination: DestinationCreateNestedOneWithoutApplicationInput
    VisaType: VisaTypeCreateNestedOneWithoutApplicationInput
    CardHolder?: CardHolderCreateNestedOneWithoutApplicationInput
    Case?: CaseCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerCreateNestedManyWithoutApplicationInput
    Risk?: RiskCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityCreateNestedManyWithoutApplicationInput
    Task?: TaskCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutApplicationDocumentInput = {
    id?: string
    destinationId: string
    visaTypeId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    CardHolder?: CardHolderUncheckedCreateNestedOneWithoutApplicationInput
    Case?: CaseUncheckedCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerUncheckedCreateNestedManyWithoutApplicationInput
    Risk?: RiskUncheckedCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityUncheckedCreateNestedManyWithoutApplicationInput
    Task?: TaskUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutApplicationDocumentInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutApplicationDocumentInput, ApplicationUncheckedCreateWithoutApplicationDocumentInput>
  }

  export type DocumentMappingCreateWithoutApplicationDocumentInput = {
    id: string
    mappedTo?: string | null
    isInvalid?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DocumentMappingUncheckedCreateWithoutApplicationDocumentInput = {
    id: string
    mappedTo?: string | null
    isInvalid?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DocumentMappingCreateOrConnectWithoutApplicationDocumentInput = {
    where: DocumentMappingWhereUniqueInput
    create: XOR<DocumentMappingCreateWithoutApplicationDocumentInput, DocumentMappingUncheckedCreateWithoutApplicationDocumentInput>
  }

  export type ApplicationUpsertWithoutApplicationDocumentInput = {
    update: XOR<ApplicationUpdateWithoutApplicationDocumentInput, ApplicationUncheckedUpdateWithoutApplicationDocumentInput>
    create: XOR<ApplicationCreateWithoutApplicationDocumentInput, ApplicationUncheckedCreateWithoutApplicationDocumentInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutApplicationDocumentInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutApplicationDocumentInput, ApplicationUncheckedUpdateWithoutApplicationDocumentInput>
  }

  export type ApplicationUpdateWithoutApplicationDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUpdateOneRequiredWithoutApplicationNestedInput
    Destination?: DestinationUpdateOneRequiredWithoutApplicationNestedInput
    VisaType?: VisaTypeUpdateOneRequiredWithoutApplicationNestedInput
    CardHolder?: CardHolderUpdateOneWithoutApplicationNestedInput
    Case?: CaseUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUpdateManyWithoutApplicationNestedInput
    Task?: TaskUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutApplicationDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    CardHolder?: CardHolderUncheckedUpdateOneWithoutApplicationNestedInput
    Case?: CaseUncheckedUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUncheckedUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUncheckedUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUncheckedUpdateManyWithoutApplicationNestedInput
    Task?: TaskUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type DocumentMappingUpsertWithoutApplicationDocumentInput = {
    update: XOR<DocumentMappingUpdateWithoutApplicationDocumentInput, DocumentMappingUncheckedUpdateWithoutApplicationDocumentInput>
    create: XOR<DocumentMappingCreateWithoutApplicationDocumentInput, DocumentMappingUncheckedCreateWithoutApplicationDocumentInput>
    where?: DocumentMappingWhereInput
  }

  export type DocumentMappingUpdateToOneWithWhereWithoutApplicationDocumentInput = {
    where?: DocumentMappingWhereInput
    data: XOR<DocumentMappingUpdateWithoutApplicationDocumentInput, DocumentMappingUncheckedUpdateWithoutApplicationDocumentInput>
  }

  export type DocumentMappingUpdateWithoutApplicationDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mappedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isInvalid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentMappingUncheckedUpdateWithoutApplicationDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mappedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isInvalid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailThreadCreateWithoutAttachmentInput = {
    id: string
    messageId: string
    fromEmail: string
    toEmail: string
    subject: string
    body: string
    timestamp?: Date | string
    direction: string
    cc?: string | null
    bcc?: string | null
    Case: CaseCreateNestedOneWithoutEmailThreadInput
  }

  export type EmailThreadUncheckedCreateWithoutAttachmentInput = {
    id: string
    caseId: string
    messageId: string
    fromEmail: string
    toEmail: string
    subject: string
    body: string
    timestamp?: Date | string
    direction: string
    cc?: string | null
    bcc?: string | null
  }

  export type EmailThreadCreateOrConnectWithoutAttachmentInput = {
    where: EmailThreadWhereUniqueInput
    create: XOR<EmailThreadCreateWithoutAttachmentInput, EmailThreadUncheckedCreateWithoutAttachmentInput>
  }

  export type EmailThreadUpsertWithoutAttachmentInput = {
    update: XOR<EmailThreadUpdateWithoutAttachmentInput, EmailThreadUncheckedUpdateWithoutAttachmentInput>
    create: XOR<EmailThreadCreateWithoutAttachmentInput, EmailThreadUncheckedCreateWithoutAttachmentInput>
    where?: EmailThreadWhereInput
  }

  export type EmailThreadUpdateToOneWithWhereWithoutAttachmentInput = {
    where?: EmailThreadWhereInput
    data: XOR<EmailThreadUpdateWithoutAttachmentInput, EmailThreadUncheckedUpdateWithoutAttachmentInput>
  }

  export type EmailThreadUpdateWithoutAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    toEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    direction?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    Case?: CaseUpdateOneRequiredWithoutEmailThreadNestedInput
  }

  export type EmailThreadUncheckedUpdateWithoutAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    toEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    direction?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationCreateWithoutCardHolderInput = {
    id?: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    Account: AccountCreateNestedOneWithoutApplicationInput
    Destination: DestinationCreateNestedOneWithoutApplicationInput
    VisaType: VisaTypeCreateNestedOneWithoutApplicationInput
    ApplicationDocument?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    Case?: CaseCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerCreateNestedManyWithoutApplicationInput
    Risk?: RiskCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityCreateNestedManyWithoutApplicationInput
    Task?: TaskCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutCardHolderInput = {
    id?: string
    destinationId: string
    visaTypeId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    ApplicationDocument?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    Case?: CaseUncheckedCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerUncheckedCreateNestedManyWithoutApplicationInput
    Risk?: RiskUncheckedCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityUncheckedCreateNestedManyWithoutApplicationInput
    Task?: TaskUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutCardHolderInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutCardHolderInput, ApplicationUncheckedCreateWithoutCardHolderInput>
  }

  export type ApplicationUpsertWithoutCardHolderInput = {
    update: XOR<ApplicationUpdateWithoutCardHolderInput, ApplicationUncheckedUpdateWithoutCardHolderInput>
    create: XOR<ApplicationCreateWithoutCardHolderInput, ApplicationUncheckedCreateWithoutCardHolderInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutCardHolderInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutCardHolderInput, ApplicationUncheckedUpdateWithoutCardHolderInput>
  }

  export type ApplicationUpdateWithoutCardHolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUpdateOneRequiredWithoutApplicationNestedInput
    Destination?: DestinationUpdateOneRequiredWithoutApplicationNestedInput
    VisaType?: VisaTypeUpdateOneRequiredWithoutApplicationNestedInput
    ApplicationDocument?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    Case?: CaseUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUpdateManyWithoutApplicationNestedInput
    Task?: TaskUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutCardHolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    ApplicationDocument?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    Case?: CaseUncheckedUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUncheckedUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUncheckedUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUncheckedUpdateManyWithoutApplicationNestedInput
    Task?: TaskUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type AccountCreateWithoutCaseInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    email: string
    fullName?: string
    areaCode?: string
    phoneNumber?: string
    gender?: string
    password?: string | null
    emailVerified?: boolean
    websiteCreatedAt?: string
    Application?: ApplicationCreateNestedManyWithoutAccountInput
    password_reset_tokens?: password_reset_tokensCreateNestedManyWithoutAccountInput
    sessions?: sessionsCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutCaseInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    email: string
    fullName?: string
    areaCode?: string
    phoneNumber?: string
    gender?: string
    password?: string | null
    emailVerified?: boolean
    websiteCreatedAt?: string
    Application?: ApplicationUncheckedCreateNestedManyWithoutAccountInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedManyWithoutAccountInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutCaseInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCaseInput, AccountUncheckedCreateWithoutCaseInput>
  }

  export type ApplicationCreateWithoutCaseInput = {
    id?: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    Account: AccountCreateNestedOneWithoutApplicationInput
    Destination: DestinationCreateNestedOneWithoutApplicationInput
    VisaType: VisaTypeCreateNestedOneWithoutApplicationInput
    ApplicationDocument?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderCreateNestedOneWithoutApplicationInput
    Passenger?: PassengerCreateNestedManyWithoutApplicationInput
    Risk?: RiskCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityCreateNestedManyWithoutApplicationInput
    Task?: TaskCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutCaseInput = {
    id?: string
    destinationId: string
    visaTypeId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    ApplicationDocument?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderUncheckedCreateNestedOneWithoutApplicationInput
    Passenger?: PassengerUncheckedCreateNestedManyWithoutApplicationInput
    Risk?: RiskUncheckedCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityUncheckedCreateNestedManyWithoutApplicationInput
    Task?: TaskUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutCaseInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutCaseInput, ApplicationUncheckedCreateWithoutCaseInput>
  }

  export type EmailThreadCreateWithoutCaseInput = {
    id: string
    messageId: string
    fromEmail: string
    toEmail: string
    subject: string
    body: string
    timestamp?: Date | string
    direction: string
    cc?: string | null
    bcc?: string | null
    Attachment?: AttachmentCreateNestedManyWithoutEmailThreadInput
  }

  export type EmailThreadUncheckedCreateWithoutCaseInput = {
    id: string
    messageId: string
    fromEmail: string
    toEmail: string
    subject: string
    body: string
    timestamp?: Date | string
    direction: string
    cc?: string | null
    bcc?: string | null
    Attachment?: AttachmentUncheckedCreateNestedManyWithoutEmailThreadInput
  }

  export type EmailThreadCreateOrConnectWithoutCaseInput = {
    where: EmailThreadWhereUniqueInput
    create: XOR<EmailThreadCreateWithoutCaseInput, EmailThreadUncheckedCreateWithoutCaseInput>
  }

  export type EmailThreadCreateManyCaseInputEnvelope = {
    data: EmailThreadCreateManyCaseInput | EmailThreadCreateManyCaseInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutCaseInput = {
    update: XOR<AccountUpdateWithoutCaseInput, AccountUncheckedUpdateWithoutCaseInput>
    create: XOR<AccountCreateWithoutCaseInput, AccountUncheckedCreateWithoutCaseInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCaseInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCaseInput, AccountUncheckedUpdateWithoutCaseInput>
  }

  export type AccountUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    areaCode?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    Application?: ApplicationUpdateManyWithoutAccountNestedInput
    password_reset_tokens?: password_reset_tokensUpdateManyWithoutAccountNestedInput
    sessions?: sessionsUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    areaCode?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    Application?: ApplicationUncheckedUpdateManyWithoutAccountNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateManyWithoutAccountNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ApplicationUpsertWithoutCaseInput = {
    update: XOR<ApplicationUpdateWithoutCaseInput, ApplicationUncheckedUpdateWithoutCaseInput>
    create: XOR<ApplicationCreateWithoutCaseInput, ApplicationUncheckedCreateWithoutCaseInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutCaseInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutCaseInput, ApplicationUncheckedUpdateWithoutCaseInput>
  }

  export type ApplicationUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUpdateOneRequiredWithoutApplicationNestedInput
    Destination?: DestinationUpdateOneRequiredWithoutApplicationNestedInput
    VisaType?: VisaTypeUpdateOneRequiredWithoutApplicationNestedInput
    ApplicationDocument?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUpdateOneWithoutApplicationNestedInput
    Passenger?: PassengerUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUpdateManyWithoutApplicationNestedInput
    Task?: TaskUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    ApplicationDocument?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUncheckedUpdateOneWithoutApplicationNestedInput
    Passenger?: PassengerUncheckedUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUncheckedUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUncheckedUpdateManyWithoutApplicationNestedInput
    Task?: TaskUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type EmailThreadUpsertWithWhereUniqueWithoutCaseInput = {
    where: EmailThreadWhereUniqueInput
    update: XOR<EmailThreadUpdateWithoutCaseInput, EmailThreadUncheckedUpdateWithoutCaseInput>
    create: XOR<EmailThreadCreateWithoutCaseInput, EmailThreadUncheckedCreateWithoutCaseInput>
  }

  export type EmailThreadUpdateWithWhereUniqueWithoutCaseInput = {
    where: EmailThreadWhereUniqueInput
    data: XOR<EmailThreadUpdateWithoutCaseInput, EmailThreadUncheckedUpdateWithoutCaseInput>
  }

  export type EmailThreadUpdateManyWithWhereWithoutCaseInput = {
    where: EmailThreadScalarWhereInput
    data: XOR<EmailThreadUpdateManyMutationInput, EmailThreadUncheckedUpdateManyWithoutCaseInput>
  }

  export type EmailThreadScalarWhereInput = {
    AND?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
    OR?: EmailThreadScalarWhereInput[]
    NOT?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
    id?: StringFilter<"EmailThread"> | string
    caseId?: StringFilter<"EmailThread"> | string
    messageId?: StringFilter<"EmailThread"> | string
    fromEmail?: StringFilter<"EmailThread"> | string
    toEmail?: StringFilter<"EmailThread"> | string
    subject?: StringFilter<"EmailThread"> | string
    body?: StringFilter<"EmailThread"> | string
    timestamp?: DateTimeFilter<"EmailThread"> | Date | string
    direction?: StringFilter<"EmailThread"> | string
    cc?: StringNullableFilter<"EmailThread"> | string | null
    bcc?: StringNullableFilter<"EmailThread"> | string | null
  }

  export type ApplicationCreateWithoutDestinationInput = {
    id?: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    Account: AccountCreateNestedOneWithoutApplicationInput
    VisaType: VisaTypeCreateNestedOneWithoutApplicationInput
    ApplicationDocument?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderCreateNestedOneWithoutApplicationInput
    Case?: CaseCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerCreateNestedManyWithoutApplicationInput
    Risk?: RiskCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityCreateNestedManyWithoutApplicationInput
    Task?: TaskCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutDestinationInput = {
    id?: string
    visaTypeId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    ApplicationDocument?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderUncheckedCreateNestedOneWithoutApplicationInput
    Case?: CaseUncheckedCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerUncheckedCreateNestedManyWithoutApplicationInput
    Risk?: RiskUncheckedCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityUncheckedCreateNestedManyWithoutApplicationInput
    Task?: TaskUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutDestinationInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutDestinationInput, ApplicationUncheckedCreateWithoutDestinationInput>
  }

  export type ApplicationCreateManyDestinationInputEnvelope = {
    data: ApplicationCreateManyDestinationInput | ApplicationCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type VisaTypeCreateWithoutDestinationInput = {
    id: string
    name: string
    waitTime?: string | null
    fees?: number | null
    requiredDocuments?: string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    Application?: ApplicationCreateNestedManyWithoutVisaTypeInput
  }

  export type VisaTypeUncheckedCreateWithoutDestinationInput = {
    id: string
    name: string
    waitTime?: string | null
    fees?: number | null
    requiredDocuments?: string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    Application?: ApplicationUncheckedCreateNestedManyWithoutVisaTypeInput
  }

  export type VisaTypeCreateOrConnectWithoutDestinationInput = {
    where: VisaTypeWhereUniqueInput
    create: XOR<VisaTypeCreateWithoutDestinationInput, VisaTypeUncheckedCreateWithoutDestinationInput>
  }

  export type VisaTypeCreateManyDestinationInputEnvelope = {
    data: VisaTypeCreateManyDestinationInput | VisaTypeCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationUpsertWithWhereUniqueWithoutDestinationInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutDestinationInput, ApplicationUncheckedUpdateWithoutDestinationInput>
    create: XOR<ApplicationCreateWithoutDestinationInput, ApplicationUncheckedCreateWithoutDestinationInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutDestinationInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutDestinationInput, ApplicationUncheckedUpdateWithoutDestinationInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutDestinationInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutDestinationInput>
  }

  export type VisaTypeUpsertWithWhereUniqueWithoutDestinationInput = {
    where: VisaTypeWhereUniqueInput
    update: XOR<VisaTypeUpdateWithoutDestinationInput, VisaTypeUncheckedUpdateWithoutDestinationInput>
    create: XOR<VisaTypeCreateWithoutDestinationInput, VisaTypeUncheckedCreateWithoutDestinationInput>
  }

  export type VisaTypeUpdateWithWhereUniqueWithoutDestinationInput = {
    where: VisaTypeWhereUniqueInput
    data: XOR<VisaTypeUpdateWithoutDestinationInput, VisaTypeUncheckedUpdateWithoutDestinationInput>
  }

  export type VisaTypeUpdateManyWithWhereWithoutDestinationInput = {
    where: VisaTypeScalarWhereInput
    data: XOR<VisaTypeUpdateManyMutationInput, VisaTypeUncheckedUpdateManyWithoutDestinationInput>
  }

  export type VisaTypeScalarWhereInput = {
    AND?: VisaTypeScalarWhereInput | VisaTypeScalarWhereInput[]
    OR?: VisaTypeScalarWhereInput[]
    NOT?: VisaTypeScalarWhereInput | VisaTypeScalarWhereInput[]
    id?: StringFilter<"VisaType"> | string
    name?: StringFilter<"VisaType"> | string
    waitTime?: StringNullableFilter<"VisaType"> | string | null
    fees?: FloatNullableFilter<"VisaType"> | number | null
    requiredDocuments?: StringNullableFilter<"VisaType"> | string | null
    allowedNationalities?: JsonNullableFilter<"VisaType">
    destinationId?: StringFilter<"VisaType"> | string
  }

  export type ApplicationDocumentCreateWithoutDocumentMappingInput = {
    id: string
    name: string
    type: string
    content: Uint8Array
    status?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Application: ApplicationCreateNestedOneWithoutApplicationDocumentInput
  }

  export type ApplicationDocumentUncheckedCreateWithoutDocumentMappingInput = {
    id: string
    applicationId: string
    name: string
    type: string
    content: Uint8Array
    status?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ApplicationDocumentCreateOrConnectWithoutDocumentMappingInput = {
    where: ApplicationDocumentWhereUniqueInput
    create: XOR<ApplicationDocumentCreateWithoutDocumentMappingInput, ApplicationDocumentUncheckedCreateWithoutDocumentMappingInput>
  }

  export type ApplicationDocumentUpsertWithoutDocumentMappingInput = {
    update: XOR<ApplicationDocumentUpdateWithoutDocumentMappingInput, ApplicationDocumentUncheckedUpdateWithoutDocumentMappingInput>
    create: XOR<ApplicationDocumentCreateWithoutDocumentMappingInput, ApplicationDocumentUncheckedCreateWithoutDocumentMappingInput>
    where?: ApplicationDocumentWhereInput
  }

  export type ApplicationDocumentUpdateToOneWithWhereWithoutDocumentMappingInput = {
    where?: ApplicationDocumentWhereInput
    data: XOR<ApplicationDocumentUpdateWithoutDocumentMappingInput, ApplicationDocumentUncheckedUpdateWithoutDocumentMappingInput>
  }

  export type ApplicationDocumentUpdateWithoutDocumentMappingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    status?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Application?: ApplicationUpdateOneRequiredWithoutApplicationDocumentNestedInput
  }

  export type ApplicationDocumentUncheckedUpdateWithoutDocumentMappingInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    status?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateWithoutEmailThreadInput = {
    id: string
    filename: string
    content: Uint8Array
    createdAt?: Date | string
  }

  export type AttachmentUncheckedCreateWithoutEmailThreadInput = {
    id: string
    filename: string
    content: Uint8Array
    createdAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutEmailThreadInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutEmailThreadInput, AttachmentUncheckedCreateWithoutEmailThreadInput>
  }

  export type AttachmentCreateManyEmailThreadInputEnvelope = {
    data: AttachmentCreateManyEmailThreadInput | AttachmentCreateManyEmailThreadInput[]
    skipDuplicates?: boolean
  }

  export type CaseCreateWithoutEmailThreadInput = {
    id: string
    gmailThreadId?: string | null
    email: string
    subject: string
    status?: string
    lastUpdate?: Date | string
    websiteCreatedAt: string
    assignedTo?: string | null
    topic?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Account?: AccountCreateNestedOneWithoutCaseInput
    Application?: ApplicationCreateNestedOneWithoutCaseInput
  }

  export type CaseUncheckedCreateWithoutEmailThreadInput = {
    id: string
    gmailThreadId?: string | null
    email: string
    subject: string
    status?: string
    lastUpdate?: Date | string
    websiteCreatedAt: string
    accountId?: string | null
    applicationId?: string | null
    assignedTo?: string | null
    topic?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CaseCreateOrConnectWithoutEmailThreadInput = {
    where: CaseWhereUniqueInput
    create: XOR<CaseCreateWithoutEmailThreadInput, CaseUncheckedCreateWithoutEmailThreadInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutEmailThreadInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutEmailThreadInput, AttachmentUncheckedUpdateWithoutEmailThreadInput>
    create: XOR<AttachmentCreateWithoutEmailThreadInput, AttachmentUncheckedCreateWithoutEmailThreadInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutEmailThreadInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutEmailThreadInput, AttachmentUncheckedUpdateWithoutEmailThreadInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutEmailThreadInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutEmailThreadInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: StringFilter<"Attachment"> | string
    emailThreadId?: StringFilter<"Attachment"> | string
    filename?: StringFilter<"Attachment"> | string
    content?: BytesFilter<"Attachment"> | Uint8Array
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
  }

  export type CaseUpsertWithoutEmailThreadInput = {
    update: XOR<CaseUpdateWithoutEmailThreadInput, CaseUncheckedUpdateWithoutEmailThreadInput>
    create: XOR<CaseCreateWithoutEmailThreadInput, CaseUncheckedCreateWithoutEmailThreadInput>
    where?: CaseWhereInput
  }

  export type CaseUpdateToOneWithWhereWithoutEmailThreadInput = {
    where?: CaseWhereInput
    data: XOR<CaseUpdateWithoutEmailThreadInput, CaseUncheckedUpdateWithoutEmailThreadInput>
  }

  export type CaseUpdateWithoutEmailThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Account?: AccountUpdateOneWithoutCaseNestedInput
    Application?: ApplicationUpdateOneWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateWithoutEmailThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateWithoutPassengerInput = {
    id?: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    Account: AccountCreateNestedOneWithoutApplicationInput
    Destination: DestinationCreateNestedOneWithoutApplicationInput
    VisaType: VisaTypeCreateNestedOneWithoutApplicationInput
    ApplicationDocument?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderCreateNestedOneWithoutApplicationInput
    Case?: CaseCreateNestedManyWithoutApplicationInput
    Risk?: RiskCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityCreateNestedManyWithoutApplicationInput
    Task?: TaskCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutPassengerInput = {
    id?: string
    destinationId: string
    visaTypeId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    ApplicationDocument?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderUncheckedCreateNestedOneWithoutApplicationInput
    Case?: CaseUncheckedCreateNestedManyWithoutApplicationInput
    Risk?: RiskUncheckedCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityUncheckedCreateNestedManyWithoutApplicationInput
    Task?: TaskUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutPassengerInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutPassengerInput, ApplicationUncheckedCreateWithoutPassengerInput>
  }

  export type ApplicationUpsertWithoutPassengerInput = {
    update: XOR<ApplicationUpdateWithoutPassengerInput, ApplicationUncheckedUpdateWithoutPassengerInput>
    create: XOR<ApplicationCreateWithoutPassengerInput, ApplicationUncheckedCreateWithoutPassengerInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutPassengerInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutPassengerInput, ApplicationUncheckedUpdateWithoutPassengerInput>
  }

  export type ApplicationUpdateWithoutPassengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUpdateOneRequiredWithoutApplicationNestedInput
    Destination?: DestinationUpdateOneRequiredWithoutApplicationNestedInput
    VisaType?: VisaTypeUpdateOneRequiredWithoutApplicationNestedInput
    ApplicationDocument?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUpdateOneWithoutApplicationNestedInput
    Case?: CaseUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUpdateManyWithoutApplicationNestedInput
    Task?: TaskUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutPassengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    ApplicationDocument?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUncheckedUpdateOneWithoutApplicationNestedInput
    Case?: CaseUncheckedUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUncheckedUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUncheckedUpdateManyWithoutApplicationNestedInput
    Task?: TaskUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationCreateWithoutRiskInput = {
    id?: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    Account: AccountCreateNestedOneWithoutApplicationInput
    Destination: DestinationCreateNestedOneWithoutApplicationInput
    VisaType: VisaTypeCreateNestedOneWithoutApplicationInput
    ApplicationDocument?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderCreateNestedOneWithoutApplicationInput
    Case?: CaseCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityCreateNestedManyWithoutApplicationInput
    Task?: TaskCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutRiskInput = {
    id?: string
    destinationId: string
    visaTypeId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    ApplicationDocument?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderUncheckedCreateNestedOneWithoutApplicationInput
    Case?: CaseUncheckedCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerUncheckedCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityUncheckedCreateNestedManyWithoutApplicationInput
    Task?: TaskUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutRiskInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutRiskInput, ApplicationUncheckedCreateWithoutRiskInput>
  }

  export type RiskActivityCreateWithoutRiskInput = {
    id: string
    createdAt?: Date | string
    description?: string | null
    type?: string | null
    details?: string | null
    timestamp?: Date | string | null
    title?: string | null
  }

  export type RiskActivityUncheckedCreateWithoutRiskInput = {
    id: string
    createdAt?: Date | string
    description?: string | null
    type?: string | null
    details?: string | null
    timestamp?: Date | string | null
    title?: string | null
  }

  export type RiskActivityCreateOrConnectWithoutRiskInput = {
    where: RiskActivityWhereUniqueInput
    create: XOR<RiskActivityCreateWithoutRiskInput, RiskActivityUncheckedCreateWithoutRiskInput>
  }

  export type RiskActivityCreateManyRiskInputEnvelope = {
    data: RiskActivityCreateManyRiskInput | RiskActivityCreateManyRiskInput[]
    skipDuplicates?: boolean
  }

  export type RiskDocumentCreateWithoutRiskInput = {
    id: string
    name: string
    createdAt?: Date | string
    status?: string
    updatedAt: Date | string
    type: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
    content: Uint8Array
  }

  export type RiskDocumentUncheckedCreateWithoutRiskInput = {
    id: string
    name: string
    createdAt?: Date | string
    status?: string
    updatedAt: Date | string
    type: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
    content: Uint8Array
  }

  export type RiskDocumentCreateOrConnectWithoutRiskInput = {
    where: RiskDocumentWhereUniqueInput
    create: XOR<RiskDocumentCreateWithoutRiskInput, RiskDocumentUncheckedCreateWithoutRiskInput>
  }

  export type RiskDocumentCreateManyRiskInputEnvelope = {
    data: RiskDocumentCreateManyRiskInput | RiskDocumentCreateManyRiskInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationUpsertWithoutRiskInput = {
    update: XOR<ApplicationUpdateWithoutRiskInput, ApplicationUncheckedUpdateWithoutRiskInput>
    create: XOR<ApplicationCreateWithoutRiskInput, ApplicationUncheckedCreateWithoutRiskInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutRiskInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutRiskInput, ApplicationUncheckedUpdateWithoutRiskInput>
  }

  export type ApplicationUpdateWithoutRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUpdateOneRequiredWithoutApplicationNestedInput
    Destination?: DestinationUpdateOneRequiredWithoutApplicationNestedInput
    VisaType?: VisaTypeUpdateOneRequiredWithoutApplicationNestedInput
    ApplicationDocument?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUpdateOneWithoutApplicationNestedInput
    Case?: CaseUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUpdateManyWithoutApplicationNestedInput
    Task?: TaskUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    ApplicationDocument?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUncheckedUpdateOneWithoutApplicationNestedInput
    Case?: CaseUncheckedUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUncheckedUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUncheckedUpdateManyWithoutApplicationNestedInput
    Task?: TaskUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type RiskActivityUpsertWithWhereUniqueWithoutRiskInput = {
    where: RiskActivityWhereUniqueInput
    update: XOR<RiskActivityUpdateWithoutRiskInput, RiskActivityUncheckedUpdateWithoutRiskInput>
    create: XOR<RiskActivityCreateWithoutRiskInput, RiskActivityUncheckedCreateWithoutRiskInput>
  }

  export type RiskActivityUpdateWithWhereUniqueWithoutRiskInput = {
    where: RiskActivityWhereUniqueInput
    data: XOR<RiskActivityUpdateWithoutRiskInput, RiskActivityUncheckedUpdateWithoutRiskInput>
  }

  export type RiskActivityUpdateManyWithWhereWithoutRiskInput = {
    where: RiskActivityScalarWhereInput
    data: XOR<RiskActivityUpdateManyMutationInput, RiskActivityUncheckedUpdateManyWithoutRiskInput>
  }

  export type RiskActivityScalarWhereInput = {
    AND?: RiskActivityScalarWhereInput | RiskActivityScalarWhereInput[]
    OR?: RiskActivityScalarWhereInput[]
    NOT?: RiskActivityScalarWhereInput | RiskActivityScalarWhereInput[]
    id?: StringFilter<"RiskActivity"> | string
    riskId?: StringFilter<"RiskActivity"> | string
    createdAt?: DateTimeFilter<"RiskActivity"> | Date | string
    description?: StringNullableFilter<"RiskActivity"> | string | null
    type?: StringNullableFilter<"RiskActivity"> | string | null
    details?: StringNullableFilter<"RiskActivity"> | string | null
    timestamp?: DateTimeNullableFilter<"RiskActivity"> | Date | string | null
    title?: StringNullableFilter<"RiskActivity"> | string | null
  }

  export type RiskDocumentUpsertWithWhereUniqueWithoutRiskInput = {
    where: RiskDocumentWhereUniqueInput
    update: XOR<RiskDocumentUpdateWithoutRiskInput, RiskDocumentUncheckedUpdateWithoutRiskInput>
    create: XOR<RiskDocumentCreateWithoutRiskInput, RiskDocumentUncheckedCreateWithoutRiskInput>
  }

  export type RiskDocumentUpdateWithWhereUniqueWithoutRiskInput = {
    where: RiskDocumentWhereUniqueInput
    data: XOR<RiskDocumentUpdateWithoutRiskInput, RiskDocumentUncheckedUpdateWithoutRiskInput>
  }

  export type RiskDocumentUpdateManyWithWhereWithoutRiskInput = {
    where: RiskDocumentScalarWhereInput
    data: XOR<RiskDocumentUpdateManyMutationInput, RiskDocumentUncheckedUpdateManyWithoutRiskInput>
  }

  export type RiskDocumentScalarWhereInput = {
    AND?: RiskDocumentScalarWhereInput | RiskDocumentScalarWhereInput[]
    OR?: RiskDocumentScalarWhereInput[]
    NOT?: RiskDocumentScalarWhereInput | RiskDocumentScalarWhereInput[]
    id?: StringFilter<"RiskDocument"> | string
    name?: StringFilter<"RiskDocument"> | string
    riskId?: StringFilter<"RiskDocument"> | string
    createdAt?: DateTimeFilter<"RiskDocument"> | Date | string
    status?: StringFilter<"RiskDocument"> | string
    updatedAt?: DateTimeFilter<"RiskDocument"> | Date | string
    type?: StringFilter<"RiskDocument"> | string
    uploadedAt?: DateTimeFilter<"RiskDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"RiskDocument"> | string | null
    content?: BytesFilter<"RiskDocument"> | Uint8Array
  }

  export type RiskCreateWithoutRiskActivityInput = {
    id: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastUpdated?: Date | string | null
    Application: ApplicationCreateNestedOneWithoutRiskInput
    RiskDocument?: RiskDocumentCreateNestedManyWithoutRiskInput
  }

  export type RiskUncheckedCreateWithoutRiskActivityInput = {
    id: string
    status: string
    applicationId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastUpdated?: Date | string | null
    RiskDocument?: RiskDocumentUncheckedCreateNestedManyWithoutRiskInput
  }

  export type RiskCreateOrConnectWithoutRiskActivityInput = {
    where: RiskWhereUniqueInput
    create: XOR<RiskCreateWithoutRiskActivityInput, RiskUncheckedCreateWithoutRiskActivityInput>
  }

  export type RiskUpsertWithoutRiskActivityInput = {
    update: XOR<RiskUpdateWithoutRiskActivityInput, RiskUncheckedUpdateWithoutRiskActivityInput>
    create: XOR<RiskCreateWithoutRiskActivityInput, RiskUncheckedCreateWithoutRiskActivityInput>
    where?: RiskWhereInput
  }

  export type RiskUpdateToOneWithWhereWithoutRiskActivityInput = {
    where?: RiskWhereInput
    data: XOR<RiskUpdateWithoutRiskActivityInput, RiskUncheckedUpdateWithoutRiskActivityInput>
  }

  export type RiskUpdateWithoutRiskActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Application?: ApplicationUpdateOneRequiredWithoutRiskNestedInput
    RiskDocument?: RiskDocumentUpdateManyWithoutRiskNestedInput
  }

  export type RiskUncheckedUpdateWithoutRiskActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RiskDocument?: RiskDocumentUncheckedUpdateManyWithoutRiskNestedInput
  }

  export type RiskCreateWithoutRiskDocumentInput = {
    id: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastUpdated?: Date | string | null
    Application: ApplicationCreateNestedOneWithoutRiskInput
    RiskActivity?: RiskActivityCreateNestedManyWithoutRiskInput
  }

  export type RiskUncheckedCreateWithoutRiskDocumentInput = {
    id: string
    status: string
    applicationId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastUpdated?: Date | string | null
    RiskActivity?: RiskActivityUncheckedCreateNestedManyWithoutRiskInput
  }

  export type RiskCreateOrConnectWithoutRiskDocumentInput = {
    where: RiskWhereUniqueInput
    create: XOR<RiskCreateWithoutRiskDocumentInput, RiskUncheckedCreateWithoutRiskDocumentInput>
  }

  export type RiskUpsertWithoutRiskDocumentInput = {
    update: XOR<RiskUpdateWithoutRiskDocumentInput, RiskUncheckedUpdateWithoutRiskDocumentInput>
    create: XOR<RiskCreateWithoutRiskDocumentInput, RiskUncheckedCreateWithoutRiskDocumentInput>
    where?: RiskWhereInput
  }

  export type RiskUpdateToOneWithWhereWithoutRiskDocumentInput = {
    where?: RiskWhereInput
    data: XOR<RiskUpdateWithoutRiskDocumentInput, RiskUncheckedUpdateWithoutRiskDocumentInput>
  }

  export type RiskUpdateWithoutRiskDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Application?: ApplicationUpdateOneRequiredWithoutRiskNestedInput
    RiskActivity?: RiskActivityUpdateManyWithoutRiskNestedInput
  }

  export type RiskUncheckedUpdateWithoutRiskDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RiskActivity?: RiskActivityUncheckedUpdateManyWithoutRiskNestedInput
  }

  export type ApplicationCreateWithoutStripeActivityInput = {
    id?: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    Account: AccountCreateNestedOneWithoutApplicationInput
    Destination: DestinationCreateNestedOneWithoutApplicationInput
    VisaType: VisaTypeCreateNestedOneWithoutApplicationInput
    ApplicationDocument?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderCreateNestedOneWithoutApplicationInput
    Case?: CaseCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerCreateNestedManyWithoutApplicationInput
    Risk?: RiskCreateNestedManyWithoutApplicationInput
    Task?: TaskCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutStripeActivityInput = {
    id?: string
    destinationId: string
    visaTypeId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    ApplicationDocument?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderUncheckedCreateNestedOneWithoutApplicationInput
    Case?: CaseUncheckedCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerUncheckedCreateNestedManyWithoutApplicationInput
    Risk?: RiskUncheckedCreateNestedManyWithoutApplicationInput
    Task?: TaskUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutStripeActivityInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutStripeActivityInput, ApplicationUncheckedCreateWithoutStripeActivityInput>
  }

  export type ApplicationUpsertWithoutStripeActivityInput = {
    update: XOR<ApplicationUpdateWithoutStripeActivityInput, ApplicationUncheckedUpdateWithoutStripeActivityInput>
    create: XOR<ApplicationCreateWithoutStripeActivityInput, ApplicationUncheckedCreateWithoutStripeActivityInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutStripeActivityInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutStripeActivityInput, ApplicationUncheckedUpdateWithoutStripeActivityInput>
  }

  export type ApplicationUpdateWithoutStripeActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUpdateOneRequiredWithoutApplicationNestedInput
    Destination?: DestinationUpdateOneRequiredWithoutApplicationNestedInput
    VisaType?: VisaTypeUpdateOneRequiredWithoutApplicationNestedInput
    ApplicationDocument?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUpdateOneWithoutApplicationNestedInput
    Case?: CaseUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUpdateManyWithoutApplicationNestedInput
    Task?: TaskUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutStripeActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    ApplicationDocument?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUncheckedUpdateOneWithoutApplicationNestedInput
    Case?: CaseUncheckedUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUncheckedUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUncheckedUpdateManyWithoutApplicationNestedInput
    Task?: TaskUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationCreateWithoutTaskInput = {
    id?: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    Account: AccountCreateNestedOneWithoutApplicationInput
    Destination: DestinationCreateNestedOneWithoutApplicationInput
    VisaType: VisaTypeCreateNestedOneWithoutApplicationInput
    ApplicationDocument?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderCreateNestedOneWithoutApplicationInput
    Case?: CaseCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerCreateNestedManyWithoutApplicationInput
    Risk?: RiskCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutTaskInput = {
    id?: string
    destinationId: string
    visaTypeId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    ApplicationDocument?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderUncheckedCreateNestedOneWithoutApplicationInput
    Case?: CaseUncheckedCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerUncheckedCreateNestedManyWithoutApplicationInput
    Risk?: RiskUncheckedCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutTaskInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutTaskInput, ApplicationUncheckedCreateWithoutTaskInput>
  }

  export type TaskActivityCreateWithoutTaskInput = {
    id: string
    status: string
    description: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type TaskActivityUncheckedCreateWithoutTaskInput = {
    id: string
    status: string
    description: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type TaskActivityCreateOrConnectWithoutTaskInput = {
    where: TaskActivityWhereUniqueInput
    create: XOR<TaskActivityCreateWithoutTaskInput, TaskActivityUncheckedCreateWithoutTaskInput>
  }

  export type TaskActivityCreateManyTaskInputEnvelope = {
    data: TaskActivityCreateManyTaskInput | TaskActivityCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationUpsertWithoutTaskInput = {
    update: XOR<ApplicationUpdateWithoutTaskInput, ApplicationUncheckedUpdateWithoutTaskInput>
    create: XOR<ApplicationCreateWithoutTaskInput, ApplicationUncheckedCreateWithoutTaskInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutTaskInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutTaskInput, ApplicationUncheckedUpdateWithoutTaskInput>
  }

  export type ApplicationUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUpdateOneRequiredWithoutApplicationNestedInput
    Destination?: DestinationUpdateOneRequiredWithoutApplicationNestedInput
    VisaType?: VisaTypeUpdateOneRequiredWithoutApplicationNestedInput
    ApplicationDocument?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUpdateOneWithoutApplicationNestedInput
    Case?: CaseUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    ApplicationDocument?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUncheckedUpdateOneWithoutApplicationNestedInput
    Case?: CaseUncheckedUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUncheckedUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUncheckedUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type TaskActivityUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskActivityWhereUniqueInput
    update: XOR<TaskActivityUpdateWithoutTaskInput, TaskActivityUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskActivityCreateWithoutTaskInput, TaskActivityUncheckedCreateWithoutTaskInput>
  }

  export type TaskActivityUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskActivityWhereUniqueInput
    data: XOR<TaskActivityUpdateWithoutTaskInput, TaskActivityUncheckedUpdateWithoutTaskInput>
  }

  export type TaskActivityUpdateManyWithWhereWithoutTaskInput = {
    where: TaskActivityScalarWhereInput
    data: XOR<TaskActivityUpdateManyMutationInput, TaskActivityUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskActivityScalarWhereInput = {
    AND?: TaskActivityScalarWhereInput | TaskActivityScalarWhereInput[]
    OR?: TaskActivityScalarWhereInput[]
    NOT?: TaskActivityScalarWhereInput | TaskActivityScalarWhereInput[]
    id?: StringFilter<"TaskActivity"> | string
    taskId?: StringFilter<"TaskActivity"> | string
    status?: StringFilter<"TaskActivity"> | string
    description?: StringFilter<"TaskActivity"> | string
    timestamp?: DateTimeFilter<"TaskActivity"> | Date | string
    createdAt?: DateTimeFilter<"TaskActivity"> | Date | string
  }

  export type TaskCreateWithoutTaskActivityInput = {
    id: string
    title: string
    description?: string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    dueDate?: Date | string | null
    taskType?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt: Date | string
    taskId: string
    Application: ApplicationCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTaskActivityInput = {
    id: string
    title: string
    description?: string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    dueDate?: Date | string | null
    taskType?: string | null
    status?: string
    applicationId: string
    createdAt?: Date | string
    updatedAt: Date | string
    taskId: string
  }

  export type TaskCreateOrConnectWithoutTaskActivityInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTaskActivityInput, TaskUncheckedCreateWithoutTaskActivityInput>
  }

  export type TaskUpsertWithoutTaskActivityInput = {
    update: XOR<TaskUpdateWithoutTaskActivityInput, TaskUncheckedUpdateWithoutTaskActivityInput>
    create: XOR<TaskCreateWithoutTaskActivityInput, TaskUncheckedCreateWithoutTaskActivityInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTaskActivityInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTaskActivityInput, TaskUncheckedUpdateWithoutTaskActivityInput>
  }

  export type TaskUpdateWithoutTaskActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    Application?: ApplicationUpdateOneRequiredWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTaskActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type ApplicationCreateWithoutVisaTypeInput = {
    id?: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    Account: AccountCreateNestedOneWithoutApplicationInput
    Destination: DestinationCreateNestedOneWithoutApplicationInput
    ApplicationDocument?: ApplicationDocumentCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderCreateNestedOneWithoutApplicationInput
    Case?: CaseCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerCreateNestedManyWithoutApplicationInput
    Risk?: RiskCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityCreateNestedManyWithoutApplicationInput
    Task?: TaskCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateWithoutVisaTypeInput = {
    id?: string
    destinationId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
    ApplicationDocument?: ApplicationDocumentUncheckedCreateNestedManyWithoutApplicationInput
    CardHolder?: CardHolderUncheckedCreateNestedOneWithoutApplicationInput
    Case?: CaseUncheckedCreateNestedManyWithoutApplicationInput
    Passenger?: PassengerUncheckedCreateNestedManyWithoutApplicationInput
    Risk?: RiskUncheckedCreateNestedManyWithoutApplicationInput
    StripeActivity?: StripeActivityUncheckedCreateNestedManyWithoutApplicationInput
    Task?: TaskUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationCreateOrConnectWithoutVisaTypeInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutVisaTypeInput, ApplicationUncheckedCreateWithoutVisaTypeInput>
  }

  export type ApplicationCreateManyVisaTypeInputEnvelope = {
    data: ApplicationCreateManyVisaTypeInput | ApplicationCreateManyVisaTypeInput[]
    skipDuplicates?: boolean
  }

  export type DestinationCreateWithoutVisaTypeInput = {
    id: string
    name: string
    code?: string | null
    Application?: ApplicationCreateNestedManyWithoutDestinationInput
  }

  export type DestinationUncheckedCreateWithoutVisaTypeInput = {
    id: string
    name: string
    code?: string | null
    Application?: ApplicationUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type DestinationCreateOrConnectWithoutVisaTypeInput = {
    where: DestinationWhereUniqueInput
    create: XOR<DestinationCreateWithoutVisaTypeInput, DestinationUncheckedCreateWithoutVisaTypeInput>
  }

  export type ApplicationUpsertWithWhereUniqueWithoutVisaTypeInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutVisaTypeInput, ApplicationUncheckedUpdateWithoutVisaTypeInput>
    create: XOR<ApplicationCreateWithoutVisaTypeInput, ApplicationUncheckedCreateWithoutVisaTypeInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutVisaTypeInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutVisaTypeInput, ApplicationUncheckedUpdateWithoutVisaTypeInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutVisaTypeInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutVisaTypeInput>
  }

  export type DestinationUpsertWithoutVisaTypeInput = {
    update: XOR<DestinationUpdateWithoutVisaTypeInput, DestinationUncheckedUpdateWithoutVisaTypeInput>
    create: XOR<DestinationCreateWithoutVisaTypeInput, DestinationUncheckedCreateWithoutVisaTypeInput>
    where?: DestinationWhereInput
  }

  export type DestinationUpdateToOneWithWhereWithoutVisaTypeInput = {
    where?: DestinationWhereInput
    data: XOR<DestinationUpdateWithoutVisaTypeInput, DestinationUncheckedUpdateWithoutVisaTypeInput>
  }

  export type DestinationUpdateWithoutVisaTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    Application?: ApplicationUpdateManyWithoutDestinationNestedInput
  }

  export type DestinationUncheckedUpdateWithoutVisaTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    Application?: ApplicationUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type AccountCreateWithoutPassword_reset_tokensInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    email: string
    fullName?: string
    areaCode?: string
    phoneNumber?: string
    gender?: string
    password?: string | null
    emailVerified?: boolean
    websiteCreatedAt?: string
    Application?: ApplicationCreateNestedManyWithoutAccountInput
    Case?: CaseCreateNestedManyWithoutAccountInput
    sessions?: sessionsCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutPassword_reset_tokensInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    email: string
    fullName?: string
    areaCode?: string
    phoneNumber?: string
    gender?: string
    password?: string | null
    emailVerified?: boolean
    websiteCreatedAt?: string
    Application?: ApplicationUncheckedCreateNestedManyWithoutAccountInput
    Case?: CaseUncheckedCreateNestedManyWithoutAccountInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutPassword_reset_tokensInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPassword_reset_tokensInput, AccountUncheckedCreateWithoutPassword_reset_tokensInput>
  }

  export type AccountUpsertWithoutPassword_reset_tokensInput = {
    update: XOR<AccountUpdateWithoutPassword_reset_tokensInput, AccountUncheckedUpdateWithoutPassword_reset_tokensInput>
    create: XOR<AccountCreateWithoutPassword_reset_tokensInput, AccountUncheckedCreateWithoutPassword_reset_tokensInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutPassword_reset_tokensInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutPassword_reset_tokensInput, AccountUncheckedUpdateWithoutPassword_reset_tokensInput>
  }

  export type AccountUpdateWithoutPassword_reset_tokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    areaCode?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    Application?: ApplicationUpdateManyWithoutAccountNestedInput
    Case?: CaseUpdateManyWithoutAccountNestedInput
    sessions?: sessionsUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutPassword_reset_tokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    areaCode?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    Application?: ApplicationUncheckedUpdateManyWithoutAccountNestedInput
    Case?: CaseUncheckedUpdateManyWithoutAccountNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateWithoutSessionsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    email: string
    fullName?: string
    areaCode?: string
    phoneNumber?: string
    gender?: string
    password?: string | null
    emailVerified?: boolean
    websiteCreatedAt?: string
    Application?: ApplicationCreateNestedManyWithoutAccountInput
    Case?: CaseCreateNestedManyWithoutAccountInput
    password_reset_tokens?: password_reset_tokensCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutSessionsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    email: string
    fullName?: string
    areaCode?: string
    phoneNumber?: string
    gender?: string
    password?: string | null
    emailVerified?: boolean
    websiteCreatedAt?: string
    Application?: ApplicationUncheckedCreateNestedManyWithoutAccountInput
    Case?: CaseUncheckedCreateNestedManyWithoutAccountInput
    password_reset_tokens?: password_reset_tokensUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutSessionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutSessionsInput, AccountUncheckedCreateWithoutSessionsInput>
  }

  export type AccountUpsertWithoutSessionsInput = {
    update: XOR<AccountUpdateWithoutSessionsInput, AccountUncheckedUpdateWithoutSessionsInput>
    create: XOR<AccountCreateWithoutSessionsInput, AccountUncheckedCreateWithoutSessionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutSessionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutSessionsInput, AccountUncheckedUpdateWithoutSessionsInput>
  }

  export type AccountUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    areaCode?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    Application?: ApplicationUpdateManyWithoutAccountNestedInput
    Case?: CaseUpdateManyWithoutAccountNestedInput
    password_reset_tokens?: password_reset_tokensUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    areaCode?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    Application?: ApplicationUncheckedUpdateManyWithoutAccountNestedInput
    Case?: CaseUncheckedUpdateManyWithoutAccountNestedInput
    password_reset_tokens?: password_reset_tokensUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ApplicationCreateManyAccountInput = {
    id?: string
    destinationId: string
    visaTypeId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
  }

  export type CaseCreateManyAccountInput = {
    id: string
    gmailThreadId?: string | null
    email: string
    subject: string
    status?: string
    lastUpdate?: Date | string
    websiteCreatedAt: string
    applicationId?: string | null
    assignedTo?: string | null
    topic?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type password_reset_tokensCreateManyAccountInput = {
    id: string
    token: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type sessionsCreateManyAccountInput = {
    id: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ApplicationUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    Destination?: DestinationUpdateOneRequiredWithoutApplicationNestedInput
    VisaType?: VisaTypeUpdateOneRequiredWithoutApplicationNestedInput
    ApplicationDocument?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUpdateOneWithoutApplicationNestedInput
    Case?: CaseUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUpdateManyWithoutApplicationNestedInput
    Task?: TaskUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    ApplicationDocument?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUncheckedUpdateOneWithoutApplicationNestedInput
    Case?: CaseUncheckedUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUncheckedUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUncheckedUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUncheckedUpdateManyWithoutApplicationNestedInput
    Task?: TaskUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CaseUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Application?: ApplicationUpdateOneWithoutCaseNestedInput
    EmailThread?: EmailThreadUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EmailThread?: EmailThreadUncheckedUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_reset_tokensUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_reset_tokensUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_reset_tokensUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationDocumentCreateManyApplicationInput = {
    id: string
    name: string
    type: string
    content: Uint8Array
    status?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CaseCreateManyApplicationInput = {
    id: string
    gmailThreadId?: string | null
    email: string
    subject: string
    status?: string
    lastUpdate?: Date | string
    websiteCreatedAt: string
    accountId?: string | null
    assignedTo?: string | null
    topic?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type PassengerCreateManyApplicationInput = {
    id: string
    createdAt?: Date | string
    name?: string | null
    passportNumber?: string | null
    updatedAt?: Date | string | null
    dateOfBirth?: Date | string | null
    fullName?: string | null
    gender?: string | null
    nationality?: string | null
    passportId?: string | null
    status?: string | null
  }

  export type RiskCreateManyApplicationInput = {
    id: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastUpdated?: Date | string | null
  }

  export type StripeActivityCreateManyApplicationInput = {
    id: string
    title?: string | null
    amount?: number | null
    createdAt?: Date | string
    status?: string | null
    type?: string | null
    description?: string | null
    timestamp?: Date | string | null
    transactionId?: string | null
    govFeeRefund?: Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: string | null
  }

  export type TaskCreateManyApplicationInput = {
    id: string
    title: string
    description?: string | null
    assignedTo?: string | null
    assignedToEmail?: string | null
    dueDate?: Date | string | null
    taskType?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt: Date | string
    taskId: string
  }

  export type ApplicationDocumentUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    status?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DocumentMapping?: DocumentMappingUpdateOneWithoutApplicationDocumentNestedInput
  }

  export type ApplicationDocumentUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    status?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DocumentMapping?: DocumentMappingUncheckedUpdateOneWithoutApplicationDocumentNestedInput
  }

  export type ApplicationDocumentUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    status?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Account?: AccountUpdateOneWithoutCaseNestedInput
    EmailThread?: EmailThreadUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EmailThread?: EmailThreadUncheckedUpdateManyWithoutCaseNestedInput
  }

  export type CaseUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gmailThreadId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteCreatedAt?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PassengerUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PassengerUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    passportId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RiskUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RiskActivity?: RiskActivityUpdateManyWithoutRiskNestedInput
    RiskDocument?: RiskDocumentUpdateManyWithoutRiskNestedInput
  }

  export type RiskUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RiskActivity?: RiskActivityUncheckedUpdateManyWithoutRiskNestedInput
    RiskDocument?: RiskDocumentUncheckedUpdateManyWithoutRiskNestedInput
  }

  export type RiskUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StripeActivityUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    govFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StripeActivityUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    govFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StripeActivityUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    govFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeRefund?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    TaskActivity?: TaskActivityUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
    TaskActivity?: TaskActivityUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToEmail?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taskType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailThreadCreateManyCaseInput = {
    id: string
    messageId: string
    fromEmail: string
    toEmail: string
    subject: string
    body: string
    timestamp?: Date | string
    direction: string
    cc?: string | null
    bcc?: string | null
  }

  export type EmailThreadUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    toEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    direction?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    Attachment?: AttachmentUpdateManyWithoutEmailThreadNestedInput
  }

  export type EmailThreadUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    toEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    direction?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    Attachment?: AttachmentUncheckedUpdateManyWithoutEmailThreadNestedInput
  }

  export type EmailThreadUncheckedUpdateManyWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromEmail?: StringFieldUpdateOperationsInput | string
    toEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    direction?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationCreateManyDestinationInput = {
    id?: string
    visaTypeId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
  }

  export type VisaTypeCreateManyDestinationInput = {
    id: string
    name: string
    waitTime?: string | null
    fees?: number | null
    requiredDocuments?: string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ApplicationUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUpdateOneRequiredWithoutApplicationNestedInput
    VisaType?: VisaTypeUpdateOneRequiredWithoutApplicationNestedInput
    ApplicationDocument?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUpdateOneWithoutApplicationNestedInput
    Case?: CaseUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUpdateManyWithoutApplicationNestedInput
    Task?: TaskUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    ApplicationDocument?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUncheckedUpdateOneWithoutApplicationNestedInput
    Case?: CaseUncheckedUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUncheckedUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUncheckedUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUncheckedUpdateManyWithoutApplicationNestedInput
    Task?: TaskUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateManyWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visaTypeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisaTypeUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    waitTime?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    Application?: ApplicationUpdateManyWithoutVisaTypeNestedInput
  }

  export type VisaTypeUncheckedUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    waitTime?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
    Application?: ApplicationUncheckedUpdateManyWithoutVisaTypeNestedInput
  }

  export type VisaTypeUncheckedUpdateManyWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    waitTime?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableFloatFieldUpdateOperationsInput | number | null
    requiredDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    allowedNationalities?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AttachmentCreateManyEmailThreadInput = {
    id: string
    filename: string
    content: Uint8Array
    createdAt?: Date | string
  }

  export type AttachmentUpdateWithoutEmailThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateWithoutEmailThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutEmailThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskActivityCreateManyRiskInput = {
    id: string
    createdAt?: Date | string
    description?: string | null
    type?: string | null
    details?: string | null
    timestamp?: Date | string | null
    title?: string | null
  }

  export type RiskDocumentCreateManyRiskInput = {
    id: string
    name: string
    createdAt?: Date | string
    status?: string
    updatedAt: Date | string
    type: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
    content: Uint8Array
  }

  export type RiskActivityUpdateWithoutRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RiskActivityUncheckedUpdateWithoutRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RiskActivityUncheckedUpdateManyWithoutRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RiskDocumentUpdateWithoutRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    content?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type RiskDocumentUncheckedUpdateWithoutRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    content?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type RiskDocumentUncheckedUpdateManyWithoutRiskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    content?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type TaskActivityCreateManyTaskInput = {
    id: string
    status: string
    description: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type TaskActivityUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskActivityUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskActivityUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateManyVisaTypeInput = {
    id?: string
    destinationId: string
    status: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applicationId: string
    passengerCount?: number | null
    stayingEnd?: Date | string | null
    stayingStart?: Date | string | null
    total?: number | null
    cancellationDetails?: string | null
    cancellationReason?: string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    applyDate?: Date | string | null
    paymentStatus?: string | null
  }

  export type ApplicationUpdateWithoutVisaTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    Account?: AccountUpdateOneRequiredWithoutApplicationNestedInput
    Destination?: DestinationUpdateOneRequiredWithoutApplicationNestedInput
    ApplicationDocument?: ApplicationDocumentUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUpdateOneWithoutApplicationNestedInput
    Case?: CaseUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUpdateManyWithoutApplicationNestedInput
    Task?: TaskUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateWithoutVisaTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    ApplicationDocument?: ApplicationDocumentUncheckedUpdateManyWithoutApplicationNestedInput
    CardHolder?: CardHolderUncheckedUpdateOneWithoutApplicationNestedInput
    Case?: CaseUncheckedUpdateManyWithoutApplicationNestedInput
    Passenger?: PassengerUncheckedUpdateManyWithoutApplicationNestedInput
    Risk?: RiskUncheckedUpdateManyWithoutApplicationNestedInput
    StripeActivity?: StripeActivityUncheckedUpdateManyWithoutApplicationNestedInput
    Task?: TaskUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateManyWithoutVisaTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: StringFieldUpdateOperationsInput | string
    passengerCount?: NullableIntFieldUpdateOperationsInput | number | null
    stayingEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stayingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    cancellationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    applyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}